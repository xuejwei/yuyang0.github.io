<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>scheme笔记</title>
<!-- 2014-07-06 Sun 18:32 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Yu Yang" />
<meta  name="keywords" content="scheme lisp" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/>
<link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript" src="static/js/custom.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="site-title"><a href="/"> Yu Yang's Blog</a></h1>
        <div>
          <a href="###" id="site-nav-btn">菜单</a>
          <ul id="site-nav" class="vertical-nav mobi-hid">
            <li> <a href="/">Home</a></li>
            <li> <a href="/about.html">About</a></li>

            <li> <a href="/tags.html">Tags</a></li>

            <li> <a href="/rss.xml">RSS</a></li>
          </ul>

          <form id="site-search" method="get" action="https://google.com/search">
            <input type="hidden" name="q" value="site:yuyang.farbox.com" />
            <input type="text" name="q" placeholder="Search..." />
            <button class="btn-search" type="submit">Search</button>
          </form>
          <div style="clear:both;"> </div>
        </div>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">scheme笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">scheme笔记</a>
<ul>
<li><a href="#sec-1-1">几个概念&#xa0;&#xa0;&#xa0;<span class="tag"><span class="concept">concept</span></span></a>
<ul>
<li><a href="#sec-1-1-1">identifier</a></li>
<li><a href="#sec-1-1-2">variable</a></li>
<li><a href="#sec-1-1-3">atom</a></li>
<li><a href="#sec-1-1-4">list</a></li>
<li><a href="#sec-1-1-5">S-expression</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Naming Conventions</a></li>
<li><a href="#sec-1-3">core syntactic forms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="core">core</span>&#xa0;<span class="syntactic">syntactic</span>&#xa0;<span class="form">form</span></span></a></li>
<li><a href="#sec-1-4">let&#xa0;&#xa0;&#xa0;<span class="tag"><span class="let">let</span></span></a></li>
<li><a href="#sec-1-5">control flow</a>
<ul>
<li><a href="#sec-1-5-1">if&#xa0;&#xa0;&#xa0;<span class="tag"><span class="if">if</span></span></a></li>
<li><a href="#sec-1-5-2">cond&#xa0;&#xa0;&#xa0;<span class="tag"><span class="cond">cond</span></span></a></li>
<li><a href="#sec-1-5-3">when unless&#xa0;&#xa0;&#xa0;<span class="tag"><span class="when">when</span>&#xa0;<span class="unless">unless</span></span></a></li>
<li><a href="#sec-1-5-4">case&#xa0;&#xa0;&#xa0;<span class="tag"><span class="case">case</span></span></a></li>
<li><a href="#sec-1-5-5">do&#xa0;&#xa0;&#xa0;<span class="tag"><span class="do">do</span></span></a></li>
<li><a href="#sec-1-5-6">map</a></li>
<li><a href="#sec-1-5-7">for-each</a></li>
<li><a href="#sec-1-5-8">apply</a></li>
<li><a href="#sec-1-5-9">multiple values</a></li>
</ul>
</li>
<li><a href="#sec-1-6">内置的函数</a>
<ul>
<li><a href="#sec-1-6-1">predication</a></li>
<li><a href="#sec-1-6-2">list procedure</a></li>
<li><a href="#sec-1-6-3">number procedure</a></li>
<li><a href="#sec-1-6-4">char</a></li>
<li><a href="#sec-1-6-5">string</a></li>
<li><a href="#sec-1-6-6">vector procedure</a></li>
<li><a href="#sec-1-6-7">symbol procedure</a></li>
<li><a href="#sec-1-6-8">Hash Table</a></li>
</ul>
</li>
<li><a href="#sec-1-7">macros</a>
<ul>
<li><a href="#sec-1-7-1">define-syntax</a></li>
<li><a href="#sec-1-7-2">let-syntax与letrec-syntax</a></li>
<li><a href="#sec-1-7-3">syntax-rules</a></li>
<li><a href="#sec-1-7-4">syntax object</a></li>
<li><a href="#sec-1-7-5">syntax-case</a></li>
<li><a href="#sec-1-7-6">with-syntax</a></li>
</ul>
</li>
<li><a href="#sec-1-8">input and output</a>
<ul>
<li><a href="#sec-1-8-1">port</a>
<ul>
<li><a href="#sec-1-8-1-1">default port</a></li>
</ul>
</li>
<li><a href="#sec-1-8-2">输入输出</a></li>
<li><a href="#sec-1-8-3">code example</a></li>
</ul>
</li>
<li><a href="#sec-1-9">递归思想</a></li>
<li><a href="#sec-1-10">continuation</a></li>
<li><a href="#sec-1-11">停机问题</a></li>
<li><a href="#sec-1-12">some example code(the little schemer)</a></li>
</ul>
</li>
<li><a href="#sec-2">racket</a>
<ul>
<li><a href="#sec-2-1">struct(新的数据类型)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="struct">struct</span></span></a>
<ul>
<li><a href="#sec-2-1-1">复制更新</a></li>
<li><a href="#sec-2-1-2">subtypes(类似于继承)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="subtypes">subtypes</span></span></a></li>
</ul>
</li>
<li><a href="#sec-2-2">match(模式匹配)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="match">match</span></span></a></li>
<li><a href="#sec-2-3">module</a>
<ul>
<li><a href="#sec-2-3-1">submodule</a>
<ul>
<li><a href="#sec-2-3-1-1">module*                                                                   :module*:</a></li>
<li><a href="#sec-2-3-1-2">module+                                                                   :module+:</a></li>
</ul>
</li>
<li><a href="#sec-2-3-2">lang</a></li>
<li><a href="#sec-2-3-3">require</a></li>
<li><a href="#sec-2-3-4">provide</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">typed racket</a>
<ul>
<li><a href="#sec-3-1">sample program</a></li>
<li><a href="#sec-3-2">Types</a>
<ul>
<li><a href="#sec-3-2-1">Basic Types</a></li>
<li><a href="#sec-3-2-2">Function Type</a></li>
<li><a href="#sec-3-2-3">Union Type</a></li>
<li><a href="#sec-3-2-4">Recursive Type</a></li>
<li><a href="#sec-3-2-5">Subtyping</a></li>
<li><a href="#sec-3-2-6">Polymorphism</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">scheme笔记</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">几个概念&#xa0;&#xa0;&#xa0;<span class="tag"><span class="concept">concept</span></span></h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">identifier</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
标识符,可以看作是一个唯一的名字,可以用来引用变量,函数等等
</p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">variable</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
变量
</p>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">atom</h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li>a string of characters
</li>
<li>a string of digits
</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">atom?</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (s)
    (<span style="color: #F92672; font-weight: bold;">and</span> (not (pair? s))
         (not (null? s)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">list</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
a collection of atoms enclosed by parentheses. example:
</p>

<pre class="example">
'()
'(a)
'(a b c)
'((a b) c d)
</pre>
<p>
语法描述:
</p>
<pre class="example">
list -&gt; '()
      | (sexp . list)
</pre>
</div>
</div>

<div id="outline-container-sec-1-1-5" class="outline-4">
<h4 id="sec-1-1-5">S-expression</h4>
<div class="outline-text-4" id="text-1-1-5">
<ul class="org-ul">
<li>all lists
</li>
<li>all atoms
</li>
</ul>
<pre class="example">
sexp -&gt; list
      | atom
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Naming Conventions</h3>
<div class="outline-text-3" id="text-1-2">
<ol class="org-ol">
<li>谓词后加? , 但是常用的数字比较=, &lt;, &gt;, &lt;=, &gt;=后面不需要?
</li>
<li>类型测试, pair? , atom?
</li>
<li>字符操作(char-xxx), 字符串操作(string-xxx), 向量操作(vector-xxx)
</li>
<li>类型转换(type1-&gt;type2)
</li>
<li>但函数有副作用时,应该以 ! 结尾, 比如 <code>set!</code>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">core syntactic forms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="core">core</span>&#xa0;<span class="syntactic">syntactic</span>&#xa0;<span class="form">form</span></span></h3>
<div class="outline-text-3" id="text-1-3">
<ol class="org-ol">
<li>top-level <code>define</code> forms
实际就是创建新的绑定,可以绑定 <code>list</code>, <code>lambda procedure</code> 这是几个示例代
码:

<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">double-any</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (f x)
    (f x x)))
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">identical</span>
(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">double-any</span> f x)
  (f x x))

(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">xyz</span> '(x y z))
</pre>
</div>
</li>
<li>constants
BNF:
<pre class="example">
&lt;constant&gt; -&gt; &lt;boolean&gt;
            | &lt;number&gt;
            | &lt;character&gt;
            | &lt;string&gt;
</pre>
</li>

<li>variables
</li>
<li>procedure applications <code>(procedure arg1 ... argn)</code>
求值规则:
<ol class="org-ol">
<li>Find the value of <code>procedure</code>.
</li>
<li>Find the value of <code>arg1</code>.
</li>
<li>Find the value of <code>argn</code>.
</li>
<li>Apply the value of <code>procedure</code> to the values of <code>arg1</code> &#x2026; <code>argn</code>.
</li>
</ol>
</li>
<li><code>quote</code> expressions (')
<ol class="org-ol">
<li>quoting an <code>identifier</code> tells Scheme to treat the identifier as a
<code>symbol</code> rather than as a <code>variable</code>. 也就是说scheme解释器不会去当前的
环境中寻找与该标识符绑定的值, 而是直接将该标识符当作symbol也就是数据处理.
</li>
<li>quoting a list tells scheme to treat the list as data, rather than
as a procedure application
</li>
</ol>
</li>
<li><code>lambda</code> expressions
      <code>(lambda (x) (+ x x)) ==&gt; #&lt;procedure&gt;</code>

<p>
一般形式有这三种:
</p>
<ul class="org-ul">
<li><code>(lambda (var1 var2 ...) exp1 exp2 ...)</code>: var1 var2 &#x2026;会依次赋值
</li>
<li><code>(lambda (var1 var2 . var) exp1 exp2)</code>: var1 var2会依次赋值, 余下的参数
会组成一个列表赋给var
</li>
<li><code>(lambda var exp1 exp2)</code>: 将所有的实参作为一个list赋给var, 注意var没有括号
</li>
</ul>
</li>
<li><code>if</code> expressions: <code>(if test-expr then-expr else-expr)</code> 只有 <code>test-expr</code>
为 <code>#f</code> 时才会运行 <code>else-expr</code>, 所以你一般要使用 <code>null?</code> <code>eq?</code> 这样的函数
来测试
</li>
<li><code>set!</code> expressions(Assignment):  Assignments do not create new bindings,
as with <code>let</code> or <code>lambda</code>, but rather change the values of existing
bindings.也就是说赋值不会像let, lambda那样产生新的绑定,而是会改变已存在绑
定的值,如果你给set!指定的符号不存在,它会报错(set!: cannot set undefined
variable)
</li>
</ol>
<p>
其它的都是一些扩展,也就是可以通过define-syntax定义出来的,比如let,and,or,not等
等,只有以上的部分才需要解释器直接实现的
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">let</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
    [(_ ((x v) ...) e1 e2 ...)
     ((<span style="color: #F92672; font-weight: bold;">lambda</span> (x ...) e1 e2 ...) v ...)]))

(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">and</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
    [(_) #t]
    [(_ e) e]
    [(_ e1 e2 e3 ...)
     (<span style="color: #F92672; font-weight: bold;">if</span> e1 (<span style="color: #F92672; font-weight: bold;">and</span> e2 e3 ...) #f)]))
</pre>
</div>
<p>
   实际上define-syntax实际就是进行模式匹配,像cond,如果匹配那么就进行替换,比
如(and 1)就匹配((_ e) e)所以就被替换为1, _就是and的占位符, 而 <code>pat ...</code> 代表
0个或者多个表达式, 比如 <code>(x v) ...</code> 代表有0个或多个 <code>(x v)</code> 这样的表达式
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">let&#xa0;&#xa0;&#xa0;<span class="tag"><span class="let">let</span></span></h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #75715E;">;;; </span><span style="color: #75715E;">form 1</span>
(<span style="color: #F92672; font-weight: bold;">let</span> ((a exp1)
      (b exp2))
  (body1)
  (body2))
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">form2</span>
(<span style="color: #F92672; font-weight: bold;">let</span> <span style="color: #A6E22E;">f</span> ([a exp1]
        [b exp2])
  (body1)
  (body2))
</pre>
</div>
<p>
由于 <code>scheme</code> 对待中括号与对待小括号是一样的,所以为了可读性, <code>let</code> 一般可以用如下代
码:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> ([a exp1]
      [b exp2])
  (body1)
  (body2))
</pre>
</div>
<p>
form2主要是为了递归, 它使得在函数体中可以引用函数名, 比如下面的代码
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> <span style="color: #A6E22E;">fac</span> ([n 10])
  (<span style="color: #F92672; font-weight: bold;">if</span> (zero? n)
      1
      (* n (fac (sub1 n)))))
</pre>
</div>
<ul class="org-ul">
<li>let: 如上所见,实际就是一个扩展语法,a,b只在body中可见, 所以你在exp2中不能使
用a
</li>
<li>let*: exp2中可以引用a, 也就是a可以用来定义b, 可以用嵌套的 <code>let</code> 来定义
     <code>let*</code>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">let*</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
    [(_ () e1 e2 ...)
     (<span style="color: #F92672; font-weight: bold;">let</span> () e1 e2 ...)]
    [(_ ((x1 v1) (x2 v2) ...) e1 e2 ...)
     (<span style="color: #F92672; font-weight: bold;">let</span> ((x1 v1))
       (<span style="color: #F92672; font-weight: bold;">let*</span> ((x2 v2) ...) e1 e2 ...))]))
</pre>
</div>
</li>
<li>letrec: 主要用来解决定义递归函数时,函数名在函数体中不可见的问题,比如
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> ([sum (<span style="color: #F92672; font-weight: bold;">lambda</span> (lst)
                (<span style="color: #F92672; font-weight: bold;">if</span> (null? lst) 0
                    (+ (car lst) (sum (cdr lst)))))])
  (sum '(1 2 3 4 5)))
</pre>
</div>
<p>
如果运行上面的代码,那么你会 <code>sum undefined</code> 的错误, 原因是 <code>sum</code> 在后面的函数
体中不可见, 所以你使用 <code>(sum (cdr lst))</code> 就会出错,当然你可以使用这种方法
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> ([sum (<span style="color: #F92672; font-weight: bold;">lambda</span> (sum lst)
                (<span style="color: #F92672; font-weight: bold;">if</span> (null? lst) 0
                    (+ (car lst) (sum sum (cdr lst)))))])
  (sum sum '(1 2 3 4 5)))
</pre>
</div>
<p>
但这种方法不够自然,而且比较丑陋,不符合scheme中定义递归函数的一般模式,所以
就引入了 <code>letrec</code>.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">letrec</span> ([sum (<span style="color: #F92672; font-weight: bold;">lambda</span> (ls)
                (<span style="color: #F92672; font-weight: bold;">if</span> (null? ls)
                    0
                    (+ (car ls) (sum (cdr ls)))))])
  (sum '(1 2 3 4 5)))
<span style="color: #75715E;">;; </span><span style="color: #75715E;">the result is 15</span>
</pre>
</div>
</li>
<li>letrec*: 和 <code>letrec</code> 类似, 只是后面的绑定可以引用前面已经绑定的变量
</li>
<li>let-values: 绑定多个变量
syntax:
<ul class="org-ul">
<li>(let-values ((formals expr) &#x2026;) body1 body2 &#x2026;)
</li>
<li>(let*-values ((formals expr) &#x2026;) body1 body2 &#x2026;)
</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let-values</span> ([(a b) (values 1 2)] [c (values 1 2 3)])
  (list a b c)) <span style="color: #75715E;">; </span><span style="color: #75715E;">the result is (1 2 (1 2 3))</span>

(<span style="color: #F92672; font-weight: bold;">let*-values</span> ([(a b) (values 1 2)] [(a b) (values b a)])
  (list a b)) <span style="color: #75715E;">; </span><span style="color: #75715E;">the result is (2 1)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">control flow</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">if&#xa0;&#xa0;&#xa0;<span class="tag"><span class="if">if</span></span></h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
当要写多个表达式时应该加入 <code>begin</code> , 注意 <code>begin</code> 会依次执行它所包含的表达式,并
返回最后一个表达式的值
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">if</span> (test-exp)
    (<span style="color: #F92672; font-weight: bold;">begin</span>
      expression1
      expression2)
    expression3)
</pre>
</div>
<p>
如果 <code>test-exp</code> 为true, 依次执行 <code>expression1</code>, <code>expression2</code> 那么返回
<code>expression2</code> 的值, 之所以需要 <code>begin</code> 是由 <code>if</code> 的语法决定的, <code>if</code> 的语
法如下:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">if</span> (test-exp)
    (true-exp)
    (false-exp))
</pre>
</div>
<p>
    所以如果你在 <code>true-exp</code> 的位置放入多条表达式,那么这些表达式的第二条会
被当作 <code>false-exp</code> ,而且因为 <code>if</code> 后的表达式的条数超出 <code>2</code> 条而报错, 所以
你需要把多条表达式括起来,但是你不能直接加一个括号,比如
</p>

<pre class="example">
((true-exp1)(true-exp2))
</pre>
<p>
   这样之所以不行是因为scheme会将 (true-exp1) 当作procedure求值,这显然不
对, 所以scheme使用begin(更准确的说begin是为了引入side effect), 也就变成
了:
</p>
<pre class="example">
(begin
  (true-exp1)
  (true-exp2))
</pre>
<p>
这就是if使用begin的原因了, 注意在 let, lambda, define,cond的body中都不需
要begin,因为它们都没有if这种特殊的状况.
</p>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">cond&#xa0;&#xa0;&#xa0;<span class="tag"><span class="cond">cond</span></span></h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
内部相当于有个隐含的begin,所以可以直接写多个表达式
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">cond</span> [(test-exp) (exp1) (exp2)]
      [else expression3])
</pre>
</div>
<p>
如果test-exp为true, 那么返回expression2的值
注意一个特殊的形式: =&gt;
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">cond</span> ((assv 'b '((a 1) (b 2))) =&gt; cadr)
      (<span style="color: #F92672; font-weight: bold;">else</span> #f))                       <span style="color: #75715E;">;; </span><span style="color: #75715E;">==&gt;  2</span>
</pre>
</div>
<p>
会将 test-exp的值传递给 =&gt;后面的函数, =&gt;后面必须是一个带一个参数的函数
</p>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">when unless&#xa0;&#xa0;&#xa0;<span class="tag"><span class="when">when</span>&#xa0;<span class="unless">unless</span></span></h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>(when (test-exp) exp1 exp2) : test-exp为真就执行exp1, exp2
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">when</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
    [(_ e0 e1 e2 ...) (<span style="color: #F92672; font-weight: bold;">if</span> e0 (<span style="color: #F92672; font-weight: bold;">begin</span> e1 e2 ...))]))
</pre>
</div>
</li>
<li>(unless (test-exp) exp1 exp2) : 只有当 <code>test-exp</code> 为#f时才会运行body中的
表达式
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4">case&#xa0;&#xa0;&#xa0;<span class="tag"><span class="case">case</span></span></h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
类似于C语言的switch
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> ((x 4) (y 5))
  (<span style="color: #F92672; font-weight: bold;">case</span> (+ x y)
    ((1 3 5 7 9) 'odd)
    ((0 2 4 6 8) 'even)
    (<span style="color: #F92672; font-weight: bold;">else</span> 'out-of-range))) <span style="color: #75715E;">;; </span><span style="color: #75715E;">===&gt; odd</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-5" class="outline-4">
<h4 id="sec-1-5-5">do&#xa0;&#xa0;&#xa0;<span class="tag"><span class="do">do</span></span></h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
<code>syntax: (do ((var init update) ...) (test result ...) expr ...)</code>
</p>

<p>
循环(do ((var init update) &#x2026;) (test res &#x2026;) exp &#x2026;)  var的初始值是init,接
着每一次迭代都绑定到update, (test res..)如果为true,那么就终止循环
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">divisors</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (n)
    (<span style="color: #F92672; font-weight: bold;">do</span> ((i 2 (+ i 1))
         (ls '()
             (<span style="color: #F92672; font-weight: bold;">if</span> (integer? (/ n i))
                 (cons i ls)
                 ls)))
        ((&gt;= i n) ls))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-6" class="outline-4">
<h4 id="sec-1-5-6">map</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
(map procedure list1 list2 &#x2026;) 会返回一个 <code>list</code>
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">map</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> (x y) (* x y))
     '(1 2 3 4)
     '(8 7 6 5))      <span style="color: #75715E;">; </span><span style="color: #75715E;">return (8 14 18 20)</span>
</pre>
</div>
<p>
<code>map</code> 与 <code>for-each</code> 可以代替许多循环的工作, 而且逻辑上比循环更清晰.
</p>
</div>
</div>

<div id="outline-container-sec-1-5-7" class="outline-4">
<h4 id="sec-1-5-7">for-each</h4>
<div class="outline-text-4" id="text-1-5-7">
<p>
和 <code>map</code> 类似但是不返回一个list作为结果, 也就是说 <code>for-each</code> 是用来产生side
effect.
</p>
</div>
</div>

<div id="outline-container-sec-1-5-8" class="outline-4">
<h4 id="sec-1-5-8">apply</h4>
<div class="outline-text-4" id="text-1-5-8">
<p>
(apply procedure obj &#x2026; list)
</p>
<ul class="org-ul">
<li><code>(apply + '(4 5)) ===&gt; 9</code>
</li>
<li><code>(apply min  5 1 3 '(6 8 3 2 5))</code> 结果是1
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5-9" class="outline-4">
<h4 id="sec-1-5-9">multiple values</h4>
<div class="outline-text-4" id="text-1-5-9">
<ul class="org-ul">
<li>(values obj &#x2026;) :返回多个值,注意它的返回值可以用 <code>let-values</code> 来绑定,不能用 <code>define</code>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let-values</span> ([(a b) (values 1 2)])
  (+ a b))
</pre>
</div>
</li>
<li>(call-with-values producer consumer): producer产生多个值, 然后将这些值传
递给consumer.注意producer必须可以不带参数的方式来调用
<div class="org-src-container">

<pre class="src src-scheme">(call-with-values
  (<span style="color: #F92672; font-weight: bold;">lambda</span> () (values 'bond 'james))
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x y) (cons y x)))  <span style="color: #75715E;">; </span><span style="color: #75715E;">the result is (james . bond)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">内置的函数</h3>
<div class="outline-text-3" id="text-1-6">
</div><div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">predication</h4>
<div class="outline-text-4" id="text-1-6-1">
<ol class="org-ol">
<li>= : 只用来比较整数, 不要用来比较浮点数
</li>
<li>eq? : 可以类似的看作是指针比较, 即便是内容相同,但是如果是两个不同对象,它
就返回 <code>#f</code>, 比如 <code>(eq? (cons 'a 'b) (cons 'a 'b))</code> 虽然是同样的list, 可
是它在内存中的位置不同,所以为 #f. 有以下几种情况是相等的.
<ul class="org-ul">
<li>#t, #f, 两个identifier的值如果都是#t或者#f,那么它们相等
</li>
<li>相同的符号(symbol), 比如

<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">sym1</span> 'hello)
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">sym2</span> 'hello)
(eq? sym1 sym2)
</pre>
</div>
</li>
<li>'()
</li>
</ul>
</li>
<li>eqv? : 和 <code>eq?</code> 很类似, 只是它在一些 <code>eq?</code> 没有定义的地方也可以使用
</li>
<li>equal? : 只要内容相同,它就会返回 #t,可以认为它的检查比 <code>eq?</code> 宽松
</li>
<li>boolean? : 等价于 <code>(lambda (x) (or (eq? x #t) (eq? x #f)))</code>
</li>
<li>null? : 只作用于list, only <code>(null? '())</code> return <code>#t</code>.
</li>
<li>pair? :
</li>
<li>number? :
</li>
<li>complex? :
</li>
<li>rational? :
</li>
<li>real? :
</li>
<li>integer? :
</li>
<li>char? :
</li>
<li>string? :
</li>
<li>vector? :
</li>
<li>symbol? :
</li>
<li>procedure? :
</li>
<li>bytevector? :
</li>
<li>hashtable? :
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2">list procedure</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
<code>list</code> 的语法定义:
</p>
<pre class="example">
List ::= '()
     ::= (Sexp . List)
</pre>
<ol class="org-ol">
<li>cons: (cons 'a 'b) ==&gt; (a . b),只能带两个参数
</li>
<li>cons* : (cons* 'a 'b 'c) ==&gt; (a b . c)    (cons* 'a 'b '(c)) ==&gt; (a b c)
</li>
<li>car: the firsts element of pair (<b>only for non-empty list</b> )
</li>
<li>cdr: Only for non-empty list, the cdr of any non-empty list is also a list.
</li>
<li>set-car! :有副作用, 会原地改变pair的值
</li>
<li>set-cdr! :
</li>
<li>car, caar, caaar&#x2026;etc: 连续执行n次(a的次数)car
(caar '((5)) ) ===&gt; 5
</li>
<li>cdr cddr cdddr &#x2026;etc : 连续执行n次(d的个数)cdr
</li>
<li>cadar : (car (cdr (car lst))) 记住按照顺序从左到右,最右边的先对list起作用
</li>
<li>list: 创建一个list eg: (list 1 2 3 4) ===&gt; '(1 2 3 4)
</li>
<li>length: list的长度
</li>
<li>append: 将一个list添加另一个list的后边,eg: (append '(1 2) '(3 4)) ===&gt; '(1 2 3 4)
</li>
<li>reverse: 将list倒转
</li>
<li>(list-ref list n): 第n个元素
</li>
<li>(list-tail list n) : 倒数第n个元素
</li>
<li>memq memv member memp 分别用eq? eqv? equal? 指定的procedure 来测试一个元
素是否属于list, 如果属于那么就返回包括该元素以及该元素后面的元素组成的
list, <code>(memq 'a '(b c a d e)) --&gt; (a d e)</code>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">memq</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x ls)
    (<span style="color: #F92672; font-weight: bold;">cond</span>
      ((null? ls) #f)
      ((eq? (car ls) x) ls)
      (<span style="color: #F92672; font-weight: bold;">else</span> (memq x (cdr ls))))))
</pre>
</div>
</li>
<li>remq (obj list) remv remove remp 删除list中的所有obj
</li>
<li>assq assv assoc assp 可以看做是关联数组((key1 . val1) (key2 . val2) &#x2026;)
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">assq</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x ls)
    (<span style="color: #F92672; font-weight: bold;">cond</span>
      ((null? ls) #f)
      ((eq? (caar ls) x) (car ls))
      (<span style="color: #F92672; font-weight: bold;">else</span> (assq x (cdr ls))))))
</pre>
</div>
<p>
返回第一个匹配的pair
</p>
</li>
<li>(filter procedure list): return a list of the elements of list for which
procedure returns true
</li>
<li>(partition procedure list): 返回两个list,第一个list包含所以使
       <code>procedure</code> 为#f的元素,第二个包含所有使 <code>procedure</code> 为 <code>#f</code> 的元素,
       <code>partition</code> 的返回值可以使用 <code>let-values</code> 来绑定或者使用
       <code>call-with-values</code> 来调用其它函数
</li>
<li>(find procedure list) : 返回第一个使procedure为#t的元素
</li>
<li>(map f list1 list2 &#x2026;)
</li>
<li>(foldl f init list1 list2 &#x2026;): <b>racket 的内置版本有bug</b>
</li>
<li>(foldr f init list1 list2 &#x2026;):
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">foldl</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (f x ls)
    (<span style="color: #F92672; font-weight: bold;">cond</span>
     [(null? ls) x]
     [else
      (foldl f (f x (car ls)) (cdr ls))])))
<span style="color: #75715E;">;; </span><span style="color: #75715E;">(foldl op init '(1 2 3 4))</span>
<span style="color: #75715E;">;; </span><span style="color: #75715E;">we can think foldl's behavior like this: (init op 1 op 2 op 3 op 4)</span>
<span style="color: #75715E;">;; </span><span style="color: #75715E;">op has left associativity</span>
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">foldr</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (f x ls)
    (<span style="color: #F92672; font-weight: bold;">cond</span>
     [(null? ls) x]
     [else
      (f (car ls) (foldr f x (cdr ls)))])))
<span style="color: #75715E;">;; </span><span style="color: #75715E;">(foldr op init '(1 2 3 4 5))</span>
<span style="color: #75715E;">;; </span><span style="color: #75715E;">we can think foldl's behavior like this: (1 op 2 op 3 op 4 op init)</span>
<span style="color: #75715E;">;; </span><span style="color: #75715E;">op has right associativity</span>
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3">number procedure</h4>
<div class="outline-text-4" id="text-1-6-3">
<ol class="org-ol">
<li>zero? :
</li>
<li>positive? :
</li>
<li>negative? :
</li>
<li>even? :
</li>
<li>odd? : 奇数
</li>
<li>数学函数: max, min, floor, ceiling(向+无穷取整), truncate(向0取整),round(最接近的整数),
abs,gcd,expt(指数),三角系列函数(san,cos&#x2026;.)
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-6-4" class="outline-4">
<h4 id="sec-1-6-4">char</h4>
<div class="outline-text-4" id="text-1-6-4">
<p>
字符使用 <code>#\x</code> 来表示,比如 <code>a</code> 就是 <code>#\a</code>,
</p>
<ul class="org-ul">
<li>(char=? char1 char2 char3 &#x2026;)
</li>
<li>(char&lt;? char1 char2 char3 &#x2026;)
</li>
<li>(char&gt;? char1 char2 char3 &#x2026;)
</li>
<li>(char&lt;=? char1 char2 char3 &#x2026;)
</li>
<li>(char&gt;=? char1 char2 char3 &#x2026;)
</li>
<li>(char-ci=? char1 char2 char3 &#x2026;) 大小写敏感
</li>
<li>(char-ci&lt;? char1 char2 char3 &#x2026;)
</li>
<li>(char-ci&gt;? char1 char2 char3 &#x2026;)
</li>
<li>(char-ci&lt;=? char1 char2 char3 &#x2026;)
</li>
<li>(char-ci&gt;=? char1 char2 char3 &#x2026;)
</li>

<li>(char-upcase char) :大写,相对应的还有个char-downcase
</li>
<li>(char-&gt;integer char)
</li>
<li>(integer-&gt;char n)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-6-5" class="outline-4">
<h4 id="sec-1-6-5">string</h4>
<div class="outline-text-4" id="text-1-6-5">
<p>
双引号内的是字符串
</p>
<ul class="org-ul">
<li>(string=? char1 char2 char3 &#x2026;)
</li>
<li>(string&lt;? char1 char2 char3 &#x2026;)
</li>
<li>(string&gt;? char1 char2 char3 &#x2026;)
</li>
<li>(string&lt;=? char1 char2 char3 &#x2026;)
</li>
<li>(string&gt;=? char1 char2 char3 &#x2026;)
</li>
<li>(string-ci=? char1 char2 char3 &#x2026;) 大小写敏感
</li>
<li>(string-ci&lt;? char1 char2 char3 &#x2026;)
</li>
<li>(string-ci&gt;? char1 char2 char3 &#x2026;)
</li>
<li>(string-ci&lt;=? char1 char2 char3 &#x2026;)
</li>
<li>(string-ci&gt;=? char1 char2 char3 &#x2026;)
</li>
<li>(string char &#x2026;): 构建个包含指定的字符的字符串
</li>
<li>(make-string n), (make-string n char)
</li>
<li>(string-append string &#x2026;)
</li>
<li>(substring string start end)
</li>
<li>(string-upcase string)
</li>
<li>(string-&gt;list): 把string转换成包含char的list
</li>
<li>(char-&gt;list lst)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-6" class="outline-4">
<h4 id="sec-1-6-6">vector procedure</h4>
<div class="outline-text-4" id="text-1-6-6">
<p>
list访问时需要遍历,不够高效, vector可以像数组一样O(1)时间内访问
</p>
<ol class="org-ol">
<li>(vector obj &#x2026;)
</li>
<li>make-vector: (make-vector 5 'a) ===&gt;  #(a a a a a)
</li>
<li>vector-length: vector的长度
</li>
<li>(vector-ref vec n)
</li>
<li>(vector-set! vec n obj)
</li>
<li>(vector-fill vec obj): 所有的元素都替换为obj
</li>
<li>list-&gt;vector :
</li>
<li>vector-&gt;list :
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-6-7" class="outline-4">
<h4 id="sec-1-6-7">symbol procedure</h4>
<div class="outline-text-4" id="text-1-6-7">
<p>
每一个symbol在解释器内部都是指向同一个对象,所以用eq?来测试相同的symbol会返
回#t, 这也使得比较操作很高效
</p>
<ol class="org-ol">
<li>symbol=? :symbol是否相等,也可以用eq?来比较
</li>
<li>symbol-&gt;string:
</li>
<li>string-&gt;symbol:
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-6-8" class="outline-4">
<h4 id="sec-1-6-8">Hash Table</h4>
<div class="outline-text-4" id="text-1-6-8">
<ul class="org-ul">
<li>(make-eq-hashtable) : 使用eq?来比较两个key, 返回一个hashtable
</li>
<li>(make-eq-hashtable size)
</li>
<li>(make-eqv-hashtable) : 使用eqv?来比较两个key
</li>
<li>(make-eqv-hashtable size)
</li>
<li>(make-hashtable hash equiv?) : hash指定hash函数, equiv?指定比较两个key的
函数
</li>
<li>(make-hashtable hash equiv? size)
</li>

<li>(hashtable-set! hashtable key obj) :
</li>
<li>(hashtable-ref hashtable key default) :
</li>
<li>(hashtable-delete! hashtable key) :
</li>
<li>(hashtable-size hashtable) : hashtable的大小
</li>
<li>(hashtable-contains? hashtable key) :测试是否包含指定的key
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">macros</h3>
<div class="outline-text-3" id="text-1-7">
<p>
定义一个宏实际上就是把一个keyword与一个 macro transformer 绑定, 一个macro
transformer一般就是一个带有一个参数的函数, 而macro transformer的输入是一个原
始代码的syntax object, 输出则是包含转换后代码的 syntax
object. <code>syntax-rules</code> 返回的就是一个macro transform.所以你可以抛开
<code>syntax-rules</code> 而这样写一个宏:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">self-as-string</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (stx)
    (datum-&gt;syntax stx
                   (format <span style="color: #E6DB74;">"~s"</span> (syntax-&gt;datum stx)))))
</pre>
</div>
</div>
<div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1">define-syntax</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
和define类似
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">let*</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
    [(_ () b1 b2 ...) (<span style="color: #F92672; font-weight: bold;">let</span> () b1 b2 ...)]
    [(_ ((i1 e1) (i2 e2) ...) b1 b2 ...)
     (<span style="color: #F92672; font-weight: bold;">let</span> ([i1 e1])
       (<span style="color: #F92672; font-weight: bold;">let*</span> ([i2 e2] ...) b1 b2 ...))]))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2">let-syntax与letrec-syntax</h4>
<div class="outline-text-4" id="text-1-7-2">
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> ([f (<span style="color: #F92672; font-weight: bold;">lambda</span> (x) (+ x 1))])
  (<span style="color: #F92672; font-weight: bold;">let-syntax</span> ([f (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
                    [(_ x) x])]
               [g (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
                    [(_ x) (f x)])])
    (list (f 1) (g 1)))) <span style="color: #75715E;">;; </span><span style="color: #75715E;">(1 2)</span>

(<span style="color: #F92672; font-weight: bold;">let</span> ([f (<span style="color: #F92672; font-weight: bold;">lambda</span> (x) (+ x 1))])
  (<span style="color: #F92672; font-weight: bold;">letrec-syntax</span> ([f (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
                       [(_ x) x])]
                  [g (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
                       [(_ x) (f x)])])
    (list (f 1) (g 1)))) <span style="color: #75715E;">;; </span><span style="color: #75715E;">(1 1)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7-3" class="outline-4">
<h4 id="sec-1-7-3">syntax-rules</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
基本语法: <code>(syntax-rules (literal ...) (pattern template) ...)</code>
</p>

<p>
返回一个transformer, 实际就是一个 <code>procedure</code>, 这个 <code>procedure</code> 接受一个
syntax object,然后返回一个syntax object.
</p>
<ul class="org-ul">
<li>literal: 一些关键字, 出现在pattern会原样匹配
</li>
<li>pattern: 用于匹配输入的表达式的模式
</li>
<li>template: 输出,记住template是原样输出,这是和syntax-case的最大区别.
</li>
<li>下划线'<sub>'</sub>: 可以匹配任何结构,一般用来代表宏名
</li>
<li>&#x2026; : 代表前面的部分重复0次或者多次
</li>
</ul>
<p>
一个例子,这个例子实现一个类 <code>if</code> 的条件判断语句,他的形式是 <code>(my-if cond then
    exp1 else exp2)</code> 这看起来更可读性更好:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">my-if</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> (then else)
    [(_ condition then true-exp else false-exp)
     (<span style="color: #F92672; font-weight: bold;">if</span> condition true-exp false-exp)]))
</pre>
</div>
<p>
<code>then, else</code> 是关键字,所以它会原样的匹配输入
</p>
</div>
</div>

<div id="outline-container-sec-1-7-4" class="outline-4">
<h4 id="sec-1-7-4">syntax object</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
<code>(syntax template)</code> 的缩写为 <code>#'template</code>, syntax和quote很类似,只是它会将
template中的pattern variable替换掉, 并且会绑定上下文信息
</p>
<ol class="org-ol">
<li>syntax: 创建一个字面的 syntax object,比如 <code>(syntax '(+ 1 x))</code>, 简写
       <code>#'(+ 1 x)</code>.
</li>
<li>syntax-&gt;datum: 将一个syntax object转换为它原来的内容.
</li>
<li>identifier? : 测试一个syntax object 是不是标识符
</li>
<li>syntax-e : 只解包一层.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-7-5" class="outline-4">
<h4 id="sec-1-7-5">syntax-case</h4>
<div class="outline-text-4" id="text-1-7-5">
<p>
比 <code>syntax-rules</code> 更具一般性,而且更通用, 使用syntax-case的一般形式是:
</p>
<pre class="example">
(define-syntax macro-name
   (lambda (x)
     (syntax-case x (other keywords go here if any)
       [
         (macro-name macro-arg1 macro-arg2)
         ;;Expansion of macro (one or multiple forms)
         ;;(syntax is a reserved word)
         (syntax (expansion of macro goes here))
       ]  ...
 )))
</pre>
<p>
解释一下上面的代码: 整个lambda定义的就是一个macro transformer, 它的唯一参数
x 实际就是一个包含了原始代码的syntax object. 通过syntax-case 来匹配x,然后返
回一个包含了转换后代码的syntax object
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">my-if</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
    (syntax-case x (then else)
      [(_ condition then true-exp else false-exp)
       (<span style="color: #F92672; font-weight: bold;">syntax</span> (<span style="color: #F92672; font-weight: bold;">if</span> condition true-exp false-exp))])))
<span style="color: #75715E;">;;</span><span style="color: #75715E;">Define a new macro</span>
(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">swap!</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
    <span style="color: #75715E;">;;</span><span style="color: #75715E;">we don't have any keywords this time</span>
    (syntax-case x ()
      [(swap! a b)
       (<span style="color: #F92672; font-weight: bold;">syntax</span>
        (<span style="color: #F92672; font-weight: bold;">let</span> ((c a))
          (set! a b)
          (set! b c)))]
      )))

(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">syntax-rules</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
    (syntax-case x ()
      [(_ (i ...) ((keyword . pattern) template) ...)
       #'(<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
           (syntax-case x (i ...)
             [(_ . pattern) #'template] ...))])))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7-6" class="outline-4">
<h4 id="sec-1-7-6">with-syntax</h4>
<div class="outline-text-4" id="text-1-7-6">
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">with-syntax</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
    (syntax-case x ()
      [(_ ((p e) ...) b1 b2 ...)
       #'(syntax-case (list e ...) ()
           [(p ...) (<span style="color: #F92672; font-weight: bold;">let</span> () b1 b2 ...)])])))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">input and output</h3>
<div class="outline-text-3" id="text-1-8">
</div><div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1">port</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
scheme的输入输出用到一个叫做port的对象,port也是first class object, port有很
多种类,比如文件,字符缓冲区, tcp网络连接, 管道等等
</p>
<ol class="org-ol">
<li>文件:
<ul class="org-ul">
<li>(open-output-file fname) : 返回一个port,用于将内容写入到文件
</li>
<li>(open-input-file  fname) : 返回一个port用于读取指定文件的内容
</li>
<li>(close-output-port port)
</li>
<li>(close-input-port port)
</li>
</ul>
<p>
还有一种常用方式(更简单, 会自动关闭port):
</p>
<ul class="org-ul">
<li>(call-with-input-file filename proc) : 打开filename并将得到的port传递
给proc, 并且调用完成时会关闭port
</li>
<li>(call-with-output-file filename proc) : 打开filename并将得到的port传递
给proc, 并且调用完成时会关闭port
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">call-with-output-file</span> <span style="color: #E6DB74;">"data"</span>
  <span style="color: #A6E22E;">#:exists</span> 'truncate
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (out)
    (display <span style="color: #E6DB74;">"hello"</span> out)))

(<span style="color: #F92672; font-weight: bold;">call-with-input-file</span> <span style="color: #E6DB74;">"data"</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (in)
    (read-line in)))
</pre>
</div>
</li>
</ul>
</li>
<li>字符缓冲区
<ul class="org-ul">
<li>(open-output-string) :
</li>
<li>(open-input-string "xxx"):
</li>
</ul>
</li>
</ol>
</div>
<div id="outline-container-sec-1-8-1-1" class="outline-5">
<h5 id="sec-1-8-1-1">default port</h5>
<div class="outline-text-5" id="text-1-8-1-1">
<p>
默认解释器会打开2个port, 一个输入,一个输出,分别会绑定到shell的输入输出,很
多实现还会打开一个error port,用于IO的scheme procedure都可以带一个可选的参
数port, 如果不指定port, 那么就使用默认的port, 默认的port有这两个函数获得
</p>
<ul class="org-ul">
<li>(current-input-port)
</li>
<li>(current-output-port)
</li>
</ul>
<p>
如果要改变默认的port,可以使用下面的两个函数:
</p>
<ul class="org-ul">
<li>(with-input-from-file filename thunk) : 将默认的 input port重新绑定到文
件,这可以实现重定向
</li>
<li>(with-output-from-file filename thunk) : 将默认的 output port重新绑定到
文件,这可以实现重定向
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2">输入输出</h4>
<div class="outline-text-4" id="text-1-8-2">
<ul class="org-ul">
<li>输入:
<ol class="org-ol">
<li>read: 它会自动将读入的内容转换为scheme内置的数据结构,实际是一个递归下
降的parser
</li>
<li>(read-char), (read-char input-port): next character
</li>
</ol>
</li>
<li>输出:
<ol class="org-ol">
<li>print
</li>
<li>write
</li>
<li>display
</li>
<li>printf: 可以指定一个字符串来格式化,用的较多
</li>
<li>fprintf: 写入文件,多一个port参数
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-3" class="outline-4">
<h4 id="sec-1-8-3">code example</h4>
<div class="outline-text-4" id="text-1-8-3">
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">call-with-input-file</span> <span style="color: #E6DB74;">"myfile.ss"</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (p)
    (<span style="color: #F92672; font-weight: bold;">let</span> <span style="color: #A6E22E;">f</span> ((x (read p)))
      (<span style="color: #F92672; font-weight: bold;">if</span> (eof-object? x)
          '()
          (cons x (f (read p)))))))

(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">read-word</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (p)
    (list-&gt;string
      (<span style="color: #F92672; font-weight: bold;">let</span> <span style="color: #A6E22E;">f</span> ()
        (<span style="color: #F92672; font-weight: bold;">let</span> ((c (peek-char p)))
          (<span style="color: #F92672; font-weight: bold;">cond</span>
            ((eof-object? c) '())
            ((char-alphabetic? c)
             (read-char p)
             (cons c (f)))
            (<span style="color: #F92672; font-weight: bold;">else</span> '())))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">递归思想</h3>
<div class="outline-text-3" id="text-1-9">
<p>
递归的思想要从逻辑上理解，在设计一个递归函数时，一开始就要明确该函数在逻辑上
的作用(不要一开始就陷入编码细节中)，然后分清该函数在逻辑上与子问题的联系，并
以此为 依据来进行函数体的设计, 特别需要注意检查结束条件,比如加法(0), 乘法
(1), list('())就是一些结束条件.
</p>

<p>
递归函数的设计要点：
</p>
<ol class="org-ol">
<li>要明确检查终止条件（null？ zero？）
</li>
<li>要明确与子问题的关系，弄清分类的情况（cond）
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">continuation</h3>
<div class="outline-text-3" id="text-1-10">
<p>
scheme中获得当前continuation的构造是call/cc, let/cc
</p>
<div class="org-src-container">

<pre class="src src-scheme">(let/cc k                               <span style="color: #75715E;">;</span><span style="color: #75715E;">k is the continuation</span>
        body)
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">identical</span>
(<span style="color: #F92672; font-weight: bold;">call/cc</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> (k)                    <span style="color: #75715E;">;</span><span style="color: #75715E;">k is the continuation</span>
           body))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">停机问题</h3>
<div class="outline-text-3" id="text-1-11">
<div class="org-src-container">

<pre class="src src-scheme"><span class="linenr">1: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">last-try</span>
<span class="linenr">2: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> ( x )
<span class="linenr">3: </span>    (<span style="color: #F92672; font-weight: bold;">and</span> ( will-stop ? last-try)
<span class="linenr">4: </span>         ( eternity x ))))
</pre>
</div>
<p>
上述代码中:eternity会永远运行,比如:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">eternity</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
    (eternity x)))
</pre>
</div>
<p>
假设存在停机函数 <code>will-stop?</code>, <code>will-stop?</code> 可以测试出一个函数是否会停机.那么:
</p>
<ol class="org-ol">
<li>假设 <code>last-try</code> 会停机, 那么 <code>(will-stop? last-try)</code> 返回 #t, 因此也就会运行
   <code>(eternity x)</code>, 前面说了, eternity会永远运行, 所以 <code>last-try</code> 不会停机.
</li>
<li>假设 <code>last-try</code> 不停机, 那么 <code>(will-stop? last-try)</code> 返回 #f, 因此也就不会运
行 <code>(eternity x)</code>, 那么 <code>last-try</code> 很显然就会返回. 所以 <code>last-try</code> 会停机
</li>
</ol>
<p>
因此这就是个悖论.因此停机函数 will-stop?不存在
</p>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">some example code(the little schemer)</h3>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">racket</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">struct(新的数据类型)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="struct">struct</span></span></h3>
<div class="outline-text-3" id="text-2-1">
<p>
语法形式: <code>(struct struct-id (field-id ...))</code>
</p>
<ul class="org-ul">
<li>struct-id : 是一个constructor, 可以用来构建一个该数据类型的实例
</li>
<li>struct-id? :一个predication,测试是否是该数据类型的实例
</li>
<li>struct-id-field-id: 从实例中获取 <code>field-id</code> 属性的值
</li>
</ul>
<p>
下面来看个例子:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(struct posn (x y))                     <span style="color: #75715E;">;</span><span style="color: #75715E;">&#23450;&#20041;&#19968;&#20010;posn&#31867;&#22411;</span>
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">pos1</span> (posn 1 2))                <span style="color: #75715E;">;</span><span style="color: #75715E;">struct-id: &#26500;&#24314;&#19968;&#20010;posn&#23454;&#20363;</span>
(posn? pos1)                            <span style="color: #75715E;">;</span><span style="color: #75715E;">struct-id?: &#26159;&#21542;&#20026;&#19968;&#20010;posn&#23545;&#35937;&#23454;&#20363;</span>
(posn-x pos1)                           <span style="color: #75715E;">;</span><span style="color: #75715E;">struct-id-field-id: &#33719;&#24471;x&#23646;&#24615;</span>
</pre>
</div>
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">复制更新</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
根据已有对象更新其中的特定域然后返回新对象
</p>

<p>
语法形式: <code>(struct-copy struct-id struct-expr [field-id expr] ...)</code>
</p>
<pre class="example">
Examples:

&gt; (define p1 (posn 1 2))
&gt; (define p2 (struct-copy posn p1 [x 3]))
&gt; (list (posn-x p2) (posn-y p2))

'(3 2)
&gt; (list (posn-x p1) (posn-x p2))

'(1 3)
</pre>
</div>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">subtypes(类似于继承)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="subtypes">subtypes</span></span></h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
语法形式: <code>(struct struct-id super-id (field-id ...))</code>
</p>
<div class="org-src-container">

<pre class="src src-scheme">(struct posn (x y))
(struct pos3d posn (z))
</pre>
</div>
<p>
那么pos3d就有 <code>(x y z)</code> 三个属性
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">match(模式匹配)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="match">match</span></span></h3>
<div class="outline-text-3" id="text-2-2">
<p>
正则表达式只能用来匹配字符串,而 <code>match</code> 可以用来匹配任何的 <code>scheme value</code>,
它的语法形式如下:
</p>
<pre class="example">
(match target-expr
  [pattern expr ...+] ...)
</pre>
<p>
将 <code>target-expr</code> 与 pattern匹配, 如果匹配成功就执行后面的expr, 对pattern的
语法要做以下说明:
</p>
<ul class="org-ul">
<li>&#x2026; 或 <span class="underline">_</span> :  代表0次或者多次
</li>
<li>..k 或 _<sub>k</sub> : 代表至少 <code>k</code> 此
下面是一个将let转换为等价的lambda形式的例子
<div class="org-src-container">

<pre class="src src-scheme">(match '(<span style="color: #F92672; font-weight: bold;">let</span> ([a 1]
              [b 2])
          (set! a 11)
          (- a b))
       [`(<span style="color: #F92672; font-weight: bold;">let</span> ([,var* ,val*] ...) ,body* ...)
        `((<span style="color: #F92672; font-weight: bold;">lambda</span> (,@var*)
            ,@body*) ,@val*)])
</pre>
</div>
<p>
注意因为&#x2026;的作用,上面的var*, val*, body*都是列表, 所以在后面需要使用 ,@来
分解.
</p>
</li>
<li>literal: 字面值直接用 <code>equal?</code> 测试是否相等
<div class="org-src-container">

<pre class="src src-scheme">(match 2
       [1 'one]
       [2 'two]
       [3 'three])
(match #f
       [#t 'yes]
       [#f 'no])
</pre>
</div>
</li>
<li>(list lvp &#x2026;): 会绑定对应的标识符,注意几个特殊符号,vector和list类似
<div class="org-src-container">

<pre class="src src-scheme">(match '(1 + 2)
[(list a '+ b) (+ a b)])         <span style="color: #75715E;">;</span><span style="color: #75715E;">return 3</span>

(match '(1 2 3)
[(list 1 a ...) a])                 <span style="color: #75715E;">;</span><span style="color: #75715E;">return '(2 3)</span>

(match '(1 2 3 4)
[(list 1 a ..3) a]
[_ 'else])                          <span style="color: #75715E;">;</span><span style="color: #75715E;">return '(2 3 4)</span>
</pre>
</div>
<p>
上例中 <code>a b</code> 就被绑定为 1, 2
</p>
</li>
<li>(struct-id pat &#x2026;)或者(struct struct-id (pat &#x2026;)):匹配一个实例,并且绑定
一些变量
<div class="org-src-container">

<pre class="src src-scheme">(define-struct tree (val left right))
(match (make-tree 0 (make-tree 1 #f #f) #f)
       [(tree a (tree b  _ _) _) (list a b)])       <span style="color: #75715E;">;</span><span style="color: #75715E;">'(0 1)</span>
</pre>
</div>
</li>
<li>(struct struct-id _) :匹配任何 struct-id的实例
</li>
<li>(? expr pat &#x2026;): expr是一个predication, 只有它返回true的时候,才会匹配后
面的pat
<div class="org-src-container">

<pre class="src src-scheme">(match '(1 3 5)
       [(list (? odd?) ...) 'yes])
</pre>
</div>
<p>
它的工作原理是这样,以下面的例子为例:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(match '((1 2) 3 6)
       [`(,(? pred? `(,a1 ,a2)) ,b ,c) `(,a1 ,b ,c)])
</pre>
</div>
<p>
如果上面的例子匹配, 那么b, c应该分别绑定3, 6, 那么前面的 <code>(? pred? `(,a1
     ,a2))</code> 应该匹配(1 2), 所以先将(1 2) 传递给pred?, 如果pred? 返回#t, 那么接
着用(1 2) 去匹配后面的`(,a1 ,a2). 也就是说pred? 只会检查(? pred? &#x2026;) 匹配
的那一部分.
</p>
</li>
<li>(quasiquote qp): unqote或unquote-splicing的部分会绑定为变量,其它部分会原样匹配
<div class="org-src-container">

<pre class="src src-scheme">(match '(1 + 2)
[`(,a + ,b) (+ a b)])
</pre>
</div>
<p>
a b都是unquote指定的部分,所以绑定为变量, 其它部分比如 + 就原样匹配, 可以和
(? expr pat &#x2026;)结合使用:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(match '(+ a <span style="color: #E6DB74;">"hello"</span>)
       [`(+ a ,(? number? x)) x]
       [`(+ a ,(? string? x)) x])
</pre>
</div>

<p>
关于quasiquote的一些说明:
</p>
<ul class="org-ul">
<li>quasiquote(`): 和quote(')类似, 只是表达式中的unquote会求值在返回,如果没
有unquote,那么它的行为就和 <code>quote</code> 一样,来看几个例子:
<code>(cons a b)</code> 等价于 <code>`(,a ,b)</code>
</li>
<li>unquote(,): 指定的部分会先求职,在插入list中
<div class="org-src-container">

<pre class="src src-scheme">(quasiquote (1 2 (unquote (+ 1 2)) (unquote (- 5 1))))
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">equivalent</span>
`(1 2 ,(+ 1 2) ,(+ 5 1))                <span style="color: #75715E;">;</span><span style="color: #75715E;">'(1 2 3 6)</span>
</pre>
</div>
</li>

<li>unquote-splicing(,@): 和unquote的行为类似, 只是它所指定的表达式求值后必
须返回list,这个list中的元素会拆开然后插入原list中
<div class="org-src-container">

<pre class="src src-scheme">`(1 2 ,@(list (+ 1 2) (2 2)) 5)         <span style="color: #75715E;">;</span><span style="color: #75715E;">'(1 2 3 4 5)</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">module</h3>
<div class="outline-text-3" id="text-2-3">
<p>
module的基本语法是:
</p>
<pre class="example">
(module name-id initial-module-path
  decl ...)
</pre>
<p>
例子:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(module cake racket
        (provide print-cake)

        (<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">print-cake</span> n)
          (show <span style="color: #E6DB74;">"   ~a   "</span> n #\.)
          (show <span style="color: #E6DB74;">" .-~a-. "</span> n #\|)
          (show <span style="color: #E6DB74;">" | ~a | "</span> n #\space)
          (show <span style="color: #E6DB74;">"---~a---"</span> n #\-))

        (<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">show</span> fmt n ch)
          (printf fmt (make-string n ch))
          (newline)))
</pre>
</div>
<ul class="org-ul">
<li>name-id: module的名字,上例是 <code>cake</code>
</li>
<li>initial-module-path: 初始化要导入的module, 上例是 <code>racket</code>
</li>
<li>provide : 可选的,也就是规定哪些东西是可以导出的,上例中 <code>print-cake</code> 会导
出,但是 <code>show</code> 是模块私有, 如果不提供 <code>provide</code> 那么所有的属性都是私有的,
所以一个模块必须指定 <code>provide</code> 才对导入者有意义
</li>
</ul>
<p>
声明一个模块并不会直接对模块的 <code>body</code> 部分求值,只有当使用 <code>require</code> 明确导
入该模块时才会求值
</p>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">submodule</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
一个文件只能包含一个顶层模块,这个模块可以通过 <code>module</code> 指定,也可以通
过 <code>lang lang-name</code> 来间接的指定, 那么在这个顶层模块中又可以定义子模块,比
如如下代码:
</p>
<div class="org-src-container">

<pre class="src src-scheme">#lang racket
(module zoo racket
        (provide tiger)
        (<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">tiger</span> <span style="color: #E6DB74;">"Tony"</span>))

(require 'zoo)

tiger
</pre>
</div>
<p>
上面的代码(假设文件名是park.rtk) <code>#lang racket</code> 指定了顶层模块, 而 <code>zoo</code> 是
一个子模块, 在顶层模块中可以直接通过 <code>(require 'zoo)</code> 来包含子模块, 如果是
在该文件以外, 你需要导入该文件的模块, 使用 <code>(require "park.rtk")</code> 只会导入
顶层模块, 使用submode语法比如 <code>(require (submod "park.rtk" zoo))</code> 就可以导
入子模块了
</p>
</div>
<div id="outline-container-sec-2-3-1-1" class="outline-5">
<h5 id="sec-2-3-1-1">module*                                                                   :module*:</h5>
<div class="outline-text-5" id="text-2-3-1-1">
<pre class="example">
(module* name-id initial-module-path-or-#f
decl ...)
</pre>
<p>
使用 <code>module</code> 声明的子模块可以可以被父模块导入, 但是子模块不能导入父模块,
而恰恰相反,使用 <code>module*</code> 声明的模块可以导入父模块, 可是父模块不能导入该子
模块, 如果指定 <code>#f</code> 作为默认导入模块, 那么父模块中的所有绑定在子模块中都可
见.
</p>
<div class="org-src-container">

<pre class="src src-scheme">#lang racket

(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">print-cake</span> n)
  (show <span style="color: #E6DB74;">"   ~a   "</span> n #\.)
  (show <span style="color: #E6DB74;">" .-~a-. "</span> n #\|)
  (show <span style="color: #E6DB74;">" | ~a | "</span> n #\space)
  (show <span style="color: #E6DB74;">"---~a---"</span> n #\-))

(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">show</span> fmt n ch)
  (printf fmt (make-string n ch))
  (newline))

(module* main #f
         (print-cake 10))
</pre>
</div>
<p>
在上面的 <code>main</code> 这个submodule中, 顶层模块的所有绑定都可见, 注意当一个
submodule的名字为main时,有一个特殊的地方,也就是说当前的文件作为执行文件时
(racket file-name.rtk),即便你没有使用 <code>(require 'main)</code> 语句, 这个子模块仍
然会运行,和python的=ifmain= 很类似,所以这个main模块可以写一些本模块的测试
代码
</p>
</div>
</div>

<div id="outline-container-sec-2-3-1-2" class="outline-5">
<h5 id="sec-2-3-1-2">module+                                                                   :module+:</h5>
<div class="outline-text-5" id="text-2-3-1-2">
<pre class="example">
(module+ name-id
decl ...)
</pre>
<p>
等价于
</p>
<pre class="example">
(module* name-id #f
  decl ...)
</pre>
<p>
module+一般用来写 <code>test</code> 模块, 多个test模块会合并为一个test模块, 使用raco
test filename.rkt来运行测试代码
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">lang</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
racket的源文件一般需要使用 <code>#lang lang-name</code> 这样的方式来指定语言,这个实际是一
个module的简写方式,比如 <code>#lang racket</code> 等价于:
</p>
<pre class="example">
(module name racket
  decl ...)
</pre>
<p>
所以 <code>#lang racket</code> 的意思就是定义一个module, 该模块的名字一般继承自文件名,
然后将racket作为初始模块导入.
</p>
</div>
</div>

<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">require</h4>
<div class="outline-text-4" id="text-2-3-3">
<ol class="org-ol">
<li>如果是文件那么应该使用这样的语法:
<div class="org-src-container">

<pre class="src src-scheme">(require <span style="color: #E6DB74;">"aa.rkt"</span>)
(require <span style="color: #E6DB74;">"../aa.rkt"</span>)
(require <span style="color: #E6DB74;">"../subdirectory/aa.rkt"</span>)
</pre>
</div>
<p>
以当前文件的路径为当前路径,使用和shell类似的路径表达方式来确定需要导入的模
块的名字,记住要带扩展名
</p>
</li>
<li>当前文件的子模块: <code>(require 'name)</code>
</li>
<li>标准模块: <code>(require racket)</code>
</li>
<li>子模块: <code>(require (submod "aa.rkt" submod-name))</code>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-3-4" class="outline-4">
<h4 id="sec-2-3-4">provide</h4>
<div class="outline-text-4" id="text-2-3-4">
<ul class="org-ul">
<li>导出所有: <code>(provide (all-defined-out))</code>
</li>
<li>只导出通过require引入的绑定: <code>(provide (all-from-out))</code>
</li>
<li>导出除指定的外所有的绑定: <code>(provide (except-out name ...))</code>
</li>
<li>重命名: <code>(provide (rename-out [orgn-id export-id]))</code>
</li>
</ul>

<p>
some example:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(provide run run-all)
(provide (all-defined-out))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">typed racket</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">sample program</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-scheme">#lang typed/racket
(struct: pt ([x : Real] [y : Real]))

(: distance (pt pt -&gt; Real))
(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">distance</span> p1 p2)
  (sqrt (+ (sqr (- (pt-x p2) (pt-x p1)))
           (sqr (- (pt-y p2) (pt-y p1))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Types</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">Basic Types</h4>
<div class="outline-text-4" id="text-3-2-1">
<ol class="org-ol">
<li>Number
</li>
<li>Char
</li>
<li>String
</li>
<li>Boolean
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">Function Type</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
(Number -&gt; Number)
(String String -&gt; Number)
</p>
</div>
</div>

<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3">Union Type</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
当一个类型有几种变种时, 应该使用Union Type
</p>
<div class="org-src-container">

<pre class="src src-scheme">#lang typed/racket
(define-type Tree (U leaf node))
(struct: leaf ([val : Number]))
(struct: node ([left : Tree] [right : Tree]))

(: tree-height (Tree -&gt; Integer))
(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">tree-height</span> t)
  (<span style="color: #F92672; font-weight: bold;">cond</span> [(leaf? t) 1]
        [else (max (+ 1 (tree-height (node-left t)))
                   (+ 1 (tree-height (node-right t))))]))
</pre>
</div>
<p>
上面的Tree就包含两种类型, Node与Leaf
</p>
</div>
</div>

<div id="outline-container-sec-3-2-4" class="outline-4">
<h4 id="sec-3-2-4">Recursive Type</h4>
<div class="outline-text-4" id="text-3-2-4">
<div class="org-src-container">

<pre class="src src-scheme">(define-type BinaryTree (Rec BT (U Number (Pair BT BT))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-5" class="outline-4">
<h4 id="sec-3-2-5">Subtyping</h4>
<div class="outline-text-4" id="text-3-2-5">
<p>
任何类型都是Any的子类型.
</p>
</div>
</div>

<div id="outline-container-sec-3-2-6" class="outline-4">
<h4 id="sec-3-2-6">Polymorphism</h4>
<div class="outline-text-4" id="text-3-2-6">
<div class="org-src-container">

<pre class="src src-scheme">(: list-length (All (A) ((Listof A) -&gt; Integer)))
(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">list-length</span> l)
  (<span style="color: #F92672; font-weight: bold;">if</span> (null? l)
      0
      (add1 (list-length (cdr l)))))
</pre>
</div>
<p>
注意上面的 <code>All</code>.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_comment">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
        var url = window.location.pathname;
        var disqus_identifier = url.substring(url.lastIndexOf('/')+1);
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'yuyang'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
<!-- begin footer -->
<div id="footer">
  <ul class="links vertical-nav">
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a class="back-to-top" href="#">Back to Top</a></li>
  </ul>
  <span>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</span>
  <a href="#" class="back-to-top" id="fixed-back-to-top" ></a>
</div>
<!-- end footer -->
</div>
</body>
</html>
