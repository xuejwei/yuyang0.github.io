<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-02-20 Sat 22:42 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>scheme笔记</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Yu Yang" />
<meta  name="keywords" content="scheme lisp" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/>
<link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="site-title"><a href="/"> 编码者言 </a></h1>
        <div>
          <a href="###" id="site-nav-btn">菜单</a>
          <ul id="site-nav" class="vertical-nav mobi-hid">
            <li> <a href="/">Home</a></li>
            <li> <a href="/about.html">About</a></li>

            <li> <a href="/tags.html">Tags</a></li>

            <li> <a href="/atom.xml">RSS</a></li>
          </ul>

          <form id="site-search" method="get" action="https://google.com/search">
            <input type="hidden" name="q" value="site:yuyang0.github.io" />
            <input type="text" name="q" placeholder="Search..." />
            <button class="btn-search" type="submit">Search</button>
          </form>
          <div style="clear:both;"> </div>
        </div>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">scheme笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline45">scheme笔记</a>
<ul>
<li><a href="#orgheadline6">几个概念&#xa0;&#xa0;&#xa0;<span class="tag"><span class="concept">concept</span></span></a>
<ul>
<li><a href="#orgheadline1">identifier</a></li>
<li><a href="#orgheadline2">variable</a></li>
<li><a href="#orgheadline3">atom</a></li>
<li><a href="#orgheadline4">list</a></li>
<li><a href="#orgheadline5">S-expression</a></li>
</ul>
</li>
<li><a href="#orgheadline7">Naming Conventions</a></li>
<li><a href="#orgheadline8">core syntactic forms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="core">core</span>&#xa0;<span class="syntactic">syntactic</span>&#xa0;<span class="form">form</span></span></a></li>
<li><a href="#orgheadline9">let&#xa0;&#xa0;&#xa0;<span class="tag"><span class="let">let</span></span></a></li>
<li><a href="#orgheadline19">control flow</a>
<ul>
<li><a href="#orgheadline10">if&#xa0;&#xa0;&#xa0;<span class="tag"><span class="if">if</span></span></a></li>
<li><a href="#orgheadline11">cond&#xa0;&#xa0;&#xa0;<span class="tag"><span class="cond">cond</span></span></a></li>
<li><a href="#orgheadline12">when unless&#xa0;&#xa0;&#xa0;<span class="tag"><span class="when">when</span>&#xa0;<span class="unless">unless</span></span></a></li>
<li><a href="#orgheadline13">case&#xa0;&#xa0;&#xa0;<span class="tag"><span class="case">case</span></span></a></li>
<li><a href="#orgheadline14">do&#xa0;&#xa0;&#xa0;<span class="tag"><span class="do">do</span></span></a></li>
<li><a href="#orgheadline15">map</a></li>
<li><a href="#orgheadline16">for-each</a></li>
<li><a href="#orgheadline17">apply</a></li>
<li><a href="#orgheadline18">multiple values</a></li>
</ul>
</li>
<li><a href="#orgheadline28">内置的函数</a>
<ul>
<li><a href="#orgheadline20">predication</a></li>
<li><a href="#orgheadline21">list procedure</a></li>
<li><a href="#orgheadline22">number procedure</a></li>
<li><a href="#orgheadline23">char</a></li>
<li><a href="#orgheadline24">string</a></li>
<li><a href="#orgheadline25">vector procedure</a></li>
<li><a href="#orgheadline26">symbol procedure</a></li>
<li><a href="#orgheadline27">Hash Table</a></li>
</ul>
</li>
<li><a href="#orgheadline29">macros</a>
<ul>
<li><a href="#orgheadline30">define-syntax</a></li>
<li><a href="#orgheadline31">let-syntax与letrec-syntax</a></li>
<li><a href="#orgheadline32">syntax-rules</a></li>
<li><a href="#orgheadline33">syntax object</a></li>
<li><a href="#orgheadline34">syntax-case</a></li>
<li><a href="#orgheadline35">with-syntax</a></li>
</ul>
</li>
<li><a href="#orgheadline40">input and output</a>
<ul>
<li><a href="#orgheadline36">port</a>
<ul>
<li><a href="#orgheadline37">default port</a></li>
</ul>
</li>
<li><a href="#orgheadline38">输入输出</a></li>
<li><a href="#orgheadline39">code example</a></li>
</ul>
</li>
<li><a href="#orgheadline41">递归思想</a></li>
<li><a href="#orgheadline42">continuation</a></li>
<li><a href="#orgheadline43">停机问题</a></li>
<li><a href="#orgheadline44">some example code(the little schemer)</a></li>
</ul>
</li>
<li><a href="#orgheadline57">racket</a>
<ul>
<li><a href="#orgheadline46">struct(新的数据类型)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="struct">struct</span></span></a>
<ul>
<li><a href="#orgheadline47">复制更新</a></li>
<li><a href="#orgheadline48">subtypes(类似于继承)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="subtypes">subtypes</span></span></a></li>
</ul>
</li>
<li><a href="#orgheadline49">match(模式匹配)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="match">match</span></span></a></li>
<li><a href="#orgheadline50">module</a>
<ul>
<li><a href="#orgheadline51">submodule</a>
<ul>
<li><a href="#orgheadline52">module*                                                                   :module*:</a></li>
<li><a href="#orgheadline53">module+                                                                   :module+:</a></li>
</ul>
</li>
<li><a href="#orgheadline54">lang</a></li>
<li><a href="#orgheadline55">require</a></li>
<li><a href="#orgheadline56">provide</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline66">typed racket</a>
<ul>
<li><a href="#orgheadline58">sample program</a></li>
<li><a href="#orgheadline65">Types</a>
<ul>
<li><a href="#orgheadline59">Basic Types</a></li>
<li><a href="#orgheadline60">Function Type</a></li>
<li><a href="#orgheadline61">Union Type</a></li>
<li><a href="#orgheadline62">Recursive Type</a></li>
<li><a href="#orgheadline63">Subtyping</a></li>
<li><a href="#orgheadline64">Polymorphism</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline45" class="outline-2">
<h2 id="orgheadline45">scheme笔记</h2>
<div class="outline-text-2" id="text-orgheadline45">
</div><div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">几个概念&#xa0;&#xa0;&#xa0;<span class="tag"><span class="concept">concept</span></span></h3>
<div class="outline-text-3" id="text-orgheadline6">
</div><div id="outline-container-orgheadline1" class="outline-4">
<h4 id="orgheadline1">identifier</h4>
<div class="outline-text-4" id="text-orgheadline1">
<p>
标识符,可以看作是一个唯一的名字,可以用来引用变量,函数等等
</p>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-4">
<h4 id="orgheadline2">variable</h4>
<div class="outline-text-4" id="text-orgheadline2">
<p>
变量
</p>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3">atom</h4>
<div class="outline-text-4" id="text-orgheadline3">
<ul class="org-ul">
<li>a string of characters</li>
<li>a string of digits</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">atom?</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>s<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">and</span> <span style="color: #93E0E3;">(</span>not <span style="color: #9FC59F;">(</span>pair? s<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span>
         <span style="color: #93E0E3;">(</span>not <span style="color: #9FC59F;">(</span>null? s<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4">list</h4>
<div class="outline-text-4" id="text-orgheadline4">
<p>
a collection of atoms enclosed by parentheses. example:
</p>

<pre class="example">
'()
'(a)
'(a b c)
'((a b) c d)
</pre>
<p>
语法描述:
</p>
<pre class="example">
list -&gt; '()
      | (sexp . list)
</pre>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5">S-expression</h4>
<div class="outline-text-4" id="text-orgheadline5">
<ul class="org-ul">
<li>all lists</li>
<li>all atoms</li>
</ul>
<pre class="example">
sexp -&gt; list
      | atom
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">Naming Conventions</h3>
<div class="outline-text-3" id="text-orgheadline7">
<ol class="org-ol">
<li>谓词后加? , 但是常用的数字比较=, &lt;, &gt;, &lt;=, &gt;=后面不需要?</li>
<li>类型测试, pair? , atom?</li>
<li>字符操作(char-xxx), 字符串操作(string-xxx), 向量操作(vector-xxx)</li>
<li>类型转换(type1-&gt;type2)</li>
<li>但函数有副作用时,应该以 ! 结尾, 比如 <code>set!</code></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">core syntactic forms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="core">core</span>&#xa0;<span class="syntactic">syntactic</span>&#xa0;<span class="form">form</span></span></h3>
<div class="outline-text-3" id="text-orgheadline8">
<ol class="org-ol">
<li><p>
top-level <code>define</code> forms
实际就是创建新的绑定,可以绑定 <code>list</code>, <code>lambda procedure</code> 这是几个示例代
码:
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">double-any</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>f x<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>f x x<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;">;;; </span><span style="color: #7F9F7F;">identical</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #BFEBBF;">(</span><span style="color: #93E0E3;">double-any</span> f x<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>f x x<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">xyz</span> '<span style="color: #BFEBBF;">(</span>x y z<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li><p>
constants
BNF:
</p>
<pre class="example">
&lt;constant&gt; -&gt; &lt;boolean&gt;
            | &lt;number&gt;
            | &lt;character&gt;
            | &lt;string&gt;
</pre></li>

<li>variables</li>
<li>procedure applications <code>(procedure arg1 ... argn)</code>
      求值规则:
<ol class="org-ol">
<li>Find the value of <code>procedure</code>.</li>
<li>Find the value of <code>arg1</code>.</li>
<li>Find the value of <code>argn</code>.</li>
<li>Apply the value of <code>procedure</code> to the values of <code>arg1</code> &#x2026; <code>argn</code>.</li>
</ol></li>
<li><code>quote</code> expressions (')
<ol class="org-ol">
<li>quoting an <code>identifier</code> tells Scheme to treat the identifier as a
<code>symbol</code> rather than as a <code>variable</code>. 也就是说scheme解释器不会去当前的
环境中寻找与该标识符绑定的值, 而是直接将该标识符当作symbol也就是数据处理.</li>
<li>quoting a list tells scheme to treat the list as data, rather than
as a procedure application</li>
</ol></li>
<li><p>
<code>lambda</code> expressions
<code>(lambda (x) (+ x x)) ==&gt; #&lt;procedure&gt;</code>
</p>

<p>
一般形式有这三种:
</p>
<ul class="org-ul">
<li><code>(lambda (var1 var2 ...) exp1 exp2 ...)</code>: var1 var2 &#x2026;会依次赋值</li>
<li><code>(lambda (var1 var2 . var) exp1 exp2)</code>: var1 var2会依次赋值, 余下的参数
会组成一个列表赋给var</li>
<li><code>(lambda var exp1 exp2)</code>: 将所有的实参作为一个list赋给var, 注意var没有括号</li>
</ul></li>
<li><code>if</code> expressions: <code>(if test-expr then-expr else-expr)</code> 只有 <code>test-expr</code>
为 <code>#f</code> 时才会运行 <code>else-expr</code>, 所以你一般要使用 <code>null?</code> <code>eq?</code> 这样的函数
来测试</li>
<li><code>set!</code> expressions(Assignment):  Assignments do not create new bindings,
as with <code>let</code> or <code>lambda</code>, but rather change the values of existing
bindings.也就是说赋值不会像let, lambda那样产生新的绑定,而是会改变已存在绑
定的值,如果你给set!指定的符号不存在,它会报错(set!: cannot set undefined
variable)</li>
</ol>
<p>
其它的都是一些扩展,也就是可以通过define-syntax定义出来的,比如let,and,or,not等
等,只有以上的部分才需要解释器直接实现的
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define-syntax</span> <span style="color: #DFAF8F;">let</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax-rules</span> <span style="color: #D0BF8F;">()</span>
    <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>_ <span style="color: #9FC59F;">(</span><span style="color: #94BFF3;">(</span>x v<span style="color: #94BFF3;">)</span> ...<span style="color: #9FC59F;">)</span> e1 e2 ...<span style="color: #93E0E3;">)</span>
     <span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #94BFF3;">(</span>x ...<span style="color: #94BFF3;">)</span> e1 e2 ...<span style="color: #9FC59F;">)</span> v ...<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define-syntax</span> <span style="color: #DFAF8F;">and</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax-rules</span> <span style="color: #D0BF8F;">()</span>
    <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>_<span style="color: #93E0E3;">)</span> #t<span style="color: #D0BF8F;">]</span>
    <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>_ e<span style="color: #93E0E3;">)</span> e<span style="color: #D0BF8F;">]</span>
    <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>_ e1 e2 e3 ...<span style="color: #93E0E3;">)</span>
     <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> e1 <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">and</span> e2 e3 ...<span style="color: #9FC59F;">)</span> #f<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
   实际上define-syntax实际就是进行模式匹配,像cond,如果匹配那么就进行替换,比
如(and 1)就匹配((_ e) e)所以就被替换为1, _就是and的占位符, 而 <code>pat ...</code> 代表
0个或者多个表达式, 比如 <code>(x v) ...</code> 代表有0个或多个 <code>(x v)</code> 这样的表达式
</p>
</div>
</div>
<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">let&#xa0;&#xa0;&#xa0;<span class="tag"><span class="let">let</span></span></h3>
<div class="outline-text-3" id="text-orgheadline9">
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #5F7F5F;">;;; </span><span style="color: #7F9F7F;">form 1</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">(</span>a exp1<span style="color: #D0BF8F;">)</span>
      <span style="color: #D0BF8F;">(</span>b exp2<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>body1<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>body2<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;">;;; </span><span style="color: #7F9F7F;">form2</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #93E0E3;">f</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span>a exp1<span style="color: #D0BF8F;">]</span>
        <span style="color: #D0BF8F;">[</span>b exp2<span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>body1<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>body2<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
由于 <code>scheme</code> 对待中括号与对待小括号是一样的,所以为了可读性, <code>let</code> 一般可以用如下代
码:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span>a exp1<span style="color: #D0BF8F;">]</span>
      <span style="color: #D0BF8F;">[</span>b exp2<span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>body1<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>body2<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
form2主要是为了递归, 它使得在函数体中可以引用函数名, 比如下面的代码
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #93E0E3;">fac</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span>n <span style="color: #BFEBBF;">10</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #D0BF8F;">(</span>zero? n<span style="color: #D0BF8F;">)</span>
      <span style="color: #BFEBBF;">1</span>
      <span style="color: #D0BF8F;">(</span>* n <span style="color: #93E0E3;">(</span>fac <span style="color: #9FC59F;">(</span>sub1 n<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<ul class="org-ul">
<li>let: 如上所见,实际就是一个扩展语法,a,b只在body中可见, 所以你在exp2中不能使
用a</li>
<li><p>
let*: exp2中可以引用a, 也就是a可以用来定义b, 可以用嵌套的 <code>let</code> 来定义
<code>let*</code>
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define-syntax</span> <span style="color: #DFAF8F;">let*</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax-rules</span> <span style="color: #D0BF8F;">()</span>
    <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>_ <span style="color: #9FC59F;">()</span> e1 e2 ...<span style="color: #93E0E3;">)</span>
     <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #9FC59F;">()</span> e1 e2 ...<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span>
    <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>_ <span style="color: #9FC59F;">(</span><span style="color: #94BFF3;">(</span>x1 v1<span style="color: #94BFF3;">)</span> <span style="color: #94BFF3;">(</span>x2 v2<span style="color: #94BFF3;">)</span> ...<span style="color: #9FC59F;">)</span> e1 e2 ...<span style="color: #93E0E3;">)</span>
     <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #9FC59F;">(</span><span style="color: #94BFF3;">(</span>x1 v1<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span>
       <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">let*</span> <span style="color: #94BFF3;">(</span><span style="color: #E0CF9F;">(</span>x2 v2<span style="color: #E0CF9F;">)</span> ...<span style="color: #94BFF3;">)</span> e1 e2 ...<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li><p>
letrec: 主要用来解决定义递归函数时,函数名在函数体中不可见的问题,比如
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span>sum <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #9FC59F;">(</span>lst<span style="color: #9FC59F;">)</span>
                <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #94BFF3;">(</span>null? lst<span style="color: #94BFF3;">)</span> <span style="color: #BFEBBF;">0</span>
                    <span style="color: #94BFF3;">(</span>+ <span style="color: #E0CF9F;">(</span>car lst<span style="color: #E0CF9F;">)</span> <span style="color: #E0CF9F;">(</span>sum <span style="color: #8FB28F;">(</span>cdr lst<span style="color: #8FB28F;">)</span><span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>sum '<span style="color: #D0BF8F;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span> <span style="color: #BFEBBF;">3</span> <span style="color: #BFEBBF;">4</span> <span style="color: #BFEBBF;">5</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
如果运行上面的代码,那么你会 <code>sum undefined</code> 的错误, 原因是 <code>sum</code> 在后面的函数
体中不可见, 所以你使用 <code>(sum (cdr lst))</code> 就会出错,当然你可以使用这种方法
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span>sum <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #9FC59F;">(</span>sum lst<span style="color: #9FC59F;">)</span>
                <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #94BFF3;">(</span>null? lst<span style="color: #94BFF3;">)</span> <span style="color: #BFEBBF;">0</span>
                    <span style="color: #94BFF3;">(</span>+ <span style="color: #E0CF9F;">(</span>car lst<span style="color: #E0CF9F;">)</span> <span style="color: #E0CF9F;">(</span>sum sum <span style="color: #8FB28F;">(</span>cdr lst<span style="color: #8FB28F;">)</span><span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>sum sum '<span style="color: #D0BF8F;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span> <span style="color: #BFEBBF;">3</span> <span style="color: #BFEBBF;">4</span> <span style="color: #BFEBBF;">5</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
但这种方法不够自然,而且比较丑陋,不符合scheme中定义递归函数的一般模式,所以
就引入了 <code>letrec</code>.
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">letrec</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span>sum <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #9FC59F;">(</span>ls<span style="color: #9FC59F;">)</span>
                <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #94BFF3;">(</span>null? ls<span style="color: #94BFF3;">)</span>
                    <span style="color: #BFEBBF;">0</span>
                    <span style="color: #94BFF3;">(</span>+ <span style="color: #E0CF9F;">(</span>car ls<span style="color: #E0CF9F;">)</span> <span style="color: #E0CF9F;">(</span>sum <span style="color: #8FB28F;">(</span>cdr ls<span style="color: #8FB28F;">)</span><span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>sum '<span style="color: #D0BF8F;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span> <span style="color: #BFEBBF;">3</span> <span style="color: #BFEBBF;">4</span> <span style="color: #BFEBBF;">5</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">the result is 15</span>
</pre>
</div></li>
<li>letrec*: 和 <code>letrec</code> 类似, 只是后面的绑定可以引用前面已经绑定的变量</li>
<li><p>
let-values: 绑定多个变量
syntax:
</p>
<ul class="org-ul">
<li>(let-values ((formals expr) &#x2026;) body1 body2 &#x2026;)</li>
<li>(let*-values ((formals expr) &#x2026;) body1 body2 &#x2026;)</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let-values</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>a b<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>values <span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span> <span style="color: #D0BF8F;">[</span>c <span style="color: #93E0E3;">(</span>values <span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span> <span style="color: #BFEBBF;">3</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>list a b c<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span> <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">the result is (1 2 (1 2 3))</span>

<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let*-values</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>a b<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>values <span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span> <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>a b<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>values b a<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>list a b<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span> <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">the result is (2 1)</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19">control flow</h3>
<div class="outline-text-3" id="text-orgheadline19">
</div><div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10">if&#xa0;&#xa0;&#xa0;<span class="tag"><span class="if">if</span></span></h4>
<div class="outline-text-4" id="text-orgheadline10">
<p>
当要写多个表达式时应该加入 <code>begin</code> , 注意 <code>begin</code> 会依次执行它所包含的表达式,并
返回最后一个表达式的值
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #BFEBBF;">(</span>test-exp<span style="color: #BFEBBF;">)</span>
    <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">begin</span>
      expression1
      expression2<span style="color: #BFEBBF;">)</span>
    expression3<span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
如果 <code>test-exp</code> 为true, 依次执行 <code>expression1</code>, <code>expression2</code> 那么返回
<code>expression2</code> 的值, 之所以需要 <code>begin</code> 是由 <code>if</code> 的语法决定的, <code>if</code> 的语
法如下:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #BFEBBF;">(</span>test-exp<span style="color: #BFEBBF;">)</span>
    <span style="color: #BFEBBF;">(</span>true-exp<span style="color: #BFEBBF;">)</span>
    <span style="color: #BFEBBF;">(</span>false-exp<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
    所以如果你在 <code>true-exp</code> 的位置放入多条表达式,那么这些表达式的第二条会
被当作 <code>false-exp</code> ,而且因为 <code>if</code> 后的表达式的条数超出 <code>2</code> 条而报错, 所以
你需要把多条表达式括起来,但是你不能直接加一个括号,比如
</p>

<pre class="example">
((true-exp1)(true-exp2))
</pre>
<p>
   这样之所以不行是因为scheme会将 (true-exp1) 当作procedure求值,这显然不
对, 所以scheme使用begin(更准确的说begin是为了引入side effect), 也就变成
了:
</p>
<pre class="example">
(begin
  (true-exp1)
  (true-exp2))
</pre>
<p>
这就是if使用begin的原因了, 注意在 let, lambda, define,cond的body中都不需
要begin,因为它们都没有if这种特殊的状况.
</p>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11">cond&#xa0;&#xa0;&#xa0;<span class="tag"><span class="cond">cond</span></span></h4>
<div class="outline-text-4" id="text-orgheadline11">
<p>
内部相当于有个隐含的begin,所以可以直接写多个表达式
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">cond</span> <span style="color: #BFEBBF;">[</span><span style="color: #D0BF8F;">(</span>test-exp<span style="color: #D0BF8F;">)</span> <span style="color: #D0BF8F;">(</span>exp1<span style="color: #D0BF8F;">)</span> <span style="color: #D0BF8F;">(</span>exp2<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">]</span>
      <span style="color: #BFEBBF;">[</span>else expression3<span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
如果test-exp为true, 那么返回expression2的值
注意一个特殊的形式: =&gt;
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">cond</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">(</span>assv 'b '<span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">(</span>a <span style="color: #BFEBBF;">1</span><span style="color: #9FC59F;">)</span> <span style="color: #9FC59F;">(</span>b <span style="color: #BFEBBF;">2</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span> =&gt; cadr<span style="color: #BFEBBF;">)</span>
      <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">else</span> #f<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>                       <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">==&gt;  2</span>
</pre>
</div>
<p>
会将 test-exp的值传递给 =&gt;后面的函数, =&gt;后面必须是一个带一个参数的函数
</p>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12">when unless&#xa0;&#xa0;&#xa0;<span class="tag"><span class="when">when</span>&#xa0;<span class="unless">unless</span></span></h4>
<div class="outline-text-4" id="text-orgheadline12">
<ul class="org-ul">
<li><p>
(when (test-exp) exp1 exp2) : test-exp为真就执行exp1, exp2
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define-syntax</span> <span style="color: #DFAF8F;">when</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax-rules</span> <span style="color: #D0BF8F;">()</span>
    <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>_ e0 e1 e2 ...<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> e0 <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">begin</span> e1 e2 ...<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li>(unless (test-exp) exp1 exp2) : 只有当 <code>test-exp</code> 为#f时才会运行body中的
表达式</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-4">
<h4 id="orgheadline13">case&#xa0;&#xa0;&#xa0;<span class="tag"><span class="case">case</span></span></h4>
<div class="outline-text-4" id="text-orgheadline13">
<p>
类似于C语言的switch
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">(</span>x <span style="color: #BFEBBF;">4</span><span style="color: #D0BF8F;">)</span> <span style="color: #D0BF8F;">(</span>y <span style="color: #BFEBBF;">5</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">case</span> <span style="color: #D0BF8F;">(</span>+ x y<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">3</span> <span style="color: #BFEBBF;">5</span> <span style="color: #BFEBBF;">7</span> <span style="color: #BFEBBF;">9</span><span style="color: #93E0E3;">)</span> 'odd<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">(</span><span style="color: #BFEBBF;">0</span> <span style="color: #BFEBBF;">2</span> <span style="color: #BFEBBF;">4</span> <span style="color: #BFEBBF;">6</span> <span style="color: #BFEBBF;">8</span><span style="color: #93E0E3;">)</span> 'even<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">else</span> 'out-of-range<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span> <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">===&gt; odd</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline14" class="outline-4">
<h4 id="orgheadline14">do&#xa0;&#xa0;&#xa0;<span class="tag"><span class="do">do</span></span></h4>
<div class="outline-text-4" id="text-orgheadline14">
<p>
<code>syntax: (do ((var init update) ...) (test result ...) expr ...)</code>
</p>

<p>
循环(do ((var init update) &#x2026;) (test res &#x2026;) exp &#x2026;)  var的初始值是init,接
着每一次迭代都绑定到update, (test res..)如果为true,那么就终止循环
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">divisors</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>n<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">do</span> <span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">(</span>i <span style="color: #BFEBBF;">2</span> <span style="color: #94BFF3;">(</span>+ i <span style="color: #BFEBBF;">1</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span>
         <span style="color: #9FC59F;">(</span>ls '<span style="color: #94BFF3;">()</span>
             <span style="color: #94BFF3;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #E0CF9F;">(</span>integer? <span style="color: #8FB28F;">(</span>/ n i<span style="color: #8FB28F;">)</span><span style="color: #E0CF9F;">)</span>
                 <span style="color: #E0CF9F;">(</span>cons i ls<span style="color: #E0CF9F;">)</span>
                 ls<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span>
        <span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">(</span>&gt;= i n<span style="color: #9FC59F;">)</span> ls<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline15" class="outline-4">
<h4 id="orgheadline15">map</h4>
<div class="outline-text-4" id="text-orgheadline15">
<p>
(map procedure list1 list2 &#x2026;) 会返回一个 <code>list</code>
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">map</span> <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>x y<span style="color: #D0BF8F;">)</span> <span style="color: #D0BF8F;">(</span>* x y<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span>
     '<span style="color: #BFEBBF;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span> <span style="color: #BFEBBF;">3</span> <span style="color: #BFEBBF;">4</span><span style="color: #BFEBBF;">)</span>
     '<span style="color: #BFEBBF;">(</span><span style="color: #BFEBBF;">8</span> <span style="color: #BFEBBF;">7</span> <span style="color: #BFEBBF;">6</span> <span style="color: #BFEBBF;">5</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>      <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">return (8 14 18 20)</span>
</pre>
</div>
<p>
<code>map</code> 与 <code>for-each</code> 可以代替许多循环的工作, 而且逻辑上比循环更清晰.
</p>
</div>
</div>
<div id="outline-container-orgheadline16" class="outline-4">
<h4 id="orgheadline16">for-each</h4>
<div class="outline-text-4" id="text-orgheadline16">
<p>
和 <code>map</code> 类似但是不返回一个list作为结果, 也就是说 <code>for-each</code> 是用来产生side
effect.
</p>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17">apply</h4>
<div class="outline-text-4" id="text-orgheadline17">
<p>
(apply procedure obj &#x2026; list)
</p>
<ul class="org-ul">
<li><code>(apply + '(4 5)) ===&gt; 9</code></li>
<li><code>(apply min  5 1 3 '(6 8 3 2 5))</code> 结果是1</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-4">
<h4 id="orgheadline18">multiple values</h4>
<div class="outline-text-4" id="text-orgheadline18">
<ul class="org-ul">
<li><p>
(values obj &#x2026;) :返回多个值,注意它的返回值可以用 <code>let-values</code> 来绑定,不能用 <code>define</code>
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let-values</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>a b<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>values <span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>+ a b<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li><p>
(call-with-values producer consumer): producer产生多个值, 然后将这些值传
递给consumer.注意producer必须可以不带参数的方式来调用
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>call-with-values
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">()</span> <span style="color: #D0BF8F;">(</span>values 'bond 'james<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>x y<span style="color: #D0BF8F;">)</span> <span style="color: #D0BF8F;">(</span>cons y x<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>  <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">the result is (james . bond)</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline28" class="outline-3">
<h3 id="orgheadline28">内置的函数</h3>
<div class="outline-text-3" id="text-orgheadline28">
</div><div id="outline-container-orgheadline20" class="outline-4">
<h4 id="orgheadline20">predication</h4>
<div class="outline-text-4" id="text-orgheadline20">
<ol class="org-ol">
<li>= : 只用来比较整数, 不要用来比较浮点数</li>
<li>eq? : 可以类似的看作是指针比较, 即便是内容相同,但是如果是两个不同对象,它
就返回 <code>#f</code>, 比如 <code>(eq? (cons 'a 'b) (cons 'a 'b))</code> 虽然是同样的list, 可
是它在内存中的位置不同,所以为 #f. 有以下几种情况是相等的.
<ul class="org-ul">
<li>#t, #f, 两个identifier的值如果都是#t或者#f,那么它们相等</li>
<li><p>
相同的符号(symbol), 比如
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">sym1</span> 'hello<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">sym2</span> 'hello<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>eq? sym1 sym2<span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li>'()</li>
</ul></li>
<li>eqv? : 和 <code>eq?</code> 很类似, 只是它在一些 <code>eq?</code> 没有定义的地方也可以使用</li>
<li>equal? : 只要内容相同,它就会返回 #t,可以认为它的检查比 <code>eq?</code> 宽松</li>
<li>boolean? : 等价于 <code>(lambda (x) (or (eq? x #t) (eq? x #f)))</code></li>
<li>null? : 只作用于list, only <code>(null? '())</code> return <code>#t</code>.</li>
<li>pair? :</li>
<li>number? :</li>
<li>complex? :</li>
<li>rational? :</li>
<li>real? :</li>
<li>integer? :</li>
<li>char? :</li>
<li>string? :</li>
<li>vector? :</li>
<li>symbol? :</li>
<li>procedure? :</li>
<li>bytevector? :</li>
<li>hashtable? :</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline21" class="outline-4">
<h4 id="orgheadline21">list procedure</h4>
<div class="outline-text-4" id="text-orgheadline21">
<p>
<code>list</code> 的语法定义:
</p>
<pre class="example">
List ::= '()
     ::= (Sexp . List)
</pre>
<ol class="org-ol">
<li>cons: (cons 'a 'b) ==&gt; (a . b),只能带两个参数</li>
<li>cons* : (cons* 'a 'b 'c) ==&gt; (a b . c)    (cons* 'a 'b '(c)) ==&gt; (a b c)</li>
<li>car: the firsts element of pair (<b>only for non-empty list</b> )</li>
<li>cdr: Only for non-empty list, the cdr of any non-empty list is also a list.</li>
<li>set-car! :有副作用, 会原地改变pair的值</li>
<li>set-cdr! :</li>
<li>car, caar, caaar&#x2026;etc: 连续执行n次(a的次数)car
(caar '((5)) ) ===&gt; 5</li>
<li>cdr cddr cdddr &#x2026;etc : 连续执行n次(d的个数)cdr</li>
<li>cadar : (car (cdr (car lst))) 记住按照顺序从左到右,最右边的先对list起作用</li>
<li>list: 创建一个list eg: (list 1 2 3 4) ===&gt; '(1 2 3 4)</li>
<li>length: list的长度</li>
<li>append: 将一个list添加另一个list的后边,eg: (append '(1 2) '(3 4)) ===&gt; '(1 2 3 4)</li>
<li>reverse: 将list倒转</li>
<li>(list-ref list n): 第n个元素</li>
<li>(list-tail list n) : 倒数第n个元素</li>
<li><p>
memq memv member memp 分别用eq? eqv? equal? 指定的procedure 来测试一个元
素是否属于list, 如果属于那么就返回包括该元素以及该元素后面的元素组成的
list, <code>(memq 'a '(b c a d e)) --&gt; (a d e)</code>
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">memq</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>x ls<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">cond</span>
      <span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">(</span>null? ls<span style="color: #9FC59F;">)</span> #f<span style="color: #93E0E3;">)</span>
      <span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">(</span>eq? <span style="color: #94BFF3;">(</span>car ls<span style="color: #94BFF3;">)</span> x<span style="color: #9FC59F;">)</span> ls<span style="color: #93E0E3;">)</span>
      <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #9FC59F;">(</span>memq x <span style="color: #94BFF3;">(</span>cdr ls<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li>remq (obj list) remv remove remp 删除list中的所有obj</li>
<li><p>
assq assv assoc assp 可以看做是关联数组((key1 . val1) (key2 . val2) &#x2026;)
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">assq</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>x ls<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">cond</span>
      <span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">(</span>null? ls<span style="color: #9FC59F;">)</span> #f<span style="color: #93E0E3;">)</span>
      <span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">(</span>eq? <span style="color: #94BFF3;">(</span>caar ls<span style="color: #94BFF3;">)</span> x<span style="color: #9FC59F;">)</span> <span style="color: #9FC59F;">(</span>car ls<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span>
      <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #9FC59F;">(</span>assq x <span style="color: #94BFF3;">(</span>cdr ls<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
返回第一个匹配的pair
</p></li>
<li>(filter procedure list): return a list of the elements of list for which
procedure returns true</li>
<li>(partition procedure list): 返回两个list,第一个list包含所以使
<code>procedure</code> 为#f的元素,第二个包含所有使 <code>procedure</code> 为 <code>#f</code> 的元素,
<code>partition</code> 的返回值可以使用 <code>let-values</code> 来绑定或者使用
<code>call-with-values</code> 来调用其它函数</li>
<li>(find procedure list) : 返回第一个使procedure为#t的元素</li>
<li>(map f list1 list2 &#x2026;)</li>
<li>(foldl f init list1 list2 &#x2026;): <b>racket 的内置版本有bug</b></li>
<li><p>
(foldr f init list1 list2 &#x2026;):
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">foldl</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>f x ls<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">cond</span>
     <span style="color: #93E0E3;">[</span><span style="color: #9FC59F;">(</span>null? ls<span style="color: #9FC59F;">)</span> x<span style="color: #93E0E3;">]</span>
     <span style="color: #93E0E3;">[</span>else
      <span style="color: #9FC59F;">(</span>foldl f <span style="color: #94BFF3;">(</span>f x <span style="color: #E0CF9F;">(</span>car ls<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span> <span style="color: #94BFF3;">(</span>cdr ls<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">]</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(foldl op init '(1 2 3 4))</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">we can think foldl's behavior like this: (init op 1 op 2 op 3 op 4)</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">op has left associativity</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">foldr</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>f x ls<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">cond</span>
     <span style="color: #93E0E3;">[</span><span style="color: #9FC59F;">(</span>null? ls<span style="color: #9FC59F;">)</span> x<span style="color: #93E0E3;">]</span>
     <span style="color: #93E0E3;">[</span>else
      <span style="color: #9FC59F;">(</span>f <span style="color: #94BFF3;">(</span>car ls<span style="color: #94BFF3;">)</span> <span style="color: #94BFF3;">(</span>foldr f x <span style="color: #E0CF9F;">(</span>cdr ls<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">]</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(foldr op init '(1 2 3 4 5))</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">we can think foldl's behavior like this: (1 op 2 op 3 op 4 op init)</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">op has right associativity</span>
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22">number procedure</h4>
<div class="outline-text-4" id="text-orgheadline22">
<ol class="org-ol">
<li>zero? :</li>
<li>positive? :</li>
<li>negative? :</li>
<li>even? :</li>
<li>odd? : 奇数</li>
<li>数学函数: max, min, floor, ceiling(向+无穷取整), truncate(向0取整),round(最接近的整数),
abs,gcd,expt(指数),三角系列函数(san,cos&#x2026;.)</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline23" class="outline-4">
<h4 id="orgheadline23">char</h4>
<div class="outline-text-4" id="text-orgheadline23">
<p>
字符使用 <code>#\x</code> 来表示,比如 <code>a</code> 就是 <code>#\a</code>,
</p>
<ul class="org-ul">
<li>(char=? char1 char2 char3 &#x2026;)</li>
<li>(char&lt;? char1 char2 char3 &#x2026;)</li>
<li>(char&gt;? char1 char2 char3 &#x2026;)</li>
<li>(char&lt;=? char1 char2 char3 &#x2026;)</li>
<li>(char&gt;=? char1 char2 char3 &#x2026;)</li>
<li>(char-ci=? char1 char2 char3 &#x2026;) 大小写敏感</li>
<li>(char-ci&lt;? char1 char2 char3 &#x2026;)</li>
<li>(char-ci&gt;? char1 char2 char3 &#x2026;)</li>
<li>(char-ci&lt;=? char1 char2 char3 &#x2026;)</li>
<li>(char-ci&gt;=? char1 char2 char3 &#x2026;)</li>

<li>(char-upcase char) :大写,相对应的还有个char-downcase</li>
<li>(char-&gt;integer char)</li>
<li>(integer-&gt;char n)</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline24" class="outline-4">
<h4 id="orgheadline24">string</h4>
<div class="outline-text-4" id="text-orgheadline24">
<p>
双引号内的是字符串
</p>
<ul class="org-ul">
<li>(string=? char1 char2 char3 &#x2026;)</li>
<li>(string&lt;? char1 char2 char3 &#x2026;)</li>
<li>(string&gt;? char1 char2 char3 &#x2026;)</li>
<li>(string&lt;=? char1 char2 char3 &#x2026;)</li>
<li>(string&gt;=? char1 char2 char3 &#x2026;)</li>
<li>(string-ci=? char1 char2 char3 &#x2026;) 大小写敏感</li>
<li>(string-ci&lt;? char1 char2 char3 &#x2026;)</li>
<li>(string-ci&gt;? char1 char2 char3 &#x2026;)</li>
<li>(string-ci&lt;=? char1 char2 char3 &#x2026;)</li>
<li>(string-ci&gt;=? char1 char2 char3 &#x2026;)</li>
<li>(string char &#x2026;): 构建个包含指定的字符的字符串</li>
<li>(make-string n), (make-string n char)</li>
<li>(string-append string &#x2026;)</li>
<li>(substring string start end)</li>
<li>(string-upcase string)</li>
<li>(string-&gt;list): 把string转换成包含char的list</li>
<li>(char-&gt;list lst)</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline25" class="outline-4">
<h4 id="orgheadline25">vector procedure</h4>
<div class="outline-text-4" id="text-orgheadline25">
<p>
list访问时需要遍历,不够高效, vector可以像数组一样O(1)时间内访问
</p>
<ol class="org-ol">
<li>(vector obj &#x2026;)</li>
<li>make-vector: (make-vector 5 'a) ===&gt;  #(a a a a a)</li>
<li>vector-length: vector的长度</li>
<li>(vector-ref vec n)</li>
<li>(vector-set! vec n obj)</li>
<li>(vector-fill vec obj): 所有的元素都替换为obj</li>
<li>list-&gt;vector :</li>
<li>vector-&gt;list :</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline26" class="outline-4">
<h4 id="orgheadline26">symbol procedure</h4>
<div class="outline-text-4" id="text-orgheadline26">
<p>
每一个symbol在解释器内部都是指向同一个对象,所以用eq?来测试相同的symbol会返
回#t, 这也使得比较操作很高效
</p>
<ol class="org-ol">
<li>symbol=? :symbol是否相等,也可以用eq?来比较</li>
<li>symbol-&gt;string:</li>
<li>string-&gt;symbol:</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline27" class="outline-4">
<h4 id="orgheadline27">Hash Table</h4>
<div class="outline-text-4" id="text-orgheadline27">
<ul class="org-ul">
<li>(make-eq-hashtable) : 使用eq?来比较两个key, 返回一个hashtable</li>
<li>(make-eq-hashtable size)</li>
<li>(make-eqv-hashtable) : 使用eqv?来比较两个key</li>
<li>(make-eqv-hashtable size)</li>
<li>(make-hashtable hash equiv?) : hash指定hash函数, equiv?指定比较两个key的
函数</li>
<li>(make-hashtable hash equiv? size)</li>

<li>(hashtable-set! hashtable key obj) :</li>
<li>(hashtable-ref hashtable key default) :</li>
<li>(hashtable-delete! hashtable key) :</li>
<li>(hashtable-size hashtable) : hashtable的大小</li>
<li>(hashtable-contains? hashtable key) :测试是否包含指定的key</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29">macros</h3>
<div class="outline-text-3" id="text-orgheadline29">
<p>
定义一个宏实际上就是把一个keyword与一个 macro transformer 绑定, 一个macro
transformer一般就是一个带有一个参数的函数, 而macro transformer的输入是一个原
始代码的syntax object, 输出则是包含转换后代码的 syntax
object. <code>syntax-rules</code> 返回的就是一个macro transform.所以你可以抛开
<code>syntax-rules</code> 而这样写一个宏:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define-syntax</span> <span style="color: #DFAF8F;">self-as-string</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>stx<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>datum-&gt;syntax stx
                   <span style="color: #93E0E3;">(</span>format <span style="color: #CC9393;">"~s"</span> <span style="color: #9FC59F;">(</span>syntax-&gt;datum stx<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
<div id="outline-container-orgheadline30" class="outline-4">
<h4 id="orgheadline30">define-syntax</h4>
<div class="outline-text-4" id="text-orgheadline30">
<p>
和define类似
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define-syntax</span> <span style="color: #DFAF8F;">let*</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax-rules</span> <span style="color: #D0BF8F;">()</span>
    <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>_ <span style="color: #9FC59F;">()</span> b1 b2 ...<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #9FC59F;">()</span> b1 b2 ...<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span>
    <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>_ <span style="color: #9FC59F;">(</span><span style="color: #94BFF3;">(</span>i1 e1<span style="color: #94BFF3;">)</span> <span style="color: #94BFF3;">(</span>i2 e2<span style="color: #94BFF3;">)</span> ...<span style="color: #9FC59F;">)</span> b1 b2 ...<span style="color: #93E0E3;">)</span>
     <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #9FC59F;">(</span><span style="color: #94BFF3;">[</span>i1 e1<span style="color: #94BFF3;">]</span><span style="color: #9FC59F;">)</span>
       <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">let*</span> <span style="color: #94BFF3;">(</span><span style="color: #E0CF9F;">[</span>i2 e2<span style="color: #E0CF9F;">]</span> ...<span style="color: #94BFF3;">)</span> b1 b2 ...<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline31" class="outline-4">
<h4 id="orgheadline31">let-syntax与letrec-syntax</h4>
<div class="outline-text-4" id="text-orgheadline31">
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span>f <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #9FC59F;">(</span>x<span style="color: #9FC59F;">)</span> <span style="color: #9FC59F;">(</span>+ x <span style="color: #BFEBBF;">1</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">let-syntax</span> <span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">[</span>f <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax-rules</span> <span style="color: #94BFF3;">()</span>
                    <span style="color: #94BFF3;">[</span><span style="color: #E0CF9F;">(</span>_ x<span style="color: #E0CF9F;">)</span> x<span style="color: #94BFF3;">]</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">]</span>
               <span style="color: #93E0E3;">[</span>g <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax-rules</span> <span style="color: #94BFF3;">()</span>
                    <span style="color: #94BFF3;">[</span><span style="color: #E0CF9F;">(</span>_ x<span style="color: #E0CF9F;">)</span> <span style="color: #E0CF9F;">(</span>f x<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">]</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">]</span><span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>list <span style="color: #93E0E3;">(</span>f <span style="color: #BFEBBF;">1</span><span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>g <span style="color: #BFEBBF;">1</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span> <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(1 2)</span>

<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span>f <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #9FC59F;">(</span>x<span style="color: #9FC59F;">)</span> <span style="color: #9FC59F;">(</span>+ x <span style="color: #BFEBBF;">1</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">letrec-syntax</span> <span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">[</span>f <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax-rules</span> <span style="color: #94BFF3;">()</span>
                       <span style="color: #94BFF3;">[</span><span style="color: #E0CF9F;">(</span>_ x<span style="color: #E0CF9F;">)</span> x<span style="color: #94BFF3;">]</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">]</span>
                  <span style="color: #93E0E3;">[</span>g <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax-rules</span> <span style="color: #94BFF3;">()</span>
                       <span style="color: #94BFF3;">[</span><span style="color: #E0CF9F;">(</span>_ x<span style="color: #E0CF9F;">)</span> <span style="color: #E0CF9F;">(</span>f x<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">]</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">]</span><span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>list <span style="color: #93E0E3;">(</span>f <span style="color: #BFEBBF;">1</span><span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>g <span style="color: #BFEBBF;">1</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span> <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(1 1)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline32" class="outline-4">
<h4 id="orgheadline32">syntax-rules</h4>
<div class="outline-text-4" id="text-orgheadline32">
<p>
基本语法: <code>(syntax-rules (literal ...) (pattern template) ...)</code>
</p>

<p>
返回一个transformer, 实际就是一个 <code>procedure</code>, 这个 <code>procedure</code> 接受一个
syntax object,然后返回一个syntax object.
</p>
<ul class="org-ul">
<li>literal: 一些关键字, 出现在pattern会原样匹配</li>
<li>pattern: 用于匹配输入的表达式的模式</li>
<li>template: 输出,记住template是原样输出,这是和syntax-case的最大区别.</li>
<li>下划线'_': 可以匹配任何结构,一般用来代表宏名</li>
<li>&#x2026; : 代表前面的部分重复0次或者多次</li>
</ul>
<p>
一个例子,这个例子实现一个类 <code>if</code> 的条件判断语句,他的形式是 <code>(my-if cond then
    exp1 else exp2)</code> 这看起来更可读性更好:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define-syntax</span> <span style="color: #DFAF8F;">my-if</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax-rules</span> <span style="color: #D0BF8F;">(</span>then else<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>_ condition then true-exp else false-exp<span style="color: #93E0E3;">)</span>
     <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> condition true-exp false-exp<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
<code>then, else</code> 是关键字,所以它会原样的匹配输入
</p>
</div>
</div>
<div id="outline-container-orgheadline33" class="outline-4">
<h4 id="orgheadline33">syntax object</h4>
<div class="outline-text-4" id="text-orgheadline33">
<p>
<code>(syntax template)</code> 的缩写为 <code>#'template</code>, syntax和quote很类似,只是它会将
template中的pattern variable替换掉, 并且会绑定上下文信息
</p>
<ol class="org-ol">
<li>syntax: 创建一个字面的 syntax object,比如 <code>(syntax '(+ 1 x))</code>, 简写
<code>#'(+ 1 x)</code>.</li>
<li>syntax-&gt;datum: 将一个syntax object转换为它原来的内容.</li>
<li>identifier? : 测试一个syntax object 是不是标识符</li>
<li>syntax-e : 只解包一层.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline34" class="outline-4">
<h4 id="orgheadline34">syntax-case</h4>
<div class="outline-text-4" id="text-orgheadline34">
<p>
比 <code>syntax-rules</code> 更具一般性,而且更通用, 使用syntax-case的一般形式是:
</p>
<pre class="example">
(define-syntax macro-name
   (lambda (x)
     (syntax-case x (other keywords go here if any)
       [
         (macro-name macro-arg1 macro-arg2)
         ;;Expansion of macro (one or multiple forms)
         ;;(syntax is a reserved word)
         (syntax (expansion of macro goes here))
       ]  ...
 )))
</pre>
<p>
解释一下上面的代码: 整个lambda定义的就是一个macro transformer, 它的唯一参数
x 实际就是一个包含了原始代码的syntax object. 通过syntax-case 来匹配x,然后返
回一个包含了转换后代码的syntax object
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define-syntax</span> <span style="color: #DFAF8F;">my-if</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>x<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>syntax-case x <span style="color: #93E0E3;">(</span>then else<span style="color: #93E0E3;">)</span>
      <span style="color: #93E0E3;">[</span><span style="color: #9FC59F;">(</span>_ condition then true-exp else false-exp<span style="color: #9FC59F;">)</span>
       <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax</span> <span style="color: #94BFF3;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> condition true-exp false-exp<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">]</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;">;;</span><span style="color: #7F9F7F;">Define a new macro</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define-syntax</span> <span style="color: #DFAF8F;">swap!</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>x<span style="color: #D0BF8F;">)</span>
    <span style="color: #5F7F5F;">;;</span><span style="color: #7F9F7F;">we don't have any keywords this time</span>
    <span style="color: #D0BF8F;">(</span>syntax-case x <span style="color: #93E0E3;">()</span>
      <span style="color: #93E0E3;">[</span><span style="color: #9FC59F;">(</span>swap! a b<span style="color: #9FC59F;">)</span>
       <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">syntax</span>
        <span style="color: #94BFF3;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #E0CF9F;">(</span><span style="color: #8FB28F;">(</span>c a<span style="color: #8FB28F;">)</span><span style="color: #E0CF9F;">)</span>
          <span style="color: #E0CF9F;">(</span>set! a b<span style="color: #E0CF9F;">)</span>
          <span style="color: #E0CF9F;">(</span>set! b c<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">]</span>
      <span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define-syntax</span> <span style="color: #DFAF8F;">syntax-rules</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>x<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>syntax-case x <span style="color: #93E0E3;">()</span>
      <span style="color: #93E0E3;">[</span><span style="color: #9FC59F;">(</span>_ <span style="color: #94BFF3;">(</span>i ...<span style="color: #94BFF3;">)</span> <span style="color: #94BFF3;">(</span><span style="color: #E0CF9F;">(</span>keyword . pattern<span style="color: #E0CF9F;">)</span> template<span style="color: #94BFF3;">)</span> ...<span style="color: #9FC59F;">)</span>
       #'<span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #94BFF3;">(</span>x<span style="color: #94BFF3;">)</span>
           <span style="color: #94BFF3;">(</span>syntax-case x <span style="color: #E0CF9F;">(</span>i ...<span style="color: #E0CF9F;">)</span>
             <span style="color: #E0CF9F;">[</span><span style="color: #8FB28F;">(</span>_ . pattern<span style="color: #8FB28F;">)</span> #'template<span style="color: #E0CF9F;">]</span> ...<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">]</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline35" class="outline-4">
<h4 id="orgheadline35">with-syntax</h4>
<div class="outline-text-4" id="text-orgheadline35">
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define-syntax</span> <span style="color: #DFAF8F;">with-syntax</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>x<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>syntax-case x <span style="color: #93E0E3;">()</span>
      <span style="color: #93E0E3;">[</span><span style="color: #9FC59F;">(</span>_ <span style="color: #94BFF3;">(</span><span style="color: #E0CF9F;">(</span>p e<span style="color: #E0CF9F;">)</span> ...<span style="color: #94BFF3;">)</span> b1 b2 ...<span style="color: #9FC59F;">)</span>
       #'<span style="color: #9FC59F;">(</span>syntax-case <span style="color: #94BFF3;">(</span>list e ...<span style="color: #94BFF3;">)</span> <span style="color: #94BFF3;">()</span>
           <span style="color: #94BFF3;">[</span><span style="color: #E0CF9F;">(</span>p ...<span style="color: #E0CF9F;">)</span> <span style="color: #E0CF9F;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #8FB28F;">()</span> b1 b2 ...<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">]</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">]</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline40" class="outline-3">
<h3 id="orgheadline40">input and output</h3>
<div class="outline-text-3" id="text-orgheadline40">
</div><div id="outline-container-orgheadline36" class="outline-4">
<h4 id="orgheadline36">port</h4>
<div class="outline-text-4" id="text-orgheadline36">
<p>
scheme的输入输出用到一个叫做port的对象,port也是first class object, port有很
多种类,比如文件,字符缓冲区, tcp网络连接, 管道等等
</p>
<ol class="org-ol">
<li><p>
文件:
</p>
<ul class="org-ul">
<li>(open-output-file fname) : 返回一个port,用于将内容写入到文件</li>
<li>(open-input-file  fname) : 返回一个port用于读取指定文件的内容</li>
<li>(close-output-port port)</li>
<li>(close-input-port port)</li>
</ul>
<p>
还有一种常用方式(更简单, 会自动关闭port):
</p>
<ul class="org-ul">
<li>(call-with-input-file filename proc) : 打开filename并将得到的port传递
给proc, 并且调用完成时会关闭port</li>
<li><p>
(call-with-output-file filename proc) : 打开filename并将得到的port传递
给proc, 并且调用完成时会关闭port
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">call-with-output-file</span> <span style="color: #CC9393;">"data"</span>
  <span style="color: #DCDCCC; font-weight: bold;">#:exists</span> 'truncate
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>out<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>display <span style="color: #CC9393;">"hello"</span> out<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">call-with-input-file</span> <span style="color: #CC9393;">"data"</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>in<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>read-line in<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
</ul></li>
<li>字符缓冲区
<ul class="org-ul">
<li>(open-output-string) :</li>
<li>(open-input-string "xxx"):</li>
</ul></li>
</ol>
</div>
<div id="outline-container-orgheadline37" class="outline-5">
<h5 id="orgheadline37">default port</h5>
<div class="outline-text-5" id="text-orgheadline37">
<p>
默认解释器会打开2个port, 一个输入,一个输出,分别会绑定到shell的输入输出,很
多实现还会打开一个error port,用于IO的scheme procedure都可以带一个可选的参
数port, 如果不指定port, 那么就使用默认的port, 默认的port有这两个函数获得
</p>
<ul class="org-ul">
<li>(current-input-port)</li>
<li>(current-output-port)</li>
</ul>
<p>
如果要改变默认的port,可以使用下面的两个函数:
</p>
<ul class="org-ul">
<li>(with-input-from-file filename thunk) : 将默认的 input port重新绑定到文
件,这可以实现重定向</li>
<li>(with-output-from-file filename thunk) : 将默认的 output port重新绑定到
文件,这可以实现重定向</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline38" class="outline-4">
<h4 id="orgheadline38">输入输出</h4>
<div class="outline-text-4" id="text-orgheadline38">
<ul class="org-ul">
<li>输入:
<ol class="org-ol">
<li>read: 它会自动将读入的内容转换为scheme内置的数据结构,实际是一个递归下
降的parser</li>
<li>(read-char), (read-char input-port): next character</li>
</ol></li>
<li>输出:
<ol class="org-ol">
<li>print</li>
<li>write</li>
<li>display</li>
<li>printf: 可以指定一个字符串来格式化,用的较多</li>
<li>fprintf: 写入文件,多一个port参数</li>
</ol></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline39" class="outline-4">
<h4 id="orgheadline39">code example</h4>
<div class="outline-text-4" id="text-orgheadline39">
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">call-with-input-file</span> <span style="color: #CC9393;">"myfile.ss"</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>p<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #93E0E3;">f</span> <span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">(</span>x <span style="color: #94BFF3;">(</span>read p<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span>
      <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #9FC59F;">(</span>eof-object? x<span style="color: #9FC59F;">)</span>
          '<span style="color: #9FC59F;">()</span>
          <span style="color: #9FC59F;">(</span>cons x <span style="color: #94BFF3;">(</span>f <span style="color: #E0CF9F;">(</span>read p<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">read-word</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>p<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>list-&gt;string
      <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #93E0E3;">f</span> <span style="color: #9FC59F;">()</span>
        <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #94BFF3;">(</span><span style="color: #E0CF9F;">(</span>c <span style="color: #8FB28F;">(</span>peek-char p<span style="color: #8FB28F;">)</span><span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span>
          <span style="color: #94BFF3;">(</span><span style="color: #F0DFAF; font-weight: bold;">cond</span>
            <span style="color: #E0CF9F;">(</span><span style="color: #8FB28F;">(</span>eof-object? c<span style="color: #8FB28F;">)</span> '<span style="color: #8FB28F;">()</span><span style="color: #E0CF9F;">)</span>
            <span style="color: #E0CF9F;">(</span><span style="color: #8FB28F;">(</span>char-alphabetic? c<span style="color: #8FB28F;">)</span>
             <span style="color: #8FB28F;">(</span>read-char p<span style="color: #8FB28F;">)</span>
             <span style="color: #8FB28F;">(</span>cons c <span style="color: #6CA0A3;">(</span>f<span style="color: #6CA0A3;">)</span><span style="color: #8FB28F;">)</span><span style="color: #E0CF9F;">)</span>
            <span style="color: #E0CF9F;">(</span><span style="color: #F0DFAF; font-weight: bold;">else</span> '<span style="color: #8FB28F;">()</span><span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline41" class="outline-3">
<h3 id="orgheadline41">递归思想</h3>
<div class="outline-text-3" id="text-orgheadline41">
<p>
递归的思想要从逻辑上理解，在设计一个递归函数时，一开始就要明确该函数在逻辑上
的作用(不要一开始就陷入编码细节中)，然后分清该函数在逻辑上与子问题的联系，并
以此为 依据来进行函数体的设计, 特别需要注意检查结束条件,比如加法(0), 乘法
(1), list('())就是一些结束条件.
</p>

<p>
递归函数的设计要点：
</p>
<ol class="org-ol">
<li>要明确检查终止条件（null？ zero？）</li>
<li>要明确与子问题的关系，弄清分类的情况（cond）</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline42" class="outline-3">
<h3 id="orgheadline42">continuation</h3>
<div class="outline-text-3" id="text-orgheadline42">
<p>
scheme中获得当前continuation的构造是call/cc, let/cc
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>let/cc k                               <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">k is the continuation</span>
        body<span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;">;;; </span><span style="color: #7F9F7F;">identical</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">call/cc</span> <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>k<span style="color: #D0BF8F;">)</span>                    <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">k is the continuation</span>
           body<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline43" class="outline-3">
<h3 id="orgheadline43">停机问题</h3>
<div class="outline-text-3" id="text-orgheadline43">
<div class="org-src-container">

<pre class="src src-scheme"><span class="linenr">1: </span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">last-try</span>
<span class="linenr">2: </span>  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span> x <span style="color: #D0BF8F;">)</span>
<span class="linenr">3: </span>    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">and</span> <span style="color: #93E0E3;">(</span> will-stop ? last-try<span style="color: #93E0E3;">)</span>
<span class="linenr">4: </span>         <span style="color: #93E0E3;">(</span> eternity x <span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
上述代码中:eternity会永远运行,比如:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">eternity</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>x<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>eternity x<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
假设存在停机函数 <code>will-stop?</code>, <code>will-stop?</code> 可以测试出一个函数是否会停机.那么:
</p>
<ol class="org-ol">
<li>假设 <code>last-try</code> 会停机, 那么 <code>(will-stop? last-try)</code> 返回 #t, 因此也就会运行
<code>(eternity x)</code>, 前面说了, eternity会永远运行, 所以 <code>last-try</code> 不会停机.</li>
<li>假设 <code>last-try</code> 不停机, 那么 <code>(will-stop? last-try)</code> 返回 #f, 因此也就不会运
行 <code>(eternity x)</code>, 那么 <code>last-try</code> 很显然就会返回. 所以 <code>last-try</code> 会停机</li>
</ol>
<p>
因此这就是个悖论.因此停机函数 will-stop?不存在
</p>
</div>
</div>
<div id="outline-container-orgheadline44" class="outline-3">
<h3 id="orgheadline44">some example code(the little schemer)</h3>
</div>
</div>
<div id="outline-container-orgheadline57" class="outline-2">
<h2 id="orgheadline57">racket</h2>
<div class="outline-text-2" id="text-orgheadline57">
</div><div id="outline-container-orgheadline46" class="outline-3">
<h3 id="orgheadline46">struct(新的数据类型)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="struct">struct</span></span></h3>
<div class="outline-text-3" id="text-orgheadline46">
<p>
语法形式: <code>(struct struct-id (field-id ...))</code>
</p>
<ul class="org-ul">
<li>struct-id : 是一个constructor, 可以用来构建一个该数据类型的实例</li>
<li>struct-id? :一个predication,测试是否是该数据类型的实例</li>
<li>struct-id-field-id: 从实例中获取 <code>field-id</code> 属性的值</li>
</ul>
<p>
下面来看个例子:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>struct posn <span style="color: #BFEBBF;">(</span>x y<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>                     <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">&#23450;&#20041;&#19968;&#20010;posn&#31867;&#22411;</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">pos1</span> <span style="color: #BFEBBF;">(</span>posn <span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>                <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">struct-id: &#26500;&#24314;&#19968;&#20010;posn&#23454;&#20363;</span>
<span style="color: #DCDCCC;">(</span>posn? pos1<span style="color: #DCDCCC;">)</span>                            <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">struct-id?: &#26159;&#21542;&#20026;&#19968;&#20010;posn&#23545;&#35937;&#23454;&#20363;</span>
<span style="color: #DCDCCC;">(</span>posn-x pos1<span style="color: #DCDCCC;">)</span>                           <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">struct-id-field-id: &#33719;&#24471;x&#23646;&#24615;</span>
</pre>
</div>
</div>

<div id="outline-container-orgheadline47" class="outline-4">
<h4 id="orgheadline47">复制更新</h4>
<div class="outline-text-4" id="text-orgheadline47">
<p>
根据已有对象更新其中的特定域然后返回新对象
</p>

<p>
语法形式: <code>(struct-copy struct-id struct-expr [field-id expr] ...)</code>
</p>
<pre class="example">
Examples:

&gt; (define p1 (posn 1 2))
&gt; (define p2 (struct-copy posn p1 [x 3]))
&gt; (list (posn-x p2) (posn-y p2))

'(3 2)
&gt; (list (posn-x p1) (posn-x p2))

'(1 3)
</pre>
</div>
</div>
<div id="outline-container-orgheadline48" class="outline-4">
<h4 id="orgheadline48">subtypes(类似于继承)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="subtypes">subtypes</span></span></h4>
<div class="outline-text-4" id="text-orgheadline48">
<p>
语法形式: <code>(struct struct-id super-id (field-id ...))</code>
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>struct posn <span style="color: #BFEBBF;">(</span>x y<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>struct pos3d posn <span style="color: #BFEBBF;">(</span>z<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
那么pos3d就有 <code>(x y z)</code> 三个属性
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline49" class="outline-3">
<h3 id="orgheadline49">match(模式匹配)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="match">match</span></span></h3>
<div class="outline-text-3" id="text-orgheadline49">
<p>
正则表达式只能用来匹配字符串,而 <code>match</code> 可以用来匹配任何的 <code>scheme value</code>,
它的语法形式如下:
</p>
<pre class="example">
(match target-expr
  [pattern expr ...+] ...)
</pre>
<p>
将 <code>target-expr</code> 与 pattern匹配, 如果匹配成功就执行后面的expr, 对pattern的
语法要做以下说明:
</p>
<ul class="org-ul">
<li>&#x2026; 或 <span class="underline">_</span> :  代表0次或者多次</li>
<li><p>
..k 或 _<sub>k</sub> : 代表至少 <code>k</code> 此
下面是一个将let转换为等价的lambda形式的例子
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>match '<span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">[</span>a <span style="color: #BFEBBF;">1</span><span style="color: #93E0E3;">]</span>
              <span style="color: #93E0E3;">[</span>b <span style="color: #BFEBBF;">2</span><span style="color: #93E0E3;">]</span><span style="color: #D0BF8F;">)</span>
          <span style="color: #D0BF8F;">(</span>set! a <span style="color: #BFEBBF;">11</span><span style="color: #D0BF8F;">)</span>
          <span style="color: #D0BF8F;">(</span>- a b<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span>
       <span style="color: #BFEBBF;">[</span>`<span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">[</span>,var* ,val*<span style="color: #9FC59F;">]</span> ...<span style="color: #93E0E3;">)</span> ,body* ...<span style="color: #D0BF8F;">)</span>
        `<span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #9FC59F;">(</span>,@var*<span style="color: #9FC59F;">)</span>
            ,@body*<span style="color: #93E0E3;">)</span> ,@val*<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
注意因为&#x2026;的作用,上面的var*, val*, body*都是列表, 所以在后面需要使用 ,@来
分解.
</p></li>
<li><p>
literal: 字面值直接用 <code>equal?</code> 测试是否相等
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>match <span style="color: #BFEBBF;">2</span>
       <span style="color: #BFEBBF;">[</span><span style="color: #BFEBBF;">1</span> 'one<span style="color: #BFEBBF;">]</span>
       <span style="color: #BFEBBF;">[</span><span style="color: #BFEBBF;">2</span> 'two<span style="color: #BFEBBF;">]</span>
       <span style="color: #BFEBBF;">[</span><span style="color: #BFEBBF;">3</span> 'three<span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>match #f
       <span style="color: #BFEBBF;">[</span>#t 'yes<span style="color: #BFEBBF;">]</span>
       <span style="color: #BFEBBF;">[</span>#f 'no<span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li><p>
(list lvp &#x2026;): 会绑定对应的标识符,注意几个特殊符号,vector和list类似
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>match '<span style="color: #BFEBBF;">(</span><span style="color: #BFEBBF;">1</span> + <span style="color: #BFEBBF;">2</span><span style="color: #BFEBBF;">)</span>
<span style="color: #BFEBBF;">[</span><span style="color: #D0BF8F;">(</span>list a '+ b<span style="color: #D0BF8F;">)</span> <span style="color: #D0BF8F;">(</span>+ a b<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>         <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">return 3</span>

<span style="color: #DCDCCC;">(</span>match '<span style="color: #BFEBBF;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span> <span style="color: #BFEBBF;">3</span><span style="color: #BFEBBF;">)</span>
<span style="color: #BFEBBF;">[</span><span style="color: #D0BF8F;">(</span>list <span style="color: #BFEBBF;">1</span> a ...<span style="color: #D0BF8F;">)</span> a<span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>                 <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">return '(2 3)</span>

<span style="color: #DCDCCC;">(</span>match '<span style="color: #BFEBBF;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span> <span style="color: #BFEBBF;">3</span> <span style="color: #BFEBBF;">4</span><span style="color: #BFEBBF;">)</span>
<span style="color: #BFEBBF;">[</span><span style="color: #D0BF8F;">(</span>list <span style="color: #BFEBBF;">1</span> a ..3<span style="color: #D0BF8F;">)</span> a<span style="color: #BFEBBF;">]</span>
<span style="color: #BFEBBF;">[</span>_ 'else<span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>                          <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">return '(2 3 4)</span>
</pre>
</div>
<p>
上例中 <code>a b</code> 就被绑定为 1, 2
</p></li>
<li><p>
(struct-id pat &#x2026;)或者(struct struct-id (pat &#x2026;)):匹配一个实例,并且绑定
一些变量
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>define-struct tree <span style="color: #BFEBBF;">(</span>val left right<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>match <span style="color: #BFEBBF;">(</span>make-tree <span style="color: #BFEBBF;">0</span> <span style="color: #D0BF8F;">(</span>make-tree <span style="color: #BFEBBF;">1</span> #f #f<span style="color: #D0BF8F;">)</span> #f<span style="color: #BFEBBF;">)</span>
       <span style="color: #BFEBBF;">[</span><span style="color: #D0BF8F;">(</span>tree a <span style="color: #93E0E3;">(</span>tree b  _ _<span style="color: #93E0E3;">)</span> _<span style="color: #D0BF8F;">)</span> <span style="color: #D0BF8F;">(</span>list a b<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>       <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">'(0 1)</span>
</pre>
</div></li>
<li>(struct struct-id _) :匹配任何 struct-id的实例</li>
<li><p>
(? expr pat &#x2026;): expr是一个predication, 只有它返回true的时候,才会匹配后
面的pat
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>match '<span style="color: #BFEBBF;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">3</span> <span style="color: #BFEBBF;">5</span><span style="color: #BFEBBF;">)</span>
       <span style="color: #BFEBBF;">[</span><span style="color: #D0BF8F;">(</span>list <span style="color: #93E0E3;">(</span>? odd?<span style="color: #93E0E3;">)</span> ...<span style="color: #D0BF8F;">)</span> 'yes<span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
它的工作原理是这样,以下面的例子为例:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>match '<span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span><span style="color: #D0BF8F;">)</span> <span style="color: #BFEBBF;">3</span> <span style="color: #BFEBBF;">6</span><span style="color: #BFEBBF;">)</span>
       <span style="color: #BFEBBF;">[</span>`<span style="color: #D0BF8F;">(</span>,<span style="color: #93E0E3;">(</span>? pred? `<span style="color: #9FC59F;">(</span>,a1 ,a2<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span> ,b ,c<span style="color: #D0BF8F;">)</span> `<span style="color: #D0BF8F;">(</span>,a1 ,b ,c<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
如果上面的例子匹配, 那么b, c应该分别绑定3, 6, 那么前面的 <code>(? pred? `(,a1
     ,a2))</code> 应该匹配(1 2), 所以先将(1 2) 传递给pred?, 如果pred? 返回#t, 那么接
着用(1 2) 去匹配后面的`(,a1 ,a2). 也就是说pred? 只会检查(? pred? &#x2026;) 匹配
的那一部分.
</p></li>
<li><p>
(quasiquote qp): unqote或unquote-splicing的部分会绑定为变量,其它部分会原样匹配
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>match '<span style="color: #BFEBBF;">(</span><span style="color: #BFEBBF;">1</span> + <span style="color: #BFEBBF;">2</span><span style="color: #BFEBBF;">)</span>
<span style="color: #BFEBBF;">[</span>`<span style="color: #D0BF8F;">(</span>,a + ,b<span style="color: #D0BF8F;">)</span> <span style="color: #D0BF8F;">(</span>+ a b<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
a b都是unquote指定的部分,所以绑定为变量, 其它部分比如 + 就原样匹配, 可以和
(? expr pat &#x2026;)结合使用:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>match '<span style="color: #BFEBBF;">(</span>+ a <span style="color: #CC9393;">"hello"</span><span style="color: #BFEBBF;">)</span>
       <span style="color: #BFEBBF;">[</span>`<span style="color: #D0BF8F;">(</span>+ a ,<span style="color: #93E0E3;">(</span>? number? x<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span> x<span style="color: #BFEBBF;">]</span>
       <span style="color: #BFEBBF;">[</span>`<span style="color: #D0BF8F;">(</span>+ a ,<span style="color: #93E0E3;">(</span>? string? x<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span> x<span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
关于quasiquote的一些说明:
</p>
<ul class="org-ul">
<li>quasiquote(`): 和quote(')类似, 只是表达式中的unquote会求值在返回,如果没
有unquote,那么它的行为就和 <code>quote</code> 一样,来看几个例子:
<code>(cons a b)</code> 等价于 <code>`(,a ,b)</code></li>
<li><p>
unquote(,): 指定的部分会先求职,在插入list中
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>quasiquote <span style="color: #BFEBBF;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span> <span style="color: #D0BF8F;">(</span>unquote <span style="color: #93E0E3;">(</span>+ <span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span> <span style="color: #D0BF8F;">(</span>unquote <span style="color: #93E0E3;">(</span>- <span style="color: #BFEBBF;">5</span> <span style="color: #BFEBBF;">1</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;">;;; </span><span style="color: #7F9F7F;">equivalent</span>
`<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span> ,<span style="color: #BFEBBF;">(</span>+ <span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span><span style="color: #BFEBBF;">)</span> ,<span style="color: #BFEBBF;">(</span>+ <span style="color: #BFEBBF;">5</span> <span style="color: #BFEBBF;">1</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>                <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">'(1 2 3 6)</span>
</pre>
</div></li>

<li><p>
unquote-splicing(,@): 和unquote的行为类似, 只是它所指定的表达式求值后必
须返回list,这个list中的元素会拆开然后插入原list中
</p>
<div class="org-src-container">

<pre class="src src-scheme">`<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span> ,@<span style="color: #BFEBBF;">(</span>list <span style="color: #D0BF8F;">(</span>+ <span style="color: #BFEBBF;">1</span> <span style="color: #BFEBBF;">2</span><span style="color: #D0BF8F;">)</span> <span style="color: #D0BF8F;">(</span><span style="color: #BFEBBF;">2</span> <span style="color: #BFEBBF;">2</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span> <span style="color: #BFEBBF;">5</span><span style="color: #DCDCCC;">)</span>         <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">'(1 2 3 4 5)</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline50" class="outline-3">
<h3 id="orgheadline50">module</h3>
<div class="outline-text-3" id="text-orgheadline50">
<p>
module的基本语法是:
</p>
<pre class="example">
(module name-id initial-module-path
  decl ...)
</pre>
<p>
例子:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>module cake racket
        <span style="color: #BFEBBF;">(</span>provide print-cake<span style="color: #BFEBBF;">)</span>

        <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">print-cake</span> n<span style="color: #D0BF8F;">)</span>
          <span style="color: #D0BF8F;">(</span>show <span style="color: #CC9393;">"   ~a   "</span> n #\.<span style="color: #D0BF8F;">)</span>
          <span style="color: #D0BF8F;">(</span>show <span style="color: #CC9393;">" .-~a-. "</span> n #\|<span style="color: #D0BF8F;">)</span>
          <span style="color: #D0BF8F;">(</span>show <span style="color: #CC9393;">" | ~a | "</span> n #\space<span style="color: #D0BF8F;">)</span>
          <span style="color: #D0BF8F;">(</span>show <span style="color: #CC9393;">"---~a---"</span> n #\-<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span>

        <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">show</span> fmt n ch<span style="color: #D0BF8F;">)</span>
          <span style="color: #D0BF8F;">(</span>printf fmt <span style="color: #93E0E3;">(</span>make-string n ch<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span>
          <span style="color: #D0BF8F;">(</span>newline<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<ul class="org-ul">
<li>name-id: module的名字,上例是 <code>cake</code></li>
<li>initial-module-path: 初始化要导入的module, 上例是 <code>racket</code></li>
<li>provide : 可选的,也就是规定哪些东西是可以导出的,上例中 <code>print-cake</code> 会导
出,但是 <code>show</code> 是模块私有, 如果不提供 <code>provide</code> 那么所有的属性都是私有的,
所以一个模块必须指定 <code>provide</code> 才对导入者有意义</li>
</ul>
<p>
声明一个模块并不会直接对模块的 <code>body</code> 部分求值,只有当使用 <code>require</code> 明确导
入该模块时才会求值
</p>
</div>
<div id="outline-container-orgheadline51" class="outline-4">
<h4 id="orgheadline51">submodule</h4>
<div class="outline-text-4" id="text-orgheadline51">
<p>
一个文件只能包含一个顶层模块,这个模块可以通过 <code>module</code> 指定,也可以通
过 <code>lang lang-name</code> 来间接的指定, 那么在这个顶层模块中又可以定义子模块,比
如如下代码:
</p>
<div class="org-src-container">

<pre class="src src-scheme">#lang racket
<span style="color: #DCDCCC;">(</span>module zoo racket
        <span style="color: #BFEBBF;">(</span>provide tiger<span style="color: #BFEBBF;">)</span>
        <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">tiger</span> <span style="color: #CC9393;">"Tony"</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span>require 'zoo<span style="color: #DCDCCC;">)</span>

tiger
</pre>
</div>
<p>
上面的代码(假设文件名是park.rtk) <code>#lang racket</code> 指定了顶层模块, 而 <code>zoo</code> 是
一个子模块, 在顶层模块中可以直接通过 <code>(require 'zoo)</code> 来包含子模块, 如果是
在该文件以外, 你需要导入该文件的模块, 使用 <code>(require "park.rtk")</code> 只会导入
顶层模块, 使用submode语法比如 <code>(require (submod "park.rtk" zoo))</code> 就可以导
入子模块了
</p>
</div>
<div id="outline-container-orgheadline52" class="outline-5">
<h5 id="orgheadline52">module*                                                                   :module*:</h5>
<div class="outline-text-5" id="text-orgheadline52">
<pre class="example">
(module* name-id initial-module-path-or-#f
decl ...)
</pre>
<p>
使用 <code>module</code> 声明的子模块可以可以被父模块导入, 但是子模块不能导入父模块,
而恰恰相反,使用 <code>module*</code> 声明的模块可以导入父模块, 可是父模块不能导入该子
模块, 如果指定 <code>#f</code> 作为默认导入模块, 那么父模块中的所有绑定在子模块中都可
见.
</p>
<div class="org-src-container">

<pre class="src src-scheme">#lang racket

<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #BFEBBF;">(</span><span style="color: #93E0E3;">print-cake</span> n<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>show <span style="color: #CC9393;">"   ~a   "</span> n #\.<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>show <span style="color: #CC9393;">" .-~a-. "</span> n #\|<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>show <span style="color: #CC9393;">" | ~a | "</span> n #\space<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>show <span style="color: #CC9393;">"---~a---"</span> n #\-<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #BFEBBF;">(</span><span style="color: #93E0E3;">show</span> fmt n ch<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>printf fmt <span style="color: #D0BF8F;">(</span>make-string n ch<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>newline<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span>module* main #f
         <span style="color: #BFEBBF;">(</span>print-cake <span style="color: #BFEBBF;">10</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
在上面的 <code>main</code> 这个submodule中, 顶层模块的所有绑定都可见, 注意当一个
submodule的名字为main时,有一个特殊的地方,也就是说当前的文件作为执行文件时
(racket file-name.rtk),即便你没有使用 <code>(require 'main)</code> 语句, 这个子模块仍
然会运行,和python的=ifmain= 很类似,所以这个main模块可以写一些本模块的测试
代码
</p>
</div>
</div>
<div id="outline-container-orgheadline53" class="outline-5">
<h5 id="orgheadline53">module+                                                                   :module+:</h5>
<div class="outline-text-5" id="text-orgheadline53">
<pre class="example">
(module+ name-id
decl ...)
</pre>
<p>
等价于
</p>
<pre class="example">
(module* name-id #f
  decl ...)
</pre>
<p>
module+一般用来写 <code>test</code> 模块, 多个test模块会合并为一个test模块, 使用raco
test filename.rkt来运行测试代码
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline54" class="outline-4">
<h4 id="orgheadline54">lang</h4>
<div class="outline-text-4" id="text-orgheadline54">
<p>
racket的源文件一般需要使用 <code>#lang lang-name</code> 这样的方式来指定语言,这个实际是一
个module的简写方式,比如 <code>#lang racket</code> 等价于:
</p>
<pre class="example">
(module name racket
  decl ...)
</pre>
<p>
所以 <code>#lang racket</code> 的意思就是定义一个module, 该模块的名字一般继承自文件名,
然后将racket作为初始模块导入.
</p>
</div>
</div>
<div id="outline-container-orgheadline55" class="outline-4">
<h4 id="orgheadline55">require</h4>
<div class="outline-text-4" id="text-orgheadline55">
<ol class="org-ol">
<li><p>
如果是文件那么应该使用这样的语法:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>require <span style="color: #CC9393;">"aa.rkt"</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>require <span style="color: #CC9393;">"../aa.rkt"</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>require <span style="color: #CC9393;">"../subdirectory/aa.rkt"</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
以当前文件的路径为当前路径,使用和shell类似的路径表达方式来确定需要导入的模
块的名字,记住要带扩展名
</p></li>
<li>当前文件的子模块: <code>(require 'name)</code></li>
<li>标准模块: <code>(require racket)</code></li>
<li>子模块: <code>(require (submod "aa.rkt" submod-name))</code></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline56" class="outline-4">
<h4 id="orgheadline56">provide</h4>
<div class="outline-text-4" id="text-orgheadline56">
<ul class="org-ul">
<li>导出所有: <code>(provide (all-defined-out))</code></li>
<li>只导出通过require引入的绑定: <code>(provide (all-from-out))</code></li>
<li>导出除指定的外所有的绑定: <code>(provide (except-out name ...))</code></li>
<li>重命名: <code>(provide (rename-out [orgn-id export-id]))</code></li>
</ul>

<p>
some example:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>provide run run-all<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>provide <span style="color: #BFEBBF;">(</span>all-defined-out<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline66" class="outline-2">
<h2 id="orgheadline66">typed racket</h2>
<div class="outline-text-2" id="text-orgheadline66">
</div><div id="outline-container-orgheadline58" class="outline-3">
<h3 id="orgheadline58">sample program</h3>
<div class="outline-text-3" id="text-orgheadline58">
<div class="org-src-container">

<pre class="src src-scheme">#lang typed/racket
<span style="color: #DCDCCC;">(</span>struct: pt <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span>x : Real<span style="color: #D0BF8F;">]</span> <span style="color: #D0BF8F;">[</span>y : Real<span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span>: distance <span style="color: #BFEBBF;">(</span>pt pt -&gt; Real<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #BFEBBF;">(</span><span style="color: #93E0E3;">distance</span> p1 p2<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>sqrt <span style="color: #D0BF8F;">(</span>+ <span style="color: #93E0E3;">(</span>sqr <span style="color: #9FC59F;">(</span>- <span style="color: #94BFF3;">(</span>pt-x p2<span style="color: #94BFF3;">)</span> <span style="color: #94BFF3;">(</span>pt-x p1<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span>
           <span style="color: #93E0E3;">(</span>sqr <span style="color: #9FC59F;">(</span>- <span style="color: #94BFF3;">(</span>pt-y p2<span style="color: #94BFF3;">)</span> <span style="color: #94BFF3;">(</span>pt-y p1<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline65" class="outline-3">
<h3 id="orgheadline65">Types</h3>
<div class="outline-text-3" id="text-orgheadline65">
</div><div id="outline-container-orgheadline59" class="outline-4">
<h4 id="orgheadline59">Basic Types</h4>
<div class="outline-text-4" id="text-orgheadline59">
<ol class="org-ol">
<li>Number</li>
<li>Char</li>
<li>String</li>
<li>Boolean</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline60" class="outline-4">
<h4 id="orgheadline60">Function Type</h4>
<div class="outline-text-4" id="text-orgheadline60">
<p>
(Number -&gt; Number)
(String String -&gt; Number)
</p>
</div>
</div>
<div id="outline-container-orgheadline61" class="outline-4">
<h4 id="orgheadline61">Union Type</h4>
<div class="outline-text-4" id="text-orgheadline61">
<p>
当一个类型有几种变种时, 应该使用Union Type
</p>
<div class="org-src-container">

<pre class="src src-scheme">#lang typed/racket
<span style="color: #DCDCCC;">(</span>define-type Tree <span style="color: #BFEBBF;">(</span>U leaf node<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>struct: leaf <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span>val : Number<span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>struct: node <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">[</span>left : Tree<span style="color: #D0BF8F;">]</span> <span style="color: #D0BF8F;">[</span>right : Tree<span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span>: tree-height <span style="color: #BFEBBF;">(</span>Tree -&gt; Integer<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #BFEBBF;">(</span><span style="color: #93E0E3;">tree-height</span> t<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">cond</span> <span style="color: #D0BF8F;">[</span><span style="color: #93E0E3;">(</span>leaf? t<span style="color: #93E0E3;">)</span> <span style="color: #BFEBBF;">1</span><span style="color: #D0BF8F;">]</span>
        <span style="color: #D0BF8F;">[</span>else <span style="color: #93E0E3;">(</span>max <span style="color: #9FC59F;">(</span>+ <span style="color: #BFEBBF;">1</span> <span style="color: #94BFF3;">(</span>tree-height <span style="color: #E0CF9F;">(</span>node-left t<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span>
                   <span style="color: #9FC59F;">(</span>+ <span style="color: #BFEBBF;">1</span> <span style="color: #94BFF3;">(</span>tree-height <span style="color: #E0CF9F;">(</span>node-right t<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">]</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
上面的Tree就包含两种类型, Node与Leaf
</p>
</div>
</div>
<div id="outline-container-orgheadline62" class="outline-4">
<h4 id="orgheadline62">Recursive Type</h4>
<div class="outline-text-4" id="text-orgheadline62">
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>define-type BinaryTree <span style="color: #BFEBBF;">(</span>Rec BT <span style="color: #D0BF8F;">(</span>U Number <span style="color: #93E0E3;">(</span>Pair BT BT<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline63" class="outline-4">
<h4 id="orgheadline63">Subtyping</h4>
<div class="outline-text-4" id="text-orgheadline63">
<p>
任何类型都是Any的子类型.
</p>
</div>
</div>
<div id="outline-container-orgheadline64" class="outline-4">
<h4 id="orgheadline64">Polymorphism</h4>
<div class="outline-text-4" id="text-orgheadline64">
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>: list-length <span style="color: #BFEBBF;">(</span>All <span style="color: #D0BF8F;">(</span>A<span style="color: #D0BF8F;">)</span> <span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">(</span>Listof A<span style="color: #93E0E3;">)</span> -&gt; Integer<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #BFEBBF;">(</span><span style="color: #93E0E3;">list-length</span> l<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #D0BF8F;">(</span>null? l<span style="color: #D0BF8F;">)</span>
      <span style="color: #BFEBBF;">0</span>
      <span style="color: #D0BF8F;">(</span>add1 <span style="color: #93E0E3;">(</span>list-length <span style="color: #9FC59F;">(</span>cdr l<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
注意上面的 <code>All</code>.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<!-- 多说评论框 start -->
  <div id="duoshuo-id" class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
   var url = window.location.pathname;
   var duoshuo_identifier = url.substring(url.lastIndexOf('/')+1);
   if (!!! duoshuo_identifier) {
     duoshuo_identifier = "index.html";
   }
   var title = document.title;
   var ele = document.getElementById("duoshuo-id");
   ele.setAttribute("data-thread-key", duoshuo_identifier);
   ele.setAttribute("data-title", title);
   ele.setAttribute("data-url", url);

</script>

<script type="text/javascript">
var duoshuoQuery = {short_name:"yuyang0"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementById('postamble')
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end --><!-- begin footer -->
<div id="footer">
  <ul class="links vertical-nav">
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a class="back-to-top" href="#">Back to Top</a></li>
  </ul>
  <span>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</span>
  <a href="#" class="back-to-top" id="fixed-back-to-top" ></a>
</div>
<script src="http://apps.bdimg.com/libs/jquery/2.0.0/jquery.min.js"></script>
<script type="text/javascript">
	window.jQuery || document.write('<script src="static/js/jquery-2.0.0.min.js"><\/script>');
	</script>
<script type="text/javascript" src="static/js/custom.js"></script>
<!-- end footer -->
</div>
</body>
</html>
