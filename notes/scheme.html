<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>scheme笔记</title>
<!-- 2014-02-01 Sat 10:57 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Yu Yang" />
<meta  name="keywords" content="scheme lisp" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/> <link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="blog-title"><a href="/"> Yu Yang's Blog</a></h1>
        <ul class="nav">
          <li> <a href="/">Home</a></li>
          <li> <a href="/about.html">About</a></li>
          <li> <a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" action="https://google.com/search" id="search">
          <input type="hidden" name="q" value="site:yuyang.farbox.com" />
          <input type="text" name="q" placeholder="Search..." />
        </form>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">scheme笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">scheme笔记</a>
<ul>
<li><a href="#sec-1-1">几个概念&#xa0;&#xa0;&#xa0;<span class="tag"><span class="concept">concept</span></span></a>
<ul>
<li><a href="#sec-1-1-1">identifier</a></li>
<li><a href="#sec-1-1-2">variable</a></li>
<li><a href="#sec-1-1-3">atom</a></li>
<li><a href="#sec-1-1-4">list</a></li>
<li><a href="#sec-1-1-5">S-expression</a></li>
<li><a href="#sec-1-1-6">Number</a></li>
<li><a href="#sec-1-1-7">arithmetic expression</a></li>
<li><a href="#sec-1-1-8">logcal expression</a></li>
<li><a href="#sec-1-1-9">condition expression</a></li>
<li><a href="#sec-1-1-10">多条表达式</a></li>
<li><a href="#sec-1-1-11">The Law of Car</a></li>
<li><a href="#sec-1-1-12">The Law of Cdr</a></li>
<li><a href="#sec-1-1-13">The Law of Cons</a></li>
<li><a href="#sec-1-1-14">The Law of Null?</a></li>
<li><a href="#sec-1-1-15">The Law of Eq?</a></li>
<li><a href="#sec-1-1-16">The primitive fuctions</a></li>
<li><a href="#sec-1-1-17">quote，引用</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Naming Conventions</a></li>
<li><a href="#sec-1-3">core syntactic forms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="core">core</span>&#xa0;<span class="syntactic">syntactic</span>&#xa0;<span class="form">form</span></span></a></li>
<li><a href="#sec-1-4">let&#xa0;&#xa0;&#xa0;<span class="tag"><span class="let">let</span></span></a></li>
<li><a href="#sec-1-5">control flow</a>
<ul>
<li><a href="#sec-1-5-1">if&#xa0;&#xa0;&#xa0;<span class="tag"><span class="if">if</span></span></a></li>
<li><a href="#sec-1-5-2">cond&#xa0;&#xa0;&#xa0;<span class="tag"><span class="cond">cond</span></span></a></li>
<li><a href="#sec-1-5-3">when unless&#xa0;&#xa0;&#xa0;<span class="tag"><span class="when">when</span>&#xa0;<span class="unless">unless</span></span></a></li>
<li><a href="#sec-1-5-4">case&#xa0;&#xa0;&#xa0;<span class="tag"><span class="case">case</span></span></a></li>
<li><a href="#sec-1-5-5">do&#xa0;&#xa0;&#xa0;<span class="tag"><span class="do">do</span></span></a></li>
<li><a href="#sec-1-5-6">map</a></li>
<li><a href="#sec-1-5-7">for-each</a></li>
<li><a href="#sec-1-5-8">apply</a></li>
<li><a href="#sec-1-5-9">multiple values</a></li>
</ul>
</li>
<li><a href="#sec-1-6">内置的函数</a>
<ul>
<li><a href="#sec-1-6-1">predication</a></li>
<li><a href="#sec-1-6-2">list procedure</a></li>
<li><a href="#sec-1-6-3">number procedure</a></li>
<li><a href="#sec-1-6-4">char</a></li>
<li><a href="#sec-1-6-5">string</a></li>
<li><a href="#sec-1-6-6">vector procedure</a></li>
<li><a href="#sec-1-6-7">symbol procedure</a></li>
<li><a href="#sec-1-6-8">Hash Table</a></li>
</ul>
</li>
<li><a href="#sec-1-7">macros</a>
<ul>
<li><a href="#sec-1-7-1">define-syntax</a></li>
<li><a href="#sec-1-7-2">let-syntax与letrec-syntax</a></li>
<li><a href="#sec-1-7-3">syntax-rules</a></li>
<li><a href="#sec-1-7-4">syntax-case</a></li>
<li><a href="#sec-1-7-5">syntax</a></li>
<li><a href="#sec-1-7-6">with-syntax</a></li>
</ul>
</li>
<li><a href="#sec-1-8">input and output</a></li>
<li><a href="#sec-1-9">递归思想</a></li>
<li><a href="#sec-1-10">continuation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="continuation">continuation</span></span></a>
<ul>
<li><a href="#sec-1-10-1">call/cc</a></li>
<li><a href="#sec-1-10-2">应用</a></li>
<li><a href="#sec-1-10-3">CPS</a></li>
</ul>
</li>
<li><a href="#sec-1-11">停机问题</a></li>
<li><a href="#sec-1-12">some example code(the little schemer)</a></li>
<li><a href="#sec-1-13">racket&#xa0;&#xa0;&#xa0;<span class="tag"><span class="racket">racket</span></span></a>
<ul>
<li><a href="#sec-1-13-1">struct(新的数据类型)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="struct">struct</span></span></a>
<ul>
<li><a href="#sec-1-13-1-1">复制更新</a></li>
<li><a href="#sec-1-13-1-2">subtypes(类似于继承)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="subtypes">subtypes</span></span></a></li>
</ul>
</li>
<li><a href="#sec-1-13-2">match(模式匹配)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="match">match</span></span></a></li>
<li><a href="#sec-1-13-3">module</a>
<ul>
<li><a href="#sec-1-13-3-1">submodule</a>
<ul>
<li><a href="#sec-1-13-3-1-1">module*                                                                   :module*:</a></li>
<li><a href="#sec-1-13-3-1-2">module+                                                                   :module+:</a></li>
</ul>
</li>
<li><a href="#sec-1-13-3-2">lang</a></li>
<li><a href="#sec-1-13-3-3">require</a></li>
<li><a href="#sec-1-13-3-4">provide</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">scheme笔记</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">几个概念&#xa0;&#xa0;&#xa0;<span class="tag"><span class="concept">concept</span></span></h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">identifier</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
标识符,可以看作是一个唯一的名字,可以用来引用变量,函数等等
</p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">variable</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
变量
</p>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">atom</h4>
<div class="outline-text-4" id="text-1-1-3">
<p class="verse">
a string of characters<br  />
a string of digits<br  />
<br  />
(quote atom) or 'atom<br  />
</p>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">list</h4>
<div class="outline-text-4" id="text-1-1-4">
<p class="verse">
a collection of atoms enclosed by parentheses.<br  />
example:<br  />
'()<br  />
'(a)<br  />
'(a b c)<br  />
'((a b) c d)<br  />
</p>
</div>
</div>

<div id="outline-container-sec-1-1-5" class="outline-4">
<h4 id="sec-1-1-5">S-expression</h4>
<div class="outline-text-4" id="text-1-1-5">
<p class="verse">
all lists<br  />
all atoms<br  />
</p>
</div>
</div>

<div id="outline-container-sec-1-1-6" class="outline-4">
<h4 id="sec-1-1-6">Number</h4>
<div class="outline-text-4" id="text-1-1-6">
<p>
we only use whole number
we only use nonegative integers
</p>
</div>
</div>

<div id="outline-container-sec-1-1-7" class="outline-4">
<h4 id="sec-1-1-7">arithmetic expression</h4>
<div class="outline-text-4" id="text-1-1-7">
<div class="org-src-container">

<pre class="src src-scheme"><span class="linenr">1: </span>(+ 1 2 3 4 5) <span style="color: #75715E;">;;</span><span style="color: #75715E;">return 15</span>
<span class="linenr">2: </span>(- 10 2 3)      <span style="color: #75715E;">;; </span><span style="color: #75715E;">return 5</span>
<span class="linenr">3: </span>(* 2 3 4)     <span style="color: #75715E;">;; </span><span style="color: #75715E;">return 24</span>
<span class="linenr">4: </span>(/ 10 5 5)    <span style="color: #75715E;">;;</span><span style="color: #75715E;">return 1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-8" class="outline-4">
<h4 id="sec-1-1-8">logcal expression</h4>
<div class="outline-text-4" id="text-1-1-8">
<p class="verse">
and: (and &lt;p1&gt; &lt;p2&gt; &#x2026; &lt;pn&gt;)<br  />
or:  (or &lt;p1&gt; &lt;p2&gt; &#x2026;.&lt;pn&gt;)<br  />
not: (not &lt;p&gt;)<br  />
</p>
</div>
</div>

<div id="outline-container-sec-1-1-9" class="outline-4">
<h4 id="sec-1-1-9">condition expression</h4>
<div class="outline-text-4" id="text-1-1-9">
<div class="org-src-container">

<pre class="src src-scheme"><span class="linenr"> 1: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">var</span> 2)
<span class="linenr"> 2: </span>(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">add</span> x y) (+ x y)
<span class="linenr"> 3: </span>  (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr"> 4: </span>   (<span style="color: #66D9EF;">&lt;p1&gt;</span> <span style="color: #66D9EF;">&lt;e1&gt;</span>)
<span class="linenr"> 5: </span>   (<span style="color: #66D9EF;">&lt;p2&gt;</span> <span style="color: #66D9EF;">&lt;e2&gt;</span>)
<span class="linenr"> 6: </span>   (<span style="color: #66D9EF;">&lt;p3&gt;</span> <span style="color: #66D9EF;">&lt;e3&gt;</span>)
<span class="linenr"> 7: </span>   (<span style="color: #F92672; font-weight: bold;">else</span> (else-clause))))
<span class="linenr"> 8: </span>(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">abs</span> x)
<span class="linenr"> 9: </span>  (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr">10: </span>   (&lt; x 0) (- x)
<span class="linenr">11: </span>   (<span style="color: #F92672; font-weight: bold;">else</span> x)))
<span class="linenr">12: </span>(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">abs</span> x)
<span class="linenr">13: </span>  (<span style="color: #F92672; font-weight: bold;">if</span> (&lt; x 0)
<span class="linenr">14: </span>      (- x)
<span class="linenr">15: </span>      x))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-10" class="outline-4">
<h4 id="sec-1-1-10">多条表达式</h4>
<div class="outline-text-4" id="text-1-1-10">
<p>
(begin &#x2026;.)
cond的body中有一个隐含的begin，所以cond中可以放多条表达式，而对于if则
必须使用begin明确的将多条表达式包含起来
</p>
</div>
</div>

<div id="outline-container-sec-1-1-11" class="outline-4">
<h4 id="sec-1-1-11">The Law of Car</h4>
<div class="outline-text-4" id="text-1-1-11">
<p>
The primitive Car is defined only for non­empty lists.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-12" class="outline-4">
<h4 id="sec-1-1-12">The Law of Cdr</h4>
<div class="outline-text-4" id="text-1-1-12">
<ul class="org-ul">
<li>The primitive cdr is defined only for non­empty lists.
</li>
<li>The cdr of any non-empty list is always another list.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-1-13" class="outline-4">
<h4 id="sec-1-1-13">The Law of Cons</h4>
<div class="outline-text-4" id="text-1-1-13">
<ul class="org-ul">
<li>The primitive Cons takes two arguments.
</li>
<li>The second argument to cons must be a list.
</li>
<li>The result is a list.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-1-14" class="outline-4">
<h4 id="sec-1-1-14">The Law of Null?</h4>
<div class="outline-text-4" id="text-1-1-14">
<p>
The primitive null? is defined only for lists.(only (null? '()) return #t)
</p>
</div>
</div>

<div id="outline-container-sec-1-1-15" class="outline-4">
<h4 id="sec-1-1-15">The Law of Eq?</h4>
<div class="outline-text-4" id="text-1-1-15">
<ul class="org-ul">
<li>The primitive eq? takes two arguments.
</li>
<li>Each must be a non-numeric atom.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-1-16" class="outline-4">
<h4 id="sec-1-1-16">The primitive fuctions</h4>
<div class="outline-text-4" id="text-1-1-16">
<ul class="org-ul">
<li>number?
</li>
<li>eq?
</li>
<li>null?
</li>
<li>zero?
</li>
<li>car
</li>
<li>cdr
</li>
<li>cons
</li>
</ul>
<p>
<b>(the three fuction below is defined by the book)</b>
</p>
<ul class="org-ul">
<li>atom?
</li>
<li>add1
</li>
<li>sub1
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-1-17" class="outline-4">
<h4 id="sec-1-1-17">quote，引用</h4>
<div class="outline-text-4" id="text-1-1-17">
<p>
first&#x2013;&#x2014;&gt; symbol(or a variable)
'first-&#x2014;&gt; an atom
'1 or 1&#x2014;&gt; a number
当调用函数时，先会对各个参数求值，所以每一个参数要么是atom，list或者一
个已经绑定的symbol
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Naming Conventions</h3>
<div class="outline-text-3" id="text-1-2">
<ol class="org-ol">
<li>谓词后加? , 但是常用的数字比较=, &lt;, &gt;, &lt;=, &gt;=后面不需要?
</li>
<li>类型测试, pair? , atom?
</li>
<li>字符操作(char-xxx), 字符串操作(string-xxx), 向量操作(vector-xxx)
</li>
<li>类型转换(type1-&gt;type2)
</li>
<li>但函数有副作用时,应该以 ! 结尾, 比如 <code>set!</code>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">core syntactic forms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="core">core</span>&#xa0;<span class="syntactic">syntactic</span>&#xa0;<span class="form">form</span></span></h3>
<div class="outline-text-3" id="text-1-3">
<ol class="org-ol">
<li>top-level <code>define</code> forms
实际就是创建新的绑定,可以绑定 <code>list</code>, <code>lambda procedure</code> 这是几个示例代
码:
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">double-any</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (f x)
    (f x x)))
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">identical</span>
(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">double-any</span> f x)
  (f x x))

(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">xyz</span> '(x y z))
</pre>
</div>
</li>
<li>constants
&lt;constant&gt; -&#x2014;&gt; &lt;boolean&gt; | &lt;number&gt; | &lt;character&gt; | &lt;string&gt;
</li>
<li>variables
</li>
<li>procedure applications <code>(procedure arg_1 ... arg_n)</code>
<ul class="org-ul">
<li>Find the value of <code>procedure</code>.
</li>
<li>Find the value of <code>arg_1</code>.
</li>
<li>Find the value of <code>arg_n</code>.
</li>
<li>Apply the value of <code>procedure</code> to the values of <code>arg_1</code> &#x2026; <code>arg_n</code>.
</li>
</ul>
</li>
<li><code>quote</code> expressions (')
<ol class="org-ol">
<li>quoting an <code>identifier</code> tells Scheme to treat the identifier as a
<code>symbol</code> rather than as a <code>variable</code>. 也就是说scheme解释器不会去当前的
环境中寻找与该标识符绑定的值, 而是直接将该标识符当作symbol也就是数据处理.
</li>
<li>quoting a list tells scheme to treat the list as data, rather than
as a procedure application
</li>
</ol>
</li>
<li><code>lambda</code> expressions
      <code>(lambda (x) (+ x x)) ==&gt; #&lt;procedure&gt;</code>

<p>
一般形式有这三种:
</p>
<ul class="org-ul">
<li><code>(lambda (var1 var2 ...) exp1 exp2 ...)</code>: var1 var2 &#x2026;会依次赋值
</li>
<li><code>(lambda (var1 var2 . var) exp1 exp2)</code>: var1 var2会依次赋值, 余下的参数
会组成一个列表赋给var
</li>
<li><code>(lambda var exp1 exp2)</code>: 将所有的实参作为一个list赋给var, 注意var没有括号
</li>
</ul>
</li>
<li><code>if</code> expressions: <code>(if test-expr then-expr else-expr)</code> 只有 <code>test-expr</code>
为 <code>#f</code> 时才会运行 <code>else-expr</code>, 所以你一般要使用 <code>null?</code> <code>eq?</code> 这样的函数
来测试
</li>
<li><code>set!</code> expressions(Assignment):  Assignments do not create new bindings,
as with <code>let</code> or <code>lambda</code>, but rather change the values of existing
bindings.也就是说赋值不会像let, lambda那样产生新的绑定,而是会改变已存在绑
定的值,如果你给set!指定的符号不存在,它会报错(set!: cannot set undefined
variable)
</li>
</ol>
<p>
其它的都是一些扩展,也就是可以通过define-syntax定义出来的,比如let,and,or,not等
等,只有以上的部分才需要解释器直接实现的
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">let</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
    [(_ ((x v) ...) e1 e2 ...)
     ((<span style="color: #F92672; font-weight: bold;">lambda</span> (x ...) e1 e2 ...) v ...)]))

(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">and</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
    [(_) #t]
    [(_ e) e]
    [(_ e1 e2 e3 ...)
     (<span style="color: #F92672; font-weight: bold;">if</span> e1 (<span style="color: #F92672; font-weight: bold;">and</span> e2 e3 ...) #f)]))
</pre>
</div>
<p>
实际上define-syntax实际就是进行模式匹配,像cond,如果匹配那么就进行替换,比如
(and 1)就匹配((_ e) e)所以就被替换为1, _就是and的占位符, 而 <code>pat ...</code> 代表0个
或者多个表达式, 比如 <code>(x v)</code> 代表有0个或多个 <code>(x v)</code> 这样的表达式
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">let&#xa0;&#xa0;&#xa0;<span class="tag"><span class="let">let</span></span></h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #75715E;">;;; </span><span style="color: #75715E;">form 1</span>
(<span style="color: #F92672; font-weight: bold;">let</span> ((a exp1)
      (b exp2))
  (body1)
  (body2))
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">form2</span>
(<span style="color: #F92672; font-weight: bold;">let</span> <span style="color: #A6E22E;">f</span> ([a exp1]
        [b exp2])
  (body1)
  (body2))
</pre>
</div>
<p>
由于 <code>scheme</code> 对待中括号与对待小括号是一样的,所以为了可读性, <code>let</code> 一般可以用如下代
码:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> ([a exp1]
      [b exp2])
  (body1)
  (body2))
</pre>
</div>
<p>
form2主要是为了递归, 它使得在函数体中可以引用函数名, 比如下面的代码
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> <span style="color: #A6E22E;">fac</span> ([n 10])
  (<span style="color: #F92672; font-weight: bold;">if</span> (zero? n)
      1
      (* n (fac (sub1 n)))))
</pre>
</div>
<ul class="org-ul">
<li>let: 如上所见,实际就是一个扩展语法,a,b只在body中可见, 所以你在exp2中不能使
用a
</li>
<li>let*: exp2中可以引用a, 也就是a可以用来定义b, 可以用嵌套的 <code>let</code> 来定义
     <code>let*</code>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">let*</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
    [(_ () e1 e2 ...)
     (<span style="color: #F92672; font-weight: bold;">let</span> () e1 e2 ...)]
    [(_ ((x1 v1) (x2 v2) ...) e1 e2 ...)
     (<span style="color: #F92672; font-weight: bold;">let</span> ((x1 v1))
       (<span style="color: #F92672; font-weight: bold;">let*</span> ((x2 v2) ...) e1 e2 ...))]))
</pre>
</div>
</li>
<li>letrec: 主要用来解决定义递归函数时,函数名在函数体中不可见的问题,比如
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> ([sum (<span style="color: #F92672; font-weight: bold;">lambda</span> (lst)
                (<span style="color: #F92672; font-weight: bold;">if</span> (null? lst) 0
                    (+ (car lst) (sum (cdr lst)))))])
  (sum '(1 2 3 4 5)))
</pre>
</div>
<p>
如果运行上面的代码,那么你会 <code>sum undefined</code> 的错误, 原因是 <code>sum</code> 在后面的函数
体中不可见, 所以你使用 <code>(sum (cdr lst))</code> 就会出错,当然你可以使用这种方法
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> ([sum (<span style="color: #F92672; font-weight: bold;">lambda</span> (sum lst)
                (<span style="color: #F92672; font-weight: bold;">if</span> (null? lst) 0
                    (+ (car lst) (sum sum (cdr lst)))))])
  (sum sum '(1 2 3 4 5)))
</pre>
</div>
<p>
但这种方法不够自然,而且比较丑陋,不符合scheme中定义递归函数的一般模式,所以
就引入了 <code>letec</code>.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">letrec</span> ([sum (<span style="color: #F92672; font-weight: bold;">lambda</span> (ls)
                (<span style="color: #F92672; font-weight: bold;">if</span> (null? ls)
                    0
                    (+ (car ls) (sum (cdr ls)))))])
  (sum '(1 2 3 4 5)))
<span style="color: #75715E;">;; </span><span style="color: #75715E;">the result is 15</span>
</pre>
</div>
</li>
<li>letrec*: 和 <code>letrec</code> 类似, 只是后面的绑定可以引用前面已经绑定的变量
</li>
<li>let-values: 绑定多个变量
syntax:
<ul class="org-ul">
<li>(let-values ((formals expr) &#x2026;) body1 body2 &#x2026;)
</li>
<li>(let*-values ((formals expr) &#x2026;) body1 body2 &#x2026;)
</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let-values</span> ([(a b) (values 1 2)] [c (values 1 2 3)])
  (list a b c)) <span style="color: #75715E;">; </span><span style="color: #75715E;">the result is (1 2 (1 2 3))</span>

(<span style="color: #F92672; font-weight: bold;">let*-values</span> ([(a b) (values 1 2)] [(a b) (values b a)])
  (list a b)) <span style="color: #75715E;">; </span><span style="color: #75715E;">the result is (2 1)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">control flow</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">if&#xa0;&#xa0;&#xa0;<span class="tag"><span class="if">if</span></span></h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
当要写多个表达式时应该加入 <code>begin</code> , 注意 <code>begin</code> 会依次执行它所包含的表达式,并
返回最后一个表达式的值
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">if</span> (test-exp)
    (<span style="color: #F92672; font-weight: bold;">begin</span>
      expression1
      expression2)
    expression3)
</pre>
</div>
<p>
如果 <code>test-exp</code> 为true, 依次执行 <code>expression1</code>, <code>expression2</code> 那么返回
<code>expression2</code> 的值, 之所以需要 <code>begin</code> 是由 <code>if</code> 的语法决定的, <code>if</code> 的语
法如下:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">if</span> (test-exp)
    (true-exp)
    (false-exp))
</pre>
</div>
<p>
所以如果你在 <code>true-exp</code> 的位置放入多条表达式,那么这些表达式的第二条会被当
作 <code>false-exp</code> ,而且因为 <code>if</code> 后的表达式的条数超出 <code>2</code> 条而报错, 所以你需
要把多条表达式括起来,但是你不能直接加一个括号,比如
</p>
<pre class="example">
((true-exp1)(true-exp2))
</pre>
<p>
这样之所以不行是因为scheme会将 (true-exp1) 当作procedure求
值,这显然不对, 所以scheme使用begin, 也就变成了:
</p>
<pre class="example">
(begin
  (true-exp1)
  (true-exp2))
</pre>
<p>
这就是if使用begin的原因了, 注意在 <b>let, lambda, define,cond的body中都不需
要begin,因为它们都没有if这种特殊的状况</b>
</p>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">cond&#xa0;&#xa0;&#xa0;<span class="tag"><span class="cond">cond</span></span></h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
内部相当于有个隐含的begin,所以可以直接写多个表达式
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">cond</span>
 ((test-exp) (exp1) (exp2))
 (<span style="color: #F92672; font-weight: bold;">else</span> expression3))
</pre>
</div>
<p>
如果test-exp为true, 那么返回expression2的值
注意一个特殊的形式: =&gt;
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">cond</span> ((assv 'b '((a 1) (b 2))) =&gt; cadr)
      (<span style="color: #F92672; font-weight: bold;">else</span> #f))                       <span style="color: #75715E;">;; </span><span style="color: #75715E;">==&gt;  2</span>
</pre>
</div>
<p>
会将 test-exp的值传递给 =&gt;后面的函数, =&gt;后面必须是一个带一个参数的函数
</p>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">when unless&#xa0;&#xa0;&#xa0;<span class="tag"><span class="when">when</span>&#xa0;<span class="unless">unless</span></span></h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>(when (test-exp) exp1 exp2) : test-exp为真就执行exp1, exp2
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">when</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
    [(_ e0 e1 e2 ...) (<span style="color: #F92672; font-weight: bold;">if</span> e0 (<span style="color: #F92672; font-weight: bold;">begin</span> e1 e2 ...))]))
</pre>
</div>
</li>
<li>(unless (test-exp) exp1 exp2) : 只有当 <code>test-exp</code> 为#f时才会运行body中的
表达式
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4">case&#xa0;&#xa0;&#xa0;<span class="tag"><span class="case">case</span></span></h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
类似于C语言的switch
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> ((x 4) (y 5))
  (<span style="color: #F92672; font-weight: bold;">case</span> (+ x y)
    ((1 3 5 7 9) 'odd)
    ((0 2 4 6 8) 'even)
    (<span style="color: #F92672; font-weight: bold;">else</span> 'out-of-range))) <span style="color: #75715E;">;; </span><span style="color: #75715E;">===&gt; odd</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-5" class="outline-4">
<h4 id="sec-1-5-5">do&#xa0;&#xa0;&#xa0;<span class="tag"><span class="do">do</span></span></h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
<code>syntax: (do ((var init update) ...) (test result ...) expr ...)</code>
</p>

<p>
循环(do ((var init update) &#x2026;) (test res &#x2026;) exp &#x2026;)  var的初始值是init,接
着每一次迭代都绑定到update, (test res..)如果为true,那么就终止循环
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">divisors</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (n)
    (<span style="color: #F92672; font-weight: bold;">do</span> ((i 2 (+ i 1))
         (ls '()
             (<span style="color: #F92672; font-weight: bold;">if</span> (integer? (/ n i))
                 (cons i ls)
                 ls)))
        ((&gt;= i n) ls))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-6" class="outline-4">
<h4 id="sec-1-5-6">map</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
(map procedure list1 list2 &#x2026;) 会返回一个 <code>list</code>
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">map</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> (x y) (* x y))
     '(1 2 3 4)
     '(8 7 6 5))      <span style="color: #75715E;">; </span><span style="color: #75715E;">return (8 14 18 20)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-7" class="outline-4">
<h4 id="sec-1-5-7">for-each</h4>
<div class="outline-text-4" id="text-1-5-7">
<p>
和map类似但是不返回一个list作为结果
</p>
</div>
</div>

<div id="outline-container-sec-1-5-8" class="outline-4">
<h4 id="sec-1-5-8">apply</h4>
<div class="outline-text-4" id="text-1-5-8">
<p>
(apply procedure obj &#x2026; list)
</p>
<ul class="org-ul">
<li><code>(apply + '(4 5)) ===&gt; 9</code>
</li>
<li><code>(apply min  5 1 3 '(6 8 3 2 5))</code> 结果是1
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5-9" class="outline-4">
<h4 id="sec-1-5-9">multiple values</h4>
<div class="outline-text-4" id="text-1-5-9">
<ul class="org-ul">
<li>(values obj &#x2026;) :返回多个值,注意它的返回值可以用 <code>let-values</code> 来绑定,不能用 <code>define</code>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let-values</span> ([(a b) (values 1 2)])
  (+ a b))
</pre>
</div>
</li>
<li>(call-with-values producer consumer): producer产生多个值, 然后将这些值传
递给consumer.注意producer必须可以不带参数的方式来调用
<div class="org-src-container">

<pre class="src src-scheme">(call-with-values
  (<span style="color: #F92672; font-weight: bold;">lambda</span> () (values 'bond 'james))
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x y) (cons y x)))  <span style="color: #75715E;">; </span><span style="color: #75715E;">the result is (james . bond)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">内置的函数</h3>
<div class="outline-text-3" id="text-1-6">
</div><div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">predication</h4>
<div class="outline-text-4" id="text-1-6-1">
<ol class="org-ol">
<li>= : 只用来比较整数, 不要用来比较浮点数
</li>
<li>eq? : 可以类似的看作是指针比较, 即便是内容相同,但是如果是两个不同对象,它
就返回 <code>#f</code>, 比如 <code>(eq? (cons 'a 'b) (cons 'a 'b))</code> 虽然是同样的list, 可
是它在内存中的位置不同,所以为 #f. 有以下几种情况是相等的.
<ul class="org-ul">
<li>#t, #f, 两个identifier的值如果都是#t或者#f,那么它们相等
</li>
<li>相同的符号(symbol), 比如
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">sym1</span> 'hello)
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">sym2</span> 'hello)
(eq? sym1 sym2)
</pre>
</div>
</li>
<li>'()
</li>
</ul>
</li>
<li>eqv? : 和 <code>eq?</code> 很类似, 只是它在一些 <code>eq?</code> 没有定义的地方也可以使用
</li>
<li>equal? : 只要内容相同,它就会返回 #t,可以认为它的检查比 <code>eq?</code> 宽松
</li>
<li>boolean? : 等价于 <code>(lambda (x) (or (eq? x #t) (eq? x #f)))</code>
</li>
<li>null? : 只作用于list
</li>
<li>pair? :
</li>
<li>number? :
</li>
<li>complex? :
</li>
<li>rational? :
</li>
<li>real? :
</li>
<li>integer? :
</li>
<li>char? :
</li>
<li>string? :
</li>
<li>vector? :
</li>
<li>symbol? :
</li>
<li>procedure? :
</li>
<li>bytevector? :
</li>
<li>hashtable? :
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2">list procedure</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
<code>list</code> 的语法定义:
</p>
<pre class="example">
List ::= '()
     ::= (Sexp . List)
</pre>
<ol class="org-ol">
<li>cons: (cons 'a 'b) ==&gt; (a . b),只能带两个参数
</li>
<li>cons* : (cons* 'a 'b 'c) ==&gt; (a b . c)    (cons* 'a 'b '(c)) ==&gt; (a b c)
</li>
<li>car: the firsts element of pair
</li>
<li>cdr:
</li>
<li>set-car! :有副作用, 会原地改变pair的值
</li>
<li>set-cdr! :
</li>
<li>car, caar, caaar&#x2026;etc: 连续执行n次(a的次数)car
(caar '((5)) ) ===&gt; 5
</li>
<li>cdr cddr cdddr &#x2026;etc : 连续执行n次(d的个数)cdr
</li>
<li>cadar : (car (cdr (car lst))) 记住按照顺序从左到右,最右边的先对list起作用
</li>
<li>list: 创建一个list eg: (list 1 2 3 4) ===&gt; '(1 2 3 4)
</li>
<li>length: list的长度
</li>
<li>append: 将一个list添加另一个list的后边,eg: (append '(1 2) '(3 4)) ===&gt; '(1 2 3 4)
</li>
<li>reverse: 将list倒转
</li>
<li>(list-ref list n): 第n个元素
</li>
<li>(list-tail list n) : 倒数第n个元素
</li>
<li>memq memv member memp 分别用eq? eqv? equal? 指定的procedure 来测试一个元
素是否属于list, 如果属于那么就返回包括该元素以及该元素后面的元素组成的
list, <code>(memq 'a '(b c a d e)) --&gt; (a d e)</code>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">memq</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x ls)
    (<span style="color: #F92672; font-weight: bold;">cond</span>
      ((null? ls) #f)
      ((eq? (car ls) x) ls)
      (<span style="color: #F92672; font-weight: bold;">else</span> (memq x (cdr ls))))))
</pre>
</div>
</li>
<li>remq (obj list) remv remove remp 删除list中的所有obj
</li>
<li>assq assv assoc assp 可以看做是关联数组((key1 . val1) (key2 . val2) &#x2026;)
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">assq</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x ls)
    (<span style="color: #F92672; font-weight: bold;">cond</span>
      ((null? ls) #f)
      ((eq? (caar ls) x) (car ls))
      (<span style="color: #F92672; font-weight: bold;">else</span> (assq x (cdr ls))))))
</pre>
</div>
<p>
返回第一个匹配的pair
</p>
</li>
<li>(filter procedure list): return a list of the elements of list for which
procedure returns true
</li>
<li>(partition procedure list): 返回两个list,第一个list包含所以使
       <code>procedure</code> 为#f的元素,第二个包含所有使 <code>procedure</code> 为 <code>#f</code> 的元素,
       <code>partition</code> 的返回值可以使用 <code>let-values</code> 来绑定或者使用
       <code>call-with-values</code> 来调用其它函数
</li>
<li>(find procedure list) : 返回第一个使procedure为#t的元素
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3">number procedure</h4>
<div class="outline-text-4" id="text-1-6-3">
<ol class="org-ol">
<li>zero? :
</li>
<li>positive? :
</li>
<li>negative? :
</li>
<li>even? :
</li>
<li>odd? : 奇数
</li>
<li>数学函数: max, min, floor, ceiling(向+无穷取整), truncate(向0取整),round(最接近的整数),
abs,gcd,expt(指数),三角系列函数(san,cos&#x2026;.)
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-6-4" class="outline-4">
<h4 id="sec-1-6-4">char</h4>
<div class="outline-text-4" id="text-1-6-4">
<p>
字符使用 <code>#\x</code> 来表示,比如 <code>a</code> 就是 <code>#\a</code>,
</p>
<ul class="org-ul">
<li>(char=? char1 char2 char3 &#x2026;)
</li>
<li>(char&lt;? char1 char2 char3 &#x2026;)
</li>
<li>(char&gt;? char1 char2 char3 &#x2026;)
</li>
<li>(char&lt;=? char1 char2 char3 &#x2026;)
</li>
<li>(char&gt;=? char1 char2 char3 &#x2026;)
</li>
<li>(char-ci=? char1 char2 char3 &#x2026;) 大小写敏感
</li>
<li>(char-ci&lt;? char1 char2 char3 &#x2026;)
</li>
<li>(char-ci&gt;? char1 char2 char3 &#x2026;)
</li>
<li>(char-ci&lt;=? char1 char2 char3 &#x2026;)
</li>
<li>(char-ci&gt;=? char1 char2 char3 &#x2026;)
</li>

<li>(char-upcase char) :大写,相对应的还有个char-downcase
</li>
<li>(char-&gt;integer char)
</li>
<li>(integer-&gt;char n)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-6-5" class="outline-4">
<h4 id="sec-1-6-5">string</h4>
<div class="outline-text-4" id="text-1-6-5">
<p>
双引号内的是字符串
</p>
<ul class="org-ul">
<li>(string=? char1 char2 char3 &#x2026;)
</li>
<li>(string&lt;? char1 char2 char3 &#x2026;)
</li>
<li>(string&gt;? char1 char2 char3 &#x2026;)
</li>
<li>(string&lt;=? char1 char2 char3 &#x2026;)
</li>
<li>(string&gt;=? char1 char2 char3 &#x2026;)
</li>
<li>(string-ci=? char1 char2 char3 &#x2026;) 大小写敏感
</li>
<li>(string-ci&lt;? char1 char2 char3 &#x2026;)
</li>
<li>(string-ci&gt;? char1 char2 char3 &#x2026;)
</li>
<li>(string-ci&lt;=? char1 char2 char3 &#x2026;)
</li>
<li>(string-ci&gt;=? char1 char2 char3 &#x2026;)
</li>
<li>(string char &#x2026;): 构建个包含指定的字符的字符串
</li>
<li>(make-string n), (make-string n char)
</li>
<li>(string-append string &#x2026;)
</li>
<li>(substring string start end)
</li>
<li>(string-upcase string)
</li>
<li>(string-&gt;list): 把string转换成包含char的list
</li>
<li>(char-&gt;list lst)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-6" class="outline-4">
<h4 id="sec-1-6-6">vector procedure</h4>
<div class="outline-text-4" id="text-1-6-6">
<p>
list访问时需要遍历,不够高效, vector可以像数组一样O(1)时间内访问
</p>
<ol class="org-ol">
<li>(vector obj &#x2026;)
</li>
<li>make-vector: (make-vector 5 'a) ===&gt;  #(a a a a a)
</li>
<li>vector-length: vector的长度
</li>
<li>(vector-ref vec n)
</li>
<li>(vector-set! vec n obj)
</li>
<li>(vector-fill vec obj): 所有的元素都替换为obj
</li>
<li>list-&gt;vector :
</li>
<li>vector-&gt;list :
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-6-7" class="outline-4">
<h4 id="sec-1-6-7">symbol procedure</h4>
<div class="outline-text-4" id="text-1-6-7">
<p>
每一个symbol在解释器内部都是指向同一个对象,所以用eq?来测试相同的symbol会返
回#t, 这也使得比较操作很高效
</p>
<ol class="org-ol">
<li>symbol=? :symbol是否相等,也可以用eq?来比较
</li>
<li>symbol-&gt;string:
</li>
<li>string-&gt;symbol:
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-6-8" class="outline-4">
<h4 id="sec-1-6-8">Hash Table</h4>
<div class="outline-text-4" id="text-1-6-8">
<ul class="org-ul">
<li>(make-eq-hashtable) : 使用eq?来比较两个key, 返回一个hashtable
</li>
<li>(make-eq-hashtable size)
</li>
<li>(make-eqv-hashtable) : 使用eqv?来比较两个key
</li>
<li>(make-eqv-hashtable size)
</li>
<li>(make-hashtable hash equiv?) : hash指定hash函数, equiv?指定比较两个key的
函数
</li>
<li>(make-hashtable hash equiv? size)
</li>

<li>(hashtable-set! hashtable key obj) :
</li>
<li>(hashtable-ref hashtable key default) :
</li>
<li>(hashtable-delete! hashtable key) :
</li>
<li>(hashtable-size hashtable) : hashtable的大小
</li>
<li>(hashtable-contains? hashtable key) :测试是否包含指定的key
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">macros</h3>
<div class="outline-text-3" id="text-1-7">
<p>
定义一个宏实际上就是把一个keyword与一系列的transformers绑定
</p>
</div>
<div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1">define-syntax</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
和define类似
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">let*</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
    [(_ () b1 b2 ...) (<span style="color: #F92672; font-weight: bold;">let</span> () b1 b2 ...)]
    [(_ ((i1 e1) (i2 e2) ...) b1 b2 ...)
     (<span style="color: #F92672; font-weight: bold;">let</span> ([i1 e1])
       (<span style="color: #F92672; font-weight: bold;">let*</span> ([i2 e2] ...) b1 b2 ...))]))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2">let-syntax与letrec-syntax</h4>
<div class="outline-text-4" id="text-1-7-2">
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">let</span> ([f (<span style="color: #F92672; font-weight: bold;">lambda</span> (x) (+ x 1))])
  (<span style="color: #F92672; font-weight: bold;">let-syntax</span> ([f (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
                    [(_ x) x])]
               [g (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
                    [(_ x) (f x)])])
    (list (f 1) (g 1)))) <span style="color: #75715E;">;; </span><span style="color: #75715E;">(1 2)</span>

(<span style="color: #F92672; font-weight: bold;">let</span> ([f (<span style="color: #F92672; font-weight: bold;">lambda</span> (x) (+ x 1))])
  (<span style="color: #F92672; font-weight: bold;">letrec-syntax</span> ([f (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
                       [(_ x) x])]
                  [g (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> ()
                       [(_ x) (f x)])])
    (list (f 1) (g 1)))) <span style="color: #75715E;">;; </span><span style="color: #75715E;">(1 1)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7-3" class="outline-4">
<h4 id="sec-1-7-3">syntax-rules</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
返回一个transformer, 基本语法:
<code>(syntax-rules (literal ...) (pattern template) ...)</code>
</p>

<ul class="org-ul">
<li>literal: 一些关键字, 出现在pattern会原样匹配
</li>
<li>pattern: 用于匹配输入的表达式的模式
</li>
<li>template: 输出
</li>
<li>下划线'<sub>'</sub>: 可以匹配任何结构,一般用来代表宏名
</li>
<li>&#x2026; : 代表前面的部分重复0次或者多次
</li>
</ul>
<p>
一个例子,这个例子实现一个类 <code>if</code> 的条件判断语句,他的形式是 <code>(my-if cond then
    exp1 else exp2)</code> 这看起来更可读性更好:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">my-if</span>
  (<span style="color: #F92672; font-weight: bold;">syntax-rules</span> (then else)
    [(_ condition then true-exp else false-exp)
     (<span style="color: #F92672; font-weight: bold;">if</span> condition true-exp false-exp)]))
</pre>
</div>
<p>
<code>then, else</code> 是关键字,所以它会原样的匹配输入
</p>
</div>
</div>

<div id="outline-container-sec-1-7-4" class="outline-4">
<h4 id="sec-1-7-4">syntax-case</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
比 <code>syntax-rules</code> 更具一般性,而且更通用, 使用syntax-case的一般形式是:
</p>
<pre class="example">
(define-syntax macro-name
   (lambda (x)
     (syntax-case x (other keywords go here if any)
       [
         (macro-name macro-arg1 macro-arg2)
         ;;Expansion of macro (one or multiple forms)
         ;;(syntax is a reserved word)
         (syntax (expansion of macro goes here))
       ]  ...
 )))
</pre>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">my-if</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
    (syntax-case x (then else)
      [(_ condition then true-exp else false-exp)
       (<span style="color: #F92672; font-weight: bold;">syntax</span> (<span style="color: #F92672; font-weight: bold;">if</span> condition true-exp false-exp))])))
<span style="color: #75715E;">;;</span><span style="color: #75715E;">Define a new macro</span>
(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">swap!</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
    <span style="color: #75715E;">;;</span><span style="color: #75715E;">we don't have any keywords this time</span>
    (syntax-case x ()
      (
       (swap! a b)
       (<span style="color: #F92672; font-weight: bold;">syntax</span>
        (<span style="color: #F92672; font-weight: bold;">let</span> ((c a))
          (set! a b)
          (set! b c)))
       )
      )))

(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">syntax-rules</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
    (syntax-case x ()
      [(_ (i ...) ((keyword . pattern) template) ...)
       #'(<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
           (syntax-case x (i ...)
             [(_ . pattern) #'template] ...))])))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7-5" class="outline-4">
<h4 id="sec-1-7-5">syntax</h4>
<div class="outline-text-4" id="text-1-7-5">
<p>
<code>(syntax template)</code> 的缩写为 <code>#'template</code>, syntax和quote很类似,只是它会将
template中的pattern variable替换掉, 并且会绑定上下文信息
</p>
</div>
</div>

<div id="outline-container-sec-1-7-6" class="outline-4">
<h4 id="sec-1-7-6">with-syntax</h4>
<div class="outline-text-4" id="text-1-7-6">
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define-syntax</span> <span style="color: #FD971F;">with-syntax</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
    (syntax-case x ()
      [(_ ((p e) ...) b1 b2 ...)
       #'(syntax-case (list e ...) ()
           [(p ...) (<span style="color: #F92672; font-weight: bold;">let</span> () b1 b2 ...)])])))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">input and output</h3>
<div class="outline-text-3" id="text-1-8">
<p>
scheme的输入输出用到一个叫做port的对象,port也是first class object, 默认解释器会打开2个port, 一个输入,一个输
出,分别会绑定到shell的输入输出,很多实现还会打开一个error port,这些和C语言很相似,用于IO的scheme procedure都
可以带一个可选的参数port, 如果不指定port, 那么就默认使用(current-input-port)以及(current-output-port)返回的
port,current-input-port, current-output-port返回的port可以通过with-input-from-file以及with-output-from-file
改变,这样就可以实现重定向的效果, 常用的IO procedure有:
</p>
<ol class="org-ol">
<li>(open-input-file filename)
</li>
<li>(close-input-port input-port)
</li>
<li>(call-with-input-file filename proc) : 打开filename并将得到的port传递给proc, 并且调用完成时会关闭port
</li>
<li>(with-input-from-file filename thunk) : 将current input port重新绑定到文件,这可以实现重定向
</li>
<li>(read input-port), (read) : 返回下一个object
</li>
<li>(read-char), (read-char input-port): next character
</li>
</ol>
<p>
some code example
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">call-with-input-file</span> <span style="color: #E6DB74;">"myfile.ss"</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (p)
    (<span style="color: #F92672; font-weight: bold;">let</span> <span style="color: #A6E22E;">f</span> ((x (read p)))
      (<span style="color: #F92672; font-weight: bold;">if</span> (eof-object? x)
          '()
          (cons x (f (read p)))))))

(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">read-word</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (p)
    (list-&gt;string
      (<span style="color: #F92672; font-weight: bold;">let</span> <span style="color: #A6E22E;">f</span> ()
        (<span style="color: #F92672; font-weight: bold;">let</span> ((c (peek-char p)))
          (<span style="color: #F92672; font-weight: bold;">cond</span>
            ((eof-object? c) '())
            ((char-alphabetic? c)
             (read-char p)
             (cons c (f)))
            (<span style="color: #F92672; font-weight: bold;">else</span> '())))))))
</pre>
</div>
<p>
output和input很相似
</p>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">递归思想</h3>
<div class="outline-text-3" id="text-1-9">
<p>
递归的思想要从逻辑上理解，在设计一个递归函数时，一开始就要明确该函数在逻辑上的作用(不要一开始就陷入编码细节
中)，然后分清该函数在逻辑上与
子问题的联系，并以此为 依据来进行函数体的设计, 特别需要注意检查结束条件,比如加法(0), 乘法(1), list('())就是
一些结束条件.
</p>

<p>
递归函数的设计要点：
</p>
<ol class="org-ol">
<li>要明确检查终止条件（null？ zero？）
</li>
<li>要明确与子问题的关系，弄清分类的情况（cond）
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">continuation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="continuation">continuation</span></span></h3>
<div class="outline-text-3" id="text-1-10">
<p>
这是一份关于continuation的<a href="http://www.cs.unm.edu/~williams/cs491/appcont.pdf">文档</a>, 将continuation讲的非常清楚,我简要的总结下我的理解:
先说几个概念与符号:
</p>
<ol class="org-ol">
<li>escape procedure: 它和普通的procedure是一样的,而且也有相同的行为,会返回相
同的值,唯一的不同的是这个函数它返回后就会替换调用栈,也就是说它会返回解释器
的最顶层或者解释器的REPL循环, 一个普通的procedure对应的escape procedure通
过在符号后添加<sup>来表示</sup>,比如 <code>k</code> 是一个普通的procedure, 那么它对应的escape
procedure就是 <code>k^</code> , 还有 <code>lambda</code> 是用来构建普通的procedure, 那么
<code>lambda^</code> 就是用来构建 <code>escape procedure</code>.(注意 <code>lambda^</code> 不是scheme的一
部分)下面举个例子:
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">k</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x y)
    (+ x y)))
</pre>
</div>
<p>
现在假设你使用 <code>(+ 3 (k 1 2))</code> 那么结果是6, 但是如果你使用 <code>(+ 3 (k^ 1
      2))</code> 它就会返回 <code>3</code>, 原因是 <code>k^</code> 与 <code>k</code> 虽然有相同的返回值,但是它会替换
调用栈,所以也就不会执行后面的 <code>(+ 3)</code>,而是直接返回 <code>k^</code> 的值
</p>
</li>
<li>continuation: 通俗点说 <code>continuation</code> 实际就是代表接下来要做的事或要进行的
操作, 也就是所谓的 <code>the rest of computation</code>, 所以当你要找一个函数来代表
某一点的continuation时,你只要弄清楚该点接下来要进行的操作,把这些操作封装
进一个函数就好 有了 <code>escape procedure</code> 的概念后,那么continuation可以看作
就是escape procedure.
</li>
<li>scheme的 call/cc
<div class="org-src-container">

<pre class="src src-scheme">(+ 2 (<span style="color: #F92672; font-weight: bold;">call/cc</span>
      (<span style="color: #F92672; font-weight: bold;">lambda</span> (k^)
        (* 5 (k^ 4)))))
</pre>
</div>
<p>
从上例可以看出 <code>call/cc</code> 的参数是一个lambda函数, 该函数也有一个参数(<code>k^</code>),
很显然 <code>k^</code> 是一个escape procedure, 当然 <code>k^</code> 也代表当前的
<code>continuation</code>,在上例中,它的定义可以大致认为是这样的:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(lambda^ (v)
         (+ 2 v))
</pre>
</div>
<p>
因为上例直接返回最顶层,所以可以直接这样
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">lambda</span> (v)
  (+ 2 v))
</pre>
</div>
<p>
所以当你使用 <code>(k^ 4)</code> 时, 它就返回 <code>6</code>, 同时替换调用栈,返回解释器的最上层,同
时从这个例子你也可以体会continuation的含义, continuation就是接下来要做的
事或者操作, 那么上例中 <code>call/cc</code> 之后接下来要做的事显然就是 (+ 2
ret-of-call/cc),也就是加2
</p>
</li>
</ol>
</div>
<div id="outline-container-sec-1-10-1" class="outline-4">
<h4 id="sec-1-10-1">call/cc</h4>
<div class="outline-text-4" id="text-1-10-1">
<p>
<code>call/cc</code> <sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>是 <code>call-with-current-continuation</code> 的缩写. 它的基本形式是这样的:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">call/cc</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (k)
    (* 5 (k 4))))
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">the result is 4</span>
</pre>
</div>
<p>
<code>call/cc</code> 的参数是一个函数, 这个函数有一个参数, 这个参数会绑定到当前的
<code>continuation</code>, 具体到这个例子就是: <code>k</code> 代表当前的continuation(也就是
<code>call/cc</code> 调用时的 <code>continuation</code>), 现在当你应用该 <code>continuation</code> 也就是使
用 <code>(k 4)</code> 时代码会立即从 <code>call/cc</code> 中返回, 并且返回值是 <code>4</code>, 注意它不会执行
前面的 (* 5), 所以不要以为是返回 20. 下面在举几个例子:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">call/cc</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (k)
    (* 5 4)))                           <span style="color: #75715E;">;</span><span style="color: #75715E;">return 20</span>

(+ 2
   (<span style="color: #F92672; font-weight: bold;">call/cc</span>
    (<span style="color: #F92672; font-weight: bold;">lambda</span> (k)
      (* 5 (k 4)))))                    <span style="color: #75715E;">;</span><span style="color: #75715E;">return 6</span>

(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">return</span> #f)
(+ 1 (<span style="color: #F92672; font-weight: bold;">call/cc</span>
      (<span style="color: #F92672; font-weight: bold;">lambda</span> (cont)
        (set! return cont)
        1)))                            <span style="color: #75715E;">;</span><span style="color: #75715E;">return 2</span>
(return 22)                             <span style="color: #75715E;">;</span><span style="color: #75715E;">return 23</span>
</pre>
</div>
<p>
再来看一个比较不好懂的例子
</p>
<div class="org-src-container">

<pre class="src src-scheme">(((<span style="color: #F92672; font-weight: bold;">call/cc</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> (k) k))
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x) x)) <span style="color: #E6DB74;">"HEY!"</span>)
</pre>
</div>
<p>
<code>(call/cc (lambda(k) k))</code> 返回当前的 <code>continuation</code>, 我假设该continuation为
<code>ct</code>, 那么 <code>(ct (lambda(x) x))</code> 就会返回 <code>(lambda(x) x)</code>, 然后 <code>((lambda(x)
    x) "HEY!")</code>, 自然就返回 "HEY!"
</p>
</div>
</div>

<div id="outline-container-sec-1-10-2" class="outline-4">
<h4 id="sec-1-10-2">应用</h4>
<div class="outline-text-4" id="text-1-10-2">
<ol class="org-ol">
<li>BREAK与RESUME, 通过BREAK来暂停, 通过RESUME来从暂停的位置启动.
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">BREAK</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (message)
    (<span style="color: #F92672; font-weight: bold;">call/cc</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> (k^)
               (set! RESUME K^)
               ((lambda^ (x) x) message)))))
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-10-3" class="outline-4">
<h4 id="sec-1-10-3">CPS</h4>
<div class="outline-text-4" id="text-1-10-3">
<p>
<a href="http://en.wikipedia.org/wiki/Continuation-passing_style">CPS</a>(continuation passing style). 核心就是每一个函数都会带一个额外的参数
(continuation),前面说了continuation代表的是the rest of computation, 因此这个
参数(continuation)代表了调用者需要对该函数的返回值进行的处理, 因此一个CPS方
式编写的函数最后都会使用函数的计算结果来调用你传递的那个continuation.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">停机问题</h3>
<div class="outline-text-3" id="text-1-11">
<div class="org-src-container">

<pre class="src src-scheme"><span class="linenr">1: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">last-try</span>
<span class="linenr">2: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> ( x )
<span class="linenr">3: </span>    (<span style="color: #F92672; font-weight: bold;">and</span> ( will-stop ? last-try)
<span class="linenr">4: </span>         ( eternity x ))))
</pre>
</div>
<p>
上述代码中:eternity会永远运行,比如:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">eternity</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
    (eternity x)))
</pre>
</div>
<p>
假设存在停机函数 <code>will-stop?</code>, <code>will-stop?</code> 可以测试出一个函数是否会停机.那么:
</p>
<ol class="org-ol">
<li>假设 <code>last-try</code> 会停机, 那么 <code>(will-stop? last-try)</code> 返回 #t, 因此也就会运行
   <code>(eternity x)</code>, 前面说了, eternity会永远运行, 所以 <code>last-try</code> 不会停机.
</li>
<li>假设 <code>last-try</code> 不停机, 那么 <code>(will-stop? last-try)</code> 返回 #f, 因此也就不会运
行 <code>(eternity x)</code>, 那么 <code>last-try</code> 很显然就会返回. 所以 <code>last-try</code> 会停机
</li>
</ol>
<p>
因此这就是个悖论.因此停机函数 will-stop?不存在
</p>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">some example code(the little schemer)</h3>
<div class="outline-text-3" id="text-1-12">
<div class="org-src-container">

<pre class="src src-scheme"><span class="linenr">  1: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">test if x is a atom</span>
<span class="linenr">  2: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">atom?</span>
<span class="linenr">  3: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
<span class="linenr">  4: </span>    (<span style="color: #F92672; font-weight: bold;">and</span> (not (pair? x))
<span class="linenr">  5: </span>         (not (null? x)))))
<span class="linenr">  6: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">add1</span>
<span class="linenr">  7: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span>(x)
<span class="linenr">  8: </span>    (+ x 1)))
<span class="linenr">  9: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">sub1</span>
<span class="linenr"> 10: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x)
<span class="linenr"> 11: </span>    (- x 1)))
<span class="linenr"> 12: </span>
<span class="linenr"> 13: </span>
<span class="linenr"> 14: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">test if x is the member of lat(list)</span>
<span class="linenr"> 15: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">member?</span>
<span class="linenr"> 16: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (x l)
<span class="linenr"> 17: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr"> 18: </span>      ((null? l) #f)
<span class="linenr"> 19: </span>      (<span style="color: #F92672; font-weight: bold;">else</span> (<span style="color: #F92672; font-weight: bold;">or</span> (eq? x (car l))
<span class="linenr"> 20: </span>                (member? x (cdr l)))))))
<span class="linenr"> 21: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">test if the list is composed only of atom</span>
<span class="linenr"> 22: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">lat?</span>
<span class="linenr"> 23: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (l)
<span class="linenr"> 24: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr"> 25: </span>     ((null? l) #t)
<span class="linenr"> 26: </span>     ((atom? (car l)) (lat? (cdr l)))
<span class="linenr"> 27: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> #f))))
<span class="linenr"> 28: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">(firsts '((1 2 3) (a b c) (e f g)))</span>
<span class="linenr"> 29: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">return (1 a e)</span>
<span class="linenr"> 30: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">firsts</span>
<span class="linenr"> 31: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (l)
<span class="linenr"> 32: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr"> 33: </span>     ((null? l) '())
<span class="linenr"> 34: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> (cons (car (car l))
<span class="linenr"> 35: </span>                (firsts (cdr l)))))))
<span class="linenr"> 36: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">&#23558;new&#25554;&#20837;lat&#20013;&#31532;&#19968;&#20010;old&#30340;&#21518;&#38754;</span>
<span class="linenr"> 37: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">insertR</span>
<span class="linenr"> 38: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (new old lat)
<span class="linenr"> 39: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr"> 40: </span>     ((null? lat) '())
<span class="linenr"> 41: </span>     ((eq? old (car lat))
<span class="linenr"> 42: </span>      (cons old
<span class="linenr"> 43: </span>            (cons new
<span class="linenr"> 44: </span>                  (cdr lat))))
<span class="linenr"> 45: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> (cons (car lat) (insertR new old (cdr lat)))))))
<span class="linenr"> 46: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">&#23558;new&#25554;&#20837;lat&#20013;&#31532;&#19968;&#20010;lat&#30340;&#21069;&#38754;</span>
<span class="linenr"> 47: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">insertL</span>
<span class="linenr"> 48: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (new old lat)
<span class="linenr"> 49: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr"> 50: </span>     ((null? lat) '())
<span class="linenr"> 51: </span>     ((eq? old (car lat)) (cons new lat))
<span class="linenr"> 52: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> (cons (car lat) (insertL new old (cdr lat)))))))
<span class="linenr"> 53: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">&#23558;new&#25554;&#20837;lat&#20013;&#31532;&#25152;&#26377;old&#30340;&#21518;&#38754;</span>
<span class="linenr"> 54: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">multiinsertR</span>
<span class="linenr"> 55: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (new old lat)
<span class="linenr"> 56: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr"> 57: </span>     ((null? lat) '())
<span class="linenr"> 58: </span>     ((eq? old (car lat))
<span class="linenr"> 59: </span>      (cons old
<span class="linenr"> 60: </span>            (cons new (multiinsertR new old (cdr lat)))))
<span class="linenr"> 61: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> (cons (car lat) (multiinsertR new old (cdr lat)))))))
<span class="linenr"> 62: </span>
<span class="linenr"> 63: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">&#20197;*&#32467;&#23614;&#24847;&#21619;&#30528;&#23545;&#27599;&#19968;&#20010;&#20803;&#32032;&#36882;&#24402;</span>
<span class="linenr"> 64: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">(rember* 'aa '(aa (aa bb) (aa bb cc)))</span>
<span class="linenr"> 65: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">return ((bb) (bb cc))</span>
<span class="linenr"> 66: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">rember*</span>
<span class="linenr"> 67: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (a l)
<span class="linenr"> 68: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr"> 69: </span>     ((null? l) '())
<span class="linenr"> 70: </span>     ((atom? (car l))
<span class="linenr"> 71: </span>      (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr"> 72: </span>       ((eq? a (car l)) (rember* a (cdr l)))
<span class="linenr"> 73: </span>       (<span style="color: #F92672; font-weight: bold;">else</span> (cons (car l) (rember* a (cdr l))))))
<span class="linenr"> 74: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> (cons (rember* a (car l))
<span class="linenr"> 75: </span>                 (rember* a (cdr l)))))))
<span class="linenr"> 76: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">insertR*</span>
<span class="linenr"> 77: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (new old lat)
<span class="linenr"> 78: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr"> 79: </span>     ((null? lat) '())
<span class="linenr"> 80: </span>     ((atom? (car lat))
<span class="linenr"> 81: </span>      (<span style="color: #F92672; font-weight: bold;">if</span> (eq? old (car lat))
<span class="linenr"> 82: </span>          (cons old (cons new
<span class="linenr"> 83: </span>                          (insertR* new old (cdr lat))))
<span class="linenr"> 84: </span>          (cons (car lat) (insertR*  new old (cdr lat)))))
<span class="linenr"> 85: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> (cons (insertR* new old (car lat))
<span class="linenr"> 86: </span>                 (insertR* new old (cdr lat)))))))
<span class="linenr"> 87: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">insertL*</span>
<span class="linenr"> 88: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (new old lat)
<span class="linenr"> 89: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr"> 90: </span>     ((null? lat) '())
<span class="linenr"> 91: </span>     ((atom? (car lat)) (<span style="color: #F92672; font-weight: bold;">if</span> (eq? old (car lat))
<span class="linenr"> 92: </span>                            (cons new (cons old
<span class="linenr"> 93: </span>                                            (insertL* new old (cdr
<span class="linenr"> 94: </span>                                                               lat))))
<span class="linenr"> 95: </span>                            (cons (car lat) (insertL* new old (cdr
<span class="linenr"> 96: </span>                                                               lat)))))
<span class="linenr"> 97: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> (cons (insertL* new old (car lat))
<span class="linenr"> 98: </span>                 (insertL* new old (cdr lat)))))))
<span class="linenr"> 99: </span>
<span class="linenr">100: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">lat&#20013;a&#20986;&#29616;&#30340;&#27425;&#25968;&#65292;&#22914;&#26524;lat&#30340;&#20803;&#32032;&#26102;list&#21017;&#36882;&#24402;</span>
<span class="linenr">101: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">occur*</span>
<span class="linenr">102: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (a lat)
<span class="linenr">103: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr">104: </span>     ((null? lat) 0)
<span class="linenr">105: </span>     ((atom? (car lat)) (<span style="color: #F92672; font-weight: bold;">if</span> (eq? a (car lat))
<span class="linenr">106: </span>                            (add1 (occur* a (cdr lat)))
<span class="linenr">107: </span>                            (occur* a (cdr lat))))
<span class="linenr">108: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> (+ (occur* a (car lat))
<span class="linenr">109: </span>              (occur* a  (cdr lat)))))))
<span class="linenr">110: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">eqlist</span>
<span class="linenr">111: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (l1 l2)
<span class="linenr">112: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr">113: </span>     ((<span style="color: #F92672; font-weight: bold;">and</span> (null? l1)
<span class="linenr">114: </span>           (null? l2)) #t)
<span class="linenr">115: </span>     ((<span style="color: #F92672; font-weight: bold;">or</span> (null? l1)
<span class="linenr">116: </span>          (null? l2)) #f)
<span class="linenr">117: </span>     ((<span style="color: #F92672; font-weight: bold;">and</span> (atom? (car l1))
<span class="linenr">118: </span>           (atom? (car l2)))
<span class="linenr">119: </span>           (<span style="color: #F92672; font-weight: bold;">if</span> (eq? (car l1)
<span class="linenr">120: </span>                    (car l2))
<span class="linenr">121: </span>               (eqlist (cdr l1) (cdr l2))
<span class="linenr">122: </span>               #f))
<span class="linenr">123: </span>     ((<span style="color: #F92672; font-weight: bold;">or</span> (atom? (car l1))
<span class="linenr">124: </span>          (atom? (car l2))) #f)
<span class="linenr">125: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> (<span style="color: #F92672; font-weight: bold;">and</span> (eqlist (car l1) (car l2))
<span class="linenr">126: </span>                (eqlist (cdr l1) (cdr l2)))))))
<span class="linenr">127: </span><span style="color: #75715E;">;;</span><span style="color: #75715E;">&#38598;&#21512;&#25805;&#20316;</span>
<span class="linenr">128: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">intersect</span>
<span class="linenr">129: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (set1 set2)
<span class="linenr">130: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr">131: </span>     ((null? set1) '())
<span class="linenr">132: </span>     ((member? (car set1) set2)
<span class="linenr">133: </span>      (cons (car set1)
<span class="linenr">134: </span>            (intersect (cdr set1) set2)))
<span class="linenr">135: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> (intersect (cdr set1) set2)))))
<span class="linenr">136: </span>
<span class="linenr">137: </span>(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">union</span>
<span class="linenr">138: </span>  (<span style="color: #F92672; font-weight: bold;">lambda</span> (set1 set2)
<span class="linenr">139: </span>    (<span style="color: #F92672; font-weight: bold;">cond</span>
<span class="linenr">140: </span>     ((null? set1) set2)
<span class="linenr">141: </span>     ((member? (car set1) set2)
<span class="linenr">142: </span>      (union (cdr set1) set2))
<span class="linenr">143: </span>     (<span style="color: #F92672; font-weight: bold;">else</span> (cons (car set1)
<span class="linenr">144: </span>     (union (cdr set1) set2))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13">racket&#xa0;&#xa0;&#xa0;<span class="tag"><span class="racket">racket</span></span></h3>
<div class="outline-text-3" id="text-1-13">
</div><div id="outline-container-sec-1-13-1" class="outline-4">
<h4 id="sec-1-13-1">struct(新的数据类型)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="struct">struct</span></span></h4>
<div class="outline-text-4" id="text-1-13-1">
<p>
语法形式: <code>(struct struct-id (field-id ...))</code>
</p>
<ul class="org-ul">
<li>struct-id : 是一个constructor, 可以用来构建一个该数据类型的实例
</li>
<li>struct-id? :一个predication,测试是否是该数据类型的实例
</li>
<li>struct-id-field-id: 从实例中获取 <code>field-id</code> 属性的值
</li>
</ul>
<p>
下面来看个例子:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(struct posn (x y))                     <span style="color: #75715E;">;</span><span style="color: #75715E;">&#23450;&#20041;&#19968;&#20010;posn&#31867;&#22411;</span>
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">pos1</span> (posn 1 2))                <span style="color: #75715E;">;</span><span style="color: #75715E;">struct-id: &#26500;&#24314;&#19968;&#20010;posn&#23454;&#20363;</span>
(posn? pos1)                            <span style="color: #75715E;">;</span><span style="color: #75715E;">struct-id?: &#26159;&#21542;&#20026;&#19968;&#20010;posn&#23545;&#35937;&#23454;&#20363;</span>
(posn-x pos1)                           <span style="color: #75715E;">;</span><span style="color: #75715E;">struct-id-field-id: &#33719;&#24471;x&#23646;&#24615;</span>
</pre>
</div>
</div>

<div id="outline-container-sec-1-13-1-1" class="outline-5">
<h5 id="sec-1-13-1-1">复制更新</h5>
<div class="outline-text-5" id="text-1-13-1-1">
<p>
根据已有对象更新其中的特定域然后返回新对象
</p>

<p>
语法形式: <code>(struct-copy struct-id struct-expr [field-id expr] ...)</code>
</p>
<blockquote>
<p>
Examples:
</p>

<p>
&gt; (define p1 (posn 1 2))
&gt; (define p2 (struct-copy posn p1 [x 3]))
&gt; (list (posn-x p2) (posn-y p2))
</p>

<p>
'(3 2)
&gt; (list (posn-x p1) (posn-x p2))
</p>

<p>
'(1 3)
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-1-13-1-2" class="outline-5">
<h5 id="sec-1-13-1-2">subtypes(类似于继承)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="subtypes">subtypes</span></span></h5>
<div class="outline-text-5" id="text-1-13-1-2">
<p>
语法形式: <code>(struct struct-id super-id (field-id ...))</code>
</p>
<div class="org-src-container">

<pre class="src src-scheme">(struct posn (x y))
(struct pos3d posn (z))
</pre>
</div>
<p>
那么pos3d就有 <code>(x y z)</code> 三个属性
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-13-2" class="outline-4">
<h4 id="sec-1-13-2">match(模式匹配)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="match">match</span></span></h4>
<div class="outline-text-4" id="text-1-13-2">
<p>
正则表达式只能用来匹配字符串,而 <code>match</code> 可以用来匹配任何的 <code>scheme value</code>,
它的语法形式如下:
</p>
<pre class="example">
(match target-expr
  [pattern expr ...+] ...)
</pre>
<p>
将 <code>target-expr</code> 与 pattern匹配, 如果匹配成功就执行后面的expr, 对pattern的
语法要做以下说明:
</p>
<ul class="org-ul">
<li>literal: 字面值直接用 <code>equal?</code> 测试是否相等
<div class="org-src-container">

<pre class="src src-scheme">(match 2
       [1 'one]
       [2 'two]
       [3 'three])
(match #f
       [#t 'yes]
       [#f 'no])
</pre>
</div>
</li>
<li>(list lvp &#x2026;): 会绑定对应的标识符,注意几个特殊符号,vector和list类似
<ul class="org-ul">
<li>&#x2026; 或 <span class="underline">_</span> :  代表0次或者多次
</li>
<li>..k 或 _<sub>k</sub> : 代表至少 <code>k</code> 此
</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(match '(1 + 2)
[(list a '+ b) (+ a b)])         <span style="color: #75715E;">;</span><span style="color: #75715E;">return 3</span>

(match '(1 2 3)
[(list 1 a ...) a])                 <span style="color: #75715E;">;</span><span style="color: #75715E;">return '(2 3)</span>

(match '(1 2 3 4)
[(list 1 a ..3) a]
[_ 'else])                          <span style="color: #75715E;">;</span><span style="color: #75715E;">return '(2 3 4)</span>
</pre>
</div>
<p>
上例中 <code>a b</code> 就被绑定为 1, 2
</p>
</li>
<li>(struct-id pat &#x2026;)或者(struct struct-id (pat &#x2026;)):匹配一个实例,并且绑定
一些变量
<div class="org-src-container">

<pre class="src src-scheme">(define-struct tree (val left right))
(match (make-tree 0 (make-tree 1 #f #f) #f)
       [(tree a (tree b  _ _) _) (list a b)])       <span style="color: #75715E;">;</span><span style="color: #75715E;">'(0 1)</span>
</pre>
</div>
</li>
<li>(struct struct-id _) :匹配任何 struct-id的实例
</li>
<li>(? expr pat &#x2026;): expr是一个predication, 只有它返回true的时候,才会匹配后
面的pat
<div class="org-src-container">

<pre class="src src-scheme">(match '(1 3 5)
       [(list (? odd?) ...) 'yes])
</pre>
</div>
</li>
<li>(quasiquote qp): unqote或unquote-splicing的部分会绑定为变量,其它部分会原样匹配
<div class="org-src-container">

<pre class="src src-scheme">(match '(1 + 2)
[`(,a + ,b) (+ a b)])
</pre>
</div>
<p>
a b都是unquote指定的部分,所以绑定为变量, 其它部分比如 +就原样匹配
</p>

<p>
关于quasiquote的一些说明:
</p>
<ul class="org-ul">
<li>quasiquote(`): 和quote(')类似, 只是表达式中的unquote会求值在返回,如果没
有unquote,那么它的行为就和 <code>quote</code> 一样,来看几个例子:
<code>(cons a b)等价于 `(,a ,b)</code>
</li>
<li>unquote(,): 指定的部分会先求职,在插入list中
<div class="org-src-container">

<pre class="src src-scheme">(quasiquote (1 2 (unquote (+ 1 2)) (unquote (- 5 1))))
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">equivalent</span>
`(1 2 ,(+ 1 2) ,(+ 5 1))                <span style="color: #75715E;">;</span><span style="color: #75715E;">'(1 2 3 6)</span>
</pre>
</div>
</li>

<li>unquote-splicing(,@): 和unquote的行为类似, 只是它所指定的表达式求值后必
须返回list,这个list中的元素会拆开然后插入原list中
<div class="org-src-container">

<pre class="src src-scheme">`(1 2 ,@(list (+ 1 2) (2 2)) 5)         <span style="color: #75715E;">;</span><span style="color: #75715E;">'(1 2 3 4 5)</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-13-3" class="outline-4">
<h4 id="sec-1-13-3">module</h4>
<div class="outline-text-4" id="text-1-13-3">
<p>
module的基本语法是:
</p>
<pre class="example">
(module name-id initial-module-path
  decl ...)
</pre>
<p>
例子:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(module cake racket
        (provide print-cake)

        (<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">print-cake</span> n)
          (show <span style="color: #E6DB74;">"   ~a   "</span> n #\.)
          (show <span style="color: #E6DB74;">" .-~a-. "</span> n #\|)
          (show <span style="color: #E6DB74;">" | ~a | "</span> n #\space)
          (show <span style="color: #E6DB74;">"---~a---"</span> n #\-))

        (<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">show</span> fmt n ch)
          (printf fmt (make-string n ch))
          (newline)))
</pre>
</div>
<ul class="org-ul">
<li>name-id: module的名字,上例是 <code>cake</code>
</li>
<li>initial-module-path: 初始化要导入的module, 上例是 <code>racket</code>
</li>
<li>provide : 可选的,也就是规定哪些东西是可以导出的,上例中 <code>print-cake</code> 会导
出,但是 <code>show</code> 是模块私有, 如果不提供 <code>provide</code> 那么所有的属性都是私有的,
所以一个模块必须指定 <code>provide</code> 才对导入者有意义
</li>
</ul>
<p>
声明一个模块并不会直接对模块的 <code>body</code> 部分求值,只有当使用 <code>require</code> 明确导
入该模块时才会求值
</p>
</div>
<div id="outline-container-sec-1-13-3-1" class="outline-5">
<h5 id="sec-1-13-3-1">submodule</h5>
<div class="outline-text-5" id="text-1-13-3-1">
<p>
一个文件只能包含一个顶层模块,这个模块可以通过 <code>module</code> 指定,也可以通
过 <code>lang lang-name</code> 来间接的指定, 那么在这个顶层模块中又可以定义子模块,比
如如下代码:
</p>
<div class="org-src-container">

<pre class="src src-scheme">#lang racket
(module zoo racket
        (provide tiger)
        (<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">tiger</span> <span style="color: #E6DB74;">"Tony"</span>))

(require 'zoo)

tiger
</pre>
</div>
<p>
上面的代码(假设文件名是park.rtk) <code>#lang racket</code> 指定了顶层模块, 而 <code>zoo</code> 是
一个子模块, 在顶层模块中可以直接通过 <code>(require 'zoo)</code> 来包含子模块, 如果是
在该文件以外, 你需要导入该文件的模块, 使用 <code>(require "park.rtk")</code> 只会导入
顶层模块, 使用submode语法比如 <code>(require (submod "park.rtk" zoo))</code> 就可以导
入子模块了
</p>
</div>
<div id="outline-container-sec-1-13-3-1-1" class="outline-6">
<h6 id="sec-1-13-3-1-1">module*                                                                   :module*:</h6>
<div class="outline-text-6" id="text-1-13-3-1-1">
<pre class="example">
(module* name-id initial-module-path-or-#f
decl ...)
</pre>
<p>
使用 <code>module</code> 声明的子模块可以可以被父模块导入, 但是子模块不能导入父模块,
而恰恰相反,使用 <code>module*</code> 声明的模块可以导入父模块, 可是父模块不能导入该子
模块, 如果指定 <code>#f</code> 作为默认导入模块, 那么父模块中的所有绑定在子模块中都可
见.
</p>
<div class="org-src-container">

<pre class="src src-scheme">#lang racket

(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">print-cake</span> n)
  (show <span style="color: #E6DB74;">"   ~a   "</span> n #\.)
  (show <span style="color: #E6DB74;">" .-~a-. "</span> n #\|)
  (show <span style="color: #E6DB74;">" | ~a | "</span> n #\space)
  (show <span style="color: #E6DB74;">"---~a---"</span> n #\-))

(<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">show</span> fmt n ch)
  (printf fmt (make-string n ch))
  (newline))

(module* main #f
         (print-cake 10))
</pre>
</div>
<p>
在上面的 <code>main</code> 这个submodule中, 顶层模块的所有绑定都可见, 注意当一个
submodule的名字为main时,有一个特殊的地方,也就是说当前的文件作为执行文件时
(racket file-name.rtk),即便你没有使用 <code>(require 'main)</code> 语句, 这个子模块仍
然会运行,和python的=ifmain= 很类似,所以这个main模块可以写一些本模块的测试
代码
</p>
</div>
</div>

<div id="outline-container-sec-1-13-3-1-2" class="outline-6">
<h6 id="sec-1-13-3-1-2">module+                                                                   :module+:</h6>
<div class="outline-text-6" id="text-1-13-3-1-2">
<pre class="example">
(module+ name-id
decl ...)
</pre>
<p>
等价于
</p>
<pre class="example">
(module* name-id #f
  decl ...)
</pre>
<p>
module+一般用来写 <code>test</code> 模块, 多个test模块会合并为一个test模块, 使用raco
test filename.rkt来运行测试代码
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-13-3-2" class="outline-5">
<h5 id="sec-1-13-3-2">lang</h5>
<div class="outline-text-5" id="text-1-13-3-2">
<p>
racket的源文件一般需要使用 <code>#lang lang-name</code> 这样的方式来指定语言,这个实际是一
个module的简写方式,比如 <code>#lang racket</code> 等价于:
</p>
<pre class="example">
(module name racket
  decl ...)
</pre>
<p>
所以 <code>#lang racket</code> 的意思就是定义一个module, 该模块的名字一般继承自文件名,
然后将racket作为初始模块导入.
</p>
</div>
</div>

<div id="outline-container-sec-1-13-3-3" class="outline-5">
<h5 id="sec-1-13-3-3">require</h5>
<div class="outline-text-5" id="text-1-13-3-3">
<ol class="org-ol">
<li>如果是文件那么应该使用这样的语法:
<div class="org-src-container">

<pre class="src src-scheme">(require <span style="color: #E6DB74;">"aa.rkt"</span>)
(require <span style="color: #E6DB74;">"../aa.rkt"</span>)
(require <span style="color: #E6DB74;">"../subdirectory/aa.rkt"</span>)
</pre>
</div>
<p>
以当前文件的路径为当前路径,使用和shell类似的路径表达方式来确定需要导入的模
块的名字,记住要带扩展名
</p>
</li>
<li>当前文件的子模块: <code>(require 'name)</code>
</li>
<li>标准模块: <code>(require racket)</code>
</li>
<li>子模块: <code>(require (submod "aa.rkt" submod-name))</code>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-13-3-4" class="outline-5">
<h5 id="sec-1-13-3-4">provide</h5>
<div class="outline-text-5" id="text-1-13-3-4">
<ul class="org-ul">
<li>导出所有: <code>(provide (all-defined-out))</code>
</li>
<li>只导出通过require引入的绑定: <code>(provide (all-from-out))</code>
</li>
<li>导出除指定的外所有的绑定: <code>(provide (except-out name ...))</code>
</li>
<li>重命名: <code>(provide (rename-out [orgn-id export-id]))</code>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://community.schemewiki.org/?call-with-current-continuation">http://community.schemewiki.org/?call-with-current-continuation</a>
</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<div id="disqus_comment">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
        var url = window.location.pathname;
        var disqus_identifier = url.substring(url.lastIndexOf('/')+1);
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'yuyang'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
<!-- begin footer -->
<div id="footer">
  <hr />
  <ul class="links">
    <li>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</li>
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a href="#">Back to Top</a></li>
  </ul>
</div>
<!-- end footer -->
</div>
</body>
</html>
