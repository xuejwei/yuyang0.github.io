<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>javascript笔记</title>
<!-- 2014-05-16 Fri 13:57 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Yu Yang" />
<meta  name="keywords" content="javascript syntax" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/>
<link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript" src="static/js/custom.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="site-title"><a href="/"> Yu Yang's Blog</a></h1>
        <div>
          <a href="###" id="site-nav-btn">菜单</a>
          <ul id="site-nav" class="vertical-nav mobi-hid">
            <li> <a href="/">Home</a></li>
            <li> <a href="/about.html">About</a></li>

            <li> <a href="/tags.html">Tags</a></li>

            <li> <a href="/rss.xml">RSS</a></li>
          </ul>

          <form id="site-search" method="get" action="https://google.com/search">
            <input type="hidden" name="q" value="site:yuyang.farbox.com" />
            <input type="text" name="q" placeholder="Search..." />
            <button class="btn-search" type="submit">Search</button>
          </form>
          <div style="clear:both;"> </div>
        </div>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">javascript笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">javascript文档</a></li>
<li><a href="#sec-2">基本类型</a>
<ul>
<li><a href="#sec-2-1">type的基本常识</a></li>
<li><a href="#sec-2-2">数字</a>
<ul>
<li><a href="#sec-2-2-1">日期</a></li>
</ul>
</li>
<li><a href="#sec-2-3">字符串</a>
<ul>
<li><a href="#sec-2-3-1">常见字符串处理函数</a></li>
</ul>
</li>
<li><a href="#sec-2-4">bool</a></li>
<li><a href="#sec-2-5">undefined与null</a></li>
</ul>
</li>
<li><a href="#sec-3">正则表达式</a>
<ul>
<li><a href="#sec-3-1">Create RegExp Object</a></li>
<li><a href="#sec-3-2">flags</a></li>
<li><a href="#sec-3-3">group</a></li>
<li><a href="#sec-3-4">RegExp method</a></li>
<li><a href="#sec-3-5">String method</a></li>
</ul>
</li>
<li><a href="#sec-4">Array</a>
<ul>
<li><a href="#sec-4-1">定义</a></li>
<li><a href="#sec-4-2">遍历数组</a></li>
<li><a href="#sec-4-3">数组方法</a></li>
</ul>
</li>
<li><a href="#sec-5">objects(对象)</a>
<ul>
<li><a href="#sec-5-1">基本解释</a></li>
<li><a href="#sec-5-2">原型</a></li>
<li><a href="#sec-5-3">json</a></li>
</ul>
</li>
<li><a href="#sec-6">control flow</a></li>
<li><a href="#sec-7">function</a>
<ul>
<li><a href="#sec-7-1">definition</a></li>
<li><a href="#sec-7-2">四种调用方式</a>
<ul>
<li><a href="#sec-7-2-1">method调用模式</a></li>
<li><a href="#sec-7-2-2">函数调用模式</a></li>
<li><a href="#sec-7-2-3">构造器调用模式(不推荐)</a></li>
<li><a href="#sec-7-2-4">apply调用模式</a></li>
</ul>
</li>
<li><a href="#sec-7-3">基本特性</a></li>
<li><a href="#sec-7-4">作用域</a></li>
<li><a href="#sec-7-5">给类型增加方法</a></li>
<li><a href="#sec-7-6">内置的函数</a></li>
</ul>
</li>
<li><a href="#sec-8">一些js技巧</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">javascript文档</h2>
<div class="outline-text-2" id="text-1">
<p>
几份不错的文档：<a href="http://bonsaiden.github.io/JavaScript-Garden/">JavaScript Garden</a> ,火狐开发者社区的js <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide?redirectlocale%3Den-US&redirectslug%3DJavaScript%252FGuide">tutorial</a>
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">基本类型</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">type的基本常识</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>数字, 字符串, boolean, null, undefined是js的基本类型，它们不是object, 其
它所有的值都是object, 数字, 字符串, bookean这三种类型有对应的包装对象
（wrapper object），当你访问字符串的方法时，实际上会自动的创建一个临时的
字符串包装对象，就像调用了new String(s),当调用完成后这个临时对象会被丢弃，
对于数字（Number），bool（Boolean）都是同样的原理
</li>
<li>数字，字符串，bool都是不可变的，而object是可变的.
</li>
<li>类型转换： 2 + '2a' = '22a'(操作符是+，则自动将数字转换为字符串，如果是其
它操作符则尝试将字符串转为整数，'22'转换为22, 但'2a'无法转换，这一点和
parseInt不同)
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">数字</h3>
<div class="outline-text-3" id="text-2-2">
<p>
不区分整数与浮点数
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">x</span> = 2;
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">x</span> = 2.22;
</pre>
</div>
<p>
有一些数学函数，用来处理数字：
</p>
<div class="org-src-container">

<pre class="src src-js">Math.pow(2,53)         <span style="color: #75715E;">//</span><span style="color: #75715E;">=&gt; 9007199254740992: 2 to the power 53</span>
Math.round(.6)         <span style="color: #75715E;">//</span><span style="color: #75715E;">=&gt; 1.0: round to the nearest integer</span>
Math.ceil(.6)         <span style="color: #75715E;">//</span><span style="color: #75715E;">=&gt; 1.0: round up to an integer</span>
Math.floor(.6)         <span style="color: #75715E;">//</span><span style="color: #75715E;">=&gt; 0.0: round down to an integer</span>
Math.abs(-5)         <span style="color: #75715E;">//</span><span style="color: #75715E;">=&gt; 5: absolute value</span>
Math.max(x,y,z)         <span style="color: #75715E;">//</span><span style="color: #75715E;">Return the largest argument</span>
Math.min(x,y,z)         <span style="color: #75715E;">//</span><span style="color: #75715E;">Return the smallest argument</span>
Math.random()         <span style="color: #75715E;">//</span><span style="color: #75715E;">Pseudo-random number x where 0 &lt;= x &lt; 1.0</span>
Math.PI         <span style="color: #75715E;">//</span><span style="color: #75715E;">&#960;: circumference of a circle / diameter</span>
Math.E         <span style="color: #75715E;">//</span><span style="color: #75715E;">e: The base of the natural logarithm</span>
Math.sqrt(3)         <span style="color: #75715E;">//</span><span style="color: #75715E;">The square root of 3</span>
Math.pow(3, 1/3)         <span style="color: #75715E;">//</span><span style="color: #75715E;">The cube root of 3</span>
Math.sin(0)         <span style="color: #75715E;">//</span><span style="color: #75715E;">Trigonometry: also Math.cos, Math.atan, etc.</span>
Math.log(10)         <span style="color: #75715E;">//</span><span style="color: #75715E;">Natural logarithm of 10</span>
Math.log(100)/Math.LN10         <span style="color: #75715E;">//</span><span style="color: #75715E;">Base 10 logarithm of 100</span>
Math.log(512)/Math.LN2         <span style="color: #75715E;">//</span><span style="color: #75715E;">Base 2 logarithm of 512</span>
Math.exp(3)         <span style="color: #75715E;">//</span><span style="color: #75715E;">Math.E cubed</span>
</pre>
</div>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">日期</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">then</span> = <span style="color: #F92672; font-weight: bold;">new</span> <span style="color: #66D9EF;">Date</span>(2010, 0, 1); <span style="color: #75715E;">// </span><span style="color: #75715E;">The 1st day of the 1st month of 2010</span>
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">later</span> = <span style="color: #F92672; font-weight: bold;">new</span> <span style="color: #66D9EF;">Date</span>(2010, 0, 1, <span style="color: #75715E;">// </span><span style="color: #75715E;">Same day, at 5:10:30pm, local time</span>
                     17, 10, 30);
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">now</span> = <span style="color: #F92672; font-weight: bold;">new</span> <span style="color: #66D9EF;">Date</span>();   <span style="color: #75715E;">//</span><span style="color: #75715E;">The current date and time</span>
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">elapsed</span> = now - then;  <span style="color: #75715E;">//</span><span style="color: #75715E;">Date subtraction: interval in milliseconds</span>

later.getFullYear() <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; 2010</span>
later.getMonth() <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; 0: zero-based months</span>
later.getDate() <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; 1: one-based days</span>
later.getDay() <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; 5: day of week. 0 is Sunday 5 is Friday.</span>
later.getHours() <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; 17: 5pm, local time</span>
later.getUTCHours() <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; hours in UTC time; depends on timezone</span>

later.toString()   <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "Fri Jan 01 2010 17:10:30 GMT-0800 (PST)"</span>
later.toUTCString()   <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "Sat, 02 Jan 2010 01:10:30 GMT"</span>
later.toLocaleDateString()   <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "01/01/2010"</span>
later.toLocaleTimeString()   <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "05:10:30 PM"</span>
later.toISOString()   <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "2010-01-02T01:10:30.000Z"; ES5 only</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">字符串</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">x</span> = <span style="color: #E6DB74;">'hello world'</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#23383;&#31526;&#20018;&#21333;&#21452;&#24341;&#21495;&#31561;&#20215;</span>
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">x</span> = <span style="color: #E6DB74;">"hello world"</span>;
</pre>
</div>
<p>
js的字符串实际上就是一串16位(2个字节)的值，因为js使用UTF-16来encoding unicode字符，所以如果一个uncode
point使用utf-16编码后有3个字节，那么使用length时该字符就是2个长度,js的字符串操作基本都是以16位的值为基础，
而不是以逻辑上的字符为基础的
</p>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">常见字符串处理函数</h4>
<div class="outline-text-4" id="text-2-3-1">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">s</span> = <span style="color: #E6DB74;">"hello, world"</span>     <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; 3: position of first "l" at or after 3</span>
s.length             <span style="color: #75715E;">// </span><span style="color: #75715E;">12, the length of string(this is property, not method)</span>

s.charAt(0)    <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "h": the first character.</span>
s.charAt(s.length-1)    <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "d": the last character.</span>
s.substring(1,4)    <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "ell": the 2nd, 3rd and 4th characters.</span>
s.slice(1,4)    <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "ell": same thing</span>
s.slice(-3)    <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "rld": last 3 characters</span>
s.indexOf(<span style="color: #E6DB74;">"l"</span>)    <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; 2: position of first letter 1.</span>
s.lastIndexOf(<span style="color: #E6DB74;">"l"</span>)    <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; 10: position of last letter 1.</span>
s.indexOf(<span style="color: #E6DB74;">"l"</span>, 3)    <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; 3: position of first "l" at or after 3</span>

s.split(<span style="color: #E6DB74;">", "</span>)         <span style="color: #75715E;">//  </span><span style="color: #75715E;">['hello', 'world']  an Array</span>
s.replace(<span style="color: #E6DB74;">"h"</span>, <span style="color: #E6DB74;">"H"</span>)   <span style="color: #75715E;">// </span><span style="color: #75715E;">Hello world, replace all instances</span>
s.toUpperCase()       <span style="color: #75715E;">// </span><span style="color: #75715E;">HELLO WORLD</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">bool</h3>
<div class="outline-text-3" id="text-2-4">
<p>
只能为true或者false,以下的值会自动转换为false：
</p>
<ol class="org-ol">
<li>false
</li>
<li>null
</li>
<li>undefined
</li>
<li>"" (empty string)
</li>
<li>NAN (not a number)
</li>
<li>0, -0
</li>
</ol>
<p>
除以上的值之外的所有的值，包括所有的对象都会自动转换为true, 可以通过 !! 来明
确的将一个值转换为bool
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">undefined与null</h3>
<div class="outline-text-3" id="text-2-5">
<p>
前者表示没有定义，后者表示变量的值为空，eg：var x;(x为undefined)
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">正则表达式</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Create RegExp Object</h3>
<div class="outline-text-3" id="text-3-1">
<p>
正则表示式是对象(RegExp对象), 有两种定义方法:
</p>
<ol class="org-ol">
<li><code>var pattern = /../;</code>, <b>无引号,不是字符串</b>.
</li>
<li><code>var pattern = new RegExp(...);</code>
</li>
</ol>
<p>
<b>正则表达式要写成一行, 因为正则表达式中空格是非常重要的</b>.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">flags</h3>
<div class="outline-text-3" id="text-3-2">
<p>
正则表达式可以指定标志, 比如 <code>/../g</code>, <code>/../i</code>.
</p>
<ol class="org-ol">
<li>g : 全局模式
</li>
<li>i : 忽略大小写模式
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">group</h3>
<div class="outline-text-3" id="text-3-3">
<p>
正则表达式可以分组. 分组有以下几类:
</p>
<ol class="org-ol">
<li>(..) : 这种分组是捕获型分组, 每一个捕获型分组都会有一个编号, 这种编号是从
1开始, 如果一个捕获型分组的编号是 <code>2</code>, 且最后的结果是 <code>result</code>, 那么该分
组匹配的文本就是 <code>result[2]</code>.
</li>
<li>(?: ..): 以 <code>?:</code> 开头, 非捕获型分组, 这种分组不会干扰捕获型分组的编号, 它
匹配的文本也不会出现在最终的结果中.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">RegExp method</h3>
<div class="outline-text-3" id="text-3-4">
<p>
这是regexp的方法
</p>
<ol class="org-ol">
<li><code>.exec(str)</code>: 返回一个数组, 数组的第一个元素是匹配的完整字符串,接下来的元素
是所有的捕获型分组, 注意全局模式对exec不起作用, 它只返回第一个匹配.
</li>
<li><code>.test(str)</code>: 如果str中包含能被匹配的字符串, 那么返回true, 否则返回false.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">String method</h3>
<div class="outline-text-3" id="text-3-5">
<p>
这是字符串的方法
</p>
<ol class="org-ol">
<li><code>.search(regexp)</code>: 返回匹配字符串的第一个字符在原字符串中的index, 无匹配
那么返回 -1, 全局模式对search无用.
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">s</span> = <span style="color: #E6DB74;">"JavaScript is fun"</span>;
s.search(<span style="color: #E6DB74;">/script/</span>i) <span style="color: #75715E;">// </span><span style="color: #75715E;">Returns 4</span>
s.search(<span style="color: #E6DB74;">/a(.)a/</span>)   <span style="color: #75715E;">// </span><span style="color: #75715E;">Returns 1</span>
</pre>
</div>
<p>
如果 <code>search</code> 的第一个参数不是正则表达式及而是一个字符串, 那么先将它转换
为正则表达式(将字符串传递给 <code>new RegExp(..)</code>)
</p>
</li>
<li><code>.replace(regexp, new_str)</code>: 返回替换后的新字符串, 如果regexp是全局模式,
那么会替换所有的匹配的字符串, 否则只替换第一处. 如果regexp中使用了分组,那
么可以在new_str中通过 $1, $2 &#x2026; $n 来引用第一个, 第二个一直到第n个分组匹
配的字符串.
<div class="org-src-container">

<pre class="src src-js">text.replace(<span style="color: #E6DB74;">/javascript/</span>i, <span style="color: #E6DB74;">"JavaScript"</span>);
<span style="color: #E6DB74;">"Doe, John"</span>.replace(<span style="color: #E6DB74;">/(</span><span style="color: #E6DB74; font-weight: bold;">\w</span><span style="color: #E6DB74;">+)</span><span style="color: #E6DB74; font-weight: bold;">\s</span><span style="color: #E6DB74;">*,</span><span style="color: #E6DB74; font-weight: bold;">\s</span><span style="color: #E6DB74;">*(</span><span style="color: #E6DB74; font-weight: bold;">\w</span><span style="color: #E6DB74;">+)/</span>, <span style="color: #E6DB74;">"$2 $1"</span>); <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "John Doe"</span>
</pre>
</div>
<p>
如果 <code>replace</code> 的第一个参数不是正则表达式及而是一个字符串, 那么直接使用字
符串字面值匹配
</p>
</li>
<li><code>.match(regexp)</code>: 返回一个数组, 如果regexp是全局模式, 那么数组元素就是所
有匹配的字符串, 如果没有使用全局模式, 那么数组的第一个元素是匹配的字符串,
接下来的元素是所有的捕获型分组, 具体可以看下面的例子.
<div class="org-src-container">

<pre class="src src-js"><span style="color: #75715E;">// </span><span style="color: #75715E;">regexp has 'g' attribute</span>
<span style="color: #E6DB74;">"1 plus 2 equals 3"</span>.match(<span style="color: #E6DB74;">/</span><span style="color: #E6DB74; font-weight: bold;">\d</span><span style="color: #E6DB74;">+/</span>g)  <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; ["1", "2", "3"]</span>

<span style="color: #75715E;">// </span><span style="color: #75715E;">regexp doesn't have 'g' attribute</span>
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">url</span> = <span style="color: #E6DB74;">/(</span><span style="color: #E6DB74; font-weight: bold;">\w</span><span style="color: #E6DB74;">+):</span><span style="color: #E6DB74; font-weight: bold;">\/\/</span><span style="color: #E6DB74;">([</span><span style="color: #E6DB74; font-weight: bold;">\w</span><span style="color: #E6DB74;">.]+)</span><span style="color: #E6DB74; font-weight: bold;">\/</span><span style="color: #E6DB74;">(</span><span style="color: #E6DB74; font-weight: bold;">\S</span><span style="color: #E6DB74;">*)/</span>;
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">text</span> = <span style="color: #E6DB74;">"Visit my home page at http://www.isp.com/~david"</span>;
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">result</span> = text.match(url);
<span style="color: #F92672; font-weight: bold;">if</span> (result != <span style="color: #AE81FF;">null</span>) {
  <span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">fullurl</span> = result[0];   <span style="color: #75715E;">// </span><span style="color: #75715E;">Contains "http://www.isp.com/~david"</span>
  <span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">protocol</span> = result[1];   <span style="color: #75715E;">// </span><span style="color: #75715E;">Contains "http"</span>
  <span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">host</span> = result[2];   <span style="color: #75715E;">// </span><span style="color: #75715E;">Contains "www.isp.com"</span>
  <span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">path</span> = result[3];   <span style="color: #75715E;">// </span><span style="color: #75715E;">Contains "~david"</span>
}
</pre>
</div>
<p>
如果 <code>match</code> 的参数不是正则表达式, 那么先转换为正则表达式.
</p>
</li>
<li><code>.split(regexp)</code>:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #E6DB74;">"123,456,789"</span>.split(<span style="color: #E6DB74;">","</span>);          <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; ['123', '456', '789']</span>
<span style="color: #E6DB74;">"1, 2, 3, 4, 5"</span>.split(<span style="color: #E6DB74;">/</span><span style="color: #E6DB74; font-weight: bold;">\s</span><span style="color: #E6DB74;">*,</span><span style="color: #E6DB74; font-weight: bold;">\s</span><span style="color: #E6DB74;">*/</span>); <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; ["1","2","3","4","5"]</span>
</pre>
</div>
<p>
不会将字符串字面值转换为正则表达式, 和 <code>replace</code> 类似.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Array</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">定义</h3>
<div class="outline-text-3" id="text-4-1">
<p>
定义数组可以使用两种方法: Array与[],但是推荐[],因为像 new Array(3)这样的代
码，它会返回一个空数组，可是却将这个数组的length设置为3,这是一个令人困惑的
特性
</p>
<div class="org-src-container">

<pre class="src src-js">[1, 2, 3]; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#32467;&#26524;: [1, 2, 3]</span>
<span style="color: #F92672; font-weight: bold;">new</span> <span style="color: #66D9EF;">Array</span>(1, 2, 3); <span style="color: #75715E;">// </span><span style="color: #75715E;">&#32467;&#26524;: [1, 2, 3]</span>

[3]; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#32467;&#26524;: [3]</span>
<span style="color: #F92672; font-weight: bold;">new</span> <span style="color: #66D9EF;">Array</span>(3); <span style="color: #75715E;">// </span><span style="color: #75715E;">&#32467;&#26524;: []</span>
<span style="color: #F92672; font-weight: bold;">new</span> <span style="color: #66D9EF;">Array</span>(<span style="color: #E6DB74;">'3'</span>) <span style="color: #75715E;">// </span><span style="color: #75715E;">&#32467;&#26524;: ['3']</span>

<span style="color: #75715E;">// </span><span style="color: #75715E;">&#35793;&#32773;&#27880;&#65306;&#22240;&#27492;&#19979;&#38754;&#30340;&#20195;&#30721;&#23558;&#20250;&#20351;&#20154;&#24456;&#36855;&#24785;</span>
<span style="color: #F92672; font-weight: bold;">new</span> <span style="color: #66D9EF;">Array</span>(3, 4, 5); <span style="color: #75715E;">// </span><span style="color: #75715E;">&#32467;&#26524;: [3, 4, 5]</span>
<span style="color: #F92672; font-weight: bold;">new</span> <span style="color: #66D9EF;">Array</span>(3) <span style="color: #75715E;">// </span><span style="color: #75715E;">&#32467;&#26524;: []&#65292;&#27492;&#25968;&#32452;&#38271;&#24230;&#20026; 3</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">遍历数组</h3>
<div class="outline-text-3" id="text-4-2">
<p>
不要使用for&#x2026;in, 而要使用如下代码:
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">list</span> = [1, 2, 3, 4, 5, ...... 100000000];
<span style="color: #F92672; font-weight: bold;">for</span>(<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">i</span> = 0, <span style="color: #FD971F;">l</span> = list.length; i &lt; l; i++) {
    console.log(list[i]);
}
</pre>
</div>
<p>
原因是for &#x2026; in会遍历整个原型链，效率不高
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">数组方法</h3>
<div class="outline-text-3" id="text-4-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">方法名</th>
<th scope="col" class="left">作用</th>
<th scope="col" class="left">返回值</th>
<th scope="col" class="left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">concat</td>
<td class="left">将数组连接起来</td>
<td class="left">新数组</td>
<td class="left">[1,2].concat(['a','b']); =&gt;[1,2,'a','b']</td>
</tr>

<tr>
<td class="left">join</td>
<td class="left">构造一个字符串</td>
<td class="left">字符串</td>
<td class="left">['a','b','c'].join(','); =&gt;'a,b,c'</td>
</tr>

<tr>
<td class="left">pop</td>
<td class="left">移除最后一个元素(原地改变)</td>
<td class="left">数组</td>
<td class="left">['a','b','c'].pop(); =&gt; 'c'</td>
</tr>

<tr>
<td class="left">push</td>
<td class="left">将元素插入数组尾部(原地改变)</td>
<td class="left">数组</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">reverse</td>
<td class="left">反转元素顺序(原地改变)</td>
<td class="left">数组</td>
<td class="left">[1,2,3].reverse() =&gt;[3,2,1]</td>
</tr>

<tr>
<td class="left">sort</td>
<td class="left">排序数组,默认比较字符串,可以传递比较函数(原地改变)</td>
<td class="left">数组</td>
<td class="left">[4,15,28].sort() =&gt;[15,28,4]</td>
</tr>

<tr>
<td class="left">slice</td>
<td class="left">选取数组的一段</td>
<td class="left">新数组</td>
<td class="left">['a','b','c'].slice(0,1) =&gt;['a']</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">objects(对象)</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">基本解释</h3>
<div class="outline-text-3" id="text-5-1">
<p>
object有点类似于关联数组, js中除了数字，字符串，bool，null，undefined之外都
是对象，数组，函数等等都是对象，对象有属性名，与属性值，数组的属性名是一些小
的连续的整数，这也是适合用数组的场景，其它的地方都应该用对象. object的定义如
下:
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">foo</span> = {
  name: <span style="color: #E6DB74;">'Kitten'</span>,
  age : 12
};

foo.name; <span style="color: #75715E;">// </span><span style="color: #75715E;">kitten</span>
foo[<span style="color: #E6DB74;">'name'</span>]; <span style="color: #75715E;">// </span><span style="color: #75715E;">kitten</span>

<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">get</span> = <span style="color: #E6DB74;">'name'</span>;
foo[get]; <span style="color: #75715E;">// </span><span style="color: #75715E;">kitten</span>

foo.1234; <span style="color: #75715E;">// </span><span style="color: #75715E;">SyntaxError</span>
foo[<span style="color: #E6DB74;">'1234'</span>]; <span style="color: #75715E;">// </span><span style="color: #75715E;">works</span>
</pre>
</div>
<p>
两种访问方法foo.name与foo['name']， 推荐前者(前提是name必须是合法的js标识
符)，和python的dict不同，{}中的name不要加引号，因为这里严格的说是object的
属性，而不是key
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">原型</h3>
<div class="outline-text-3" id="text-5-2">
<p>
对象对属性名的搜索有一定的规则, 一般情况下通过字面值构建的对象都会与
Object.prototype链接，也就是以Object.prototype为原型,所以如果一个属性在对象
中没有找到，那么她会自动到 Object.prototype中找，这样我们就可以给对象进行扩
充，比如给object.prototype中添加一个方法，那么每一个对象都可以调用, 同时也可
以给指定一个对象的原型,比如下面这个函数:
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">if</span> (<span style="color: #F92672; font-weight: bold;">typeof</span> Object.beget !== <span style="color: #E6DB74;">'function'</span>) {
  Object.beget = <span style="color: #F92672; font-weight: bold;">function</span>(<span style="color: #FD971F;">o</span>){
    <span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">F</span> = <span style="color: #F92672; font-weight: bold;">function</span>(){};
    F.<span style="color: #AE81FF;">prototype</span> = o;
    <span style="color: #F92672; font-weight: bold;">return</span> <span style="color: #F92672; font-weight: bold;">new</span> <span style="color: #66D9EF;">F</span>();
  };
}
</pre>
</div>
<p>
Object.beget 会返回一个新对象, 这个对象会以调用者指定的 o 为原型.
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">json</h3>
<div class="outline-text-3" id="text-5-3">
<ol class="org-ol">
<li>JSON.stringify: 将一个对象转换为字符串(serialize)
</li>
<li>JSON.parse: 将一个字符串转换为对象.
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">control flow</h2>
<div class="outline-text-2" id="text-6">
<p>
基本和C语言类似，while，for，do&#x2026;while，if&#x2026;else if&#x2026;else,switch&#x2026;case, break, continue都和C语言差不多，
break,continue和C语言有个区别就是后面可以跟一个label，break后面跟label那么它就不是终止最内层循环，而是终止
label指定的循环，eg：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">x</span> = 0;
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">z</span> = 0
labelCancelLoops: <span style="color: #F92672; font-weight: bold;">while</span> (<span style="color: #AE81FF;">true</span>) {
    console.log(<span style="color: #E6DB74;">"Outer loops: "</span> + x);
    x += 1;
    z = 1;
    <span style="color: #F92672; font-weight: bold;">while</span> (<span style="color: #AE81FF;">true</span>) {
        console.log(<span style="color: #E6DB74;">"Inner loops: "</span> + z);
        z += 1;
        <span style="color: #F92672; font-weight: bold;">if</span> (z === 10 &amp;&amp; x === 10) {
            <span style="color: #F92672; font-weight: bold;">break</span> labelCancelLoops;
        } <span style="color: #F92672; font-weight: bold;">else</span> <span style="color: #F92672; font-weight: bold;">if</span> (z === 10) {
            <span style="color: #F92672; font-weight: bold;">break</span>;
        }
    }
}
</pre>
</div>
<p>
break labelCancelLoops会终止最外层那个循环，continue后面跟label也和这类似，continue如果有label，那么它会终
止当前循环，而开始新一轮的label指定的循环
</p>
<ul class="org-ul">
<li>for (key in obj) : 对于C语言类似的数组，它会获得index，而对于关联数组则会获得key,
所以取值需要obj[key]，但是这种循环不建议使用，因为它实际是遍历原型链，所以你无法
保证顺序，也会做很多无用功
</li>
<li>for each (var item in obj): item会赋值为值，而不是key
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">function</h2>
<div class="outline-text-2" id="text-7">
<p>
函数也是对象, 每一个函数对象都会链接到 Function.prototype对象上, 也就是以
Function.prototype对象为原型,而Function.prototype又会链接到 Object.prototype
上. 同时每一个函数对象有一个prototype属性, 每一个通过new创建的对象都会链接到
这个属性 但是这个属性和函数对象本身没关系.
</p>
</div>
<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">definition</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">function</span> <span style="color: #A6E22E;">square</span>(<span style="color: #FD971F;">number</span>) {
  <span style="color: #F92672; font-weight: bold;">return</span> number * number;
}

<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">square</span> = <span style="color: #F92672; font-weight: bold;">function</span>(<span style="color: #FD971F;">number</span>){  <span style="color: #75715E;">// </span><span style="color: #75715E;">recommend</span>
  <span style="color: #F92672; font-weight: bold;">return</span> number * number;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">四种调用方式</h3>
<div class="outline-text-3" id="text-7-2">
</div><div id="outline-container-sec-7-2-1" class="outline-4">
<h4 id="sec-7-2-1">method调用模式</h4>
<div class="outline-text-4" id="text-7-2-1">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">myObject</span> = {
  value: 0,
  <span style="color: #A6E22E;">increment</span>: <span style="color: #F92672; font-weight: bold;">function</span>(<span style="color: #FD971F;">inc</span>){
    <span style="color: #AE81FF;">this</span>.value += <span style="color: #F92672; font-weight: bold;">typeof</span> inc === <span style="color: #E6DB74;">'number'</span> ? inc : 1;
  }
};
myObject.increment();           <span style="color: #75715E;">// </span><span style="color: #75715E;">myObject.value is 1</span>
myObject.increment(2);           <span style="color: #75715E;">// </span><span style="color: #75715E;">myObject.value is 2</span>
</pre>
</div>
<p>
这样调用时this会自动绑定到该对象, 在上例中就是 myObject.
</p>
</div>
</div>

<div id="outline-container-sec-7-2-2" class="outline-4">
<h4 id="sec-7-2-2">函数调用模式</h4>
<div class="outline-text-4" id="text-7-2-2">
<p>
普通的函数调用: 比如 <code>var sum = add(3, 4);</code>, 在这种调用方式中, 在函数内部
(add) this会被绑定到全局对象也就是 window对象
</p>
</div>
</div>

<div id="outline-container-sec-7-2-3" class="outline-4">
<h4 id="sec-7-2-3">构造器调用模式(不推荐)</h4>
<div class="outline-text-4" id="text-7-2-3">
<p>
实际是对OOP的一种不必要且蹩脚的模拟, 很晦涩难懂, 这种调用方式是使用 new 操
作符来调用. 这样调用时函数会有截然不同的行为.
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">Quo</span> = <span style="color: #F92672; font-weight: bold;">function</span>(<span style="color: #FD971F;">string</span>){
  <span style="color: #AE81FF;">this</span>.status = string;
};

Quo.<span style="color: #AE81FF;">prototype</span>.get_status = <span style="color: #F92672; font-weight: bold;">function</span>(){
  <span style="color: #F92672; font-weight: bold;">return</span> <span style="color: #AE81FF;">this</span>.status;
}
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">myQuo</span> = <span style="color: #F92672; font-weight: bold;">new</span> <span style="color: #66D9EF;">Quo</span>(<span style="color: #E6DB74;">"confused"</span>);
myQuo.get_status()              <span style="color: #75715E;">// </span><span style="color: #75715E;">the result is "confused"</span>
</pre>
</div>
<p>
我解释下上面的代码: 首先 Quo 是一个函数对象(构造器), 当对这个对象使用 new
操作符时会创建一个新的对象也就是myQuo, myQuo会以 Quo.prototype 为原型, 同时
在 Quo运行时, this会绑定到正在创建的那个对象也就是 myQuo.
</p>

<p>
一般来说构造器函数要以大写开头的名字命名, 同时在构造器内部不会明确的使用
return语句, 但是一旦明确的使用了return, 那么最后的结果就是return后的那个对
象了. 内置的Number, String, Regex, Date等等实际都是构造器函数.
</p>

<p>
在一般的 OOP 语言中是区分类与对象, 所以上述代码实际就是在模拟类, 可是js完全
不需要类, 所有这种模拟是不必要的
</p>
</div>
</div>

<div id="outline-container-sec-7-2-4" class="outline-4">
<h4 id="sec-7-2-4">apply调用模式</h4>
<div class="outline-text-4" id="text-7-2-4">
<p>
每一个函数都有一个apply方法, 该方法接受2个参数, 第一个参数是传递给 this的,
第二个参数是一个参数数组, 和lisp的apply有点类似
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">arr</span> = [1, 2];
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">sum</span> = add.apply(<span style="color: #AE81FF;">null</span>, arr); <span style="color: #75715E;">// </span><span style="color: #75715E;">sum is 3</span>
</pre>
</div>
<p>
在上例的这次add函数的apply调用中, 在add函数的内部 this 被绑定到 null.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">基本特性</h3>
<div class="outline-text-3" id="text-7-3">
<p>
js的函数是first class object，所以它可以作为参数传递，也可以作为返回值返回，
支持闭包与匿名函数，使用词法作用域, 它的很多地方借鉴了lisp的特性，下面是一些
示例代码：
</p>
<div class="org-src-container">

<pre class="src src-js"> <span style="color: #75715E;">// </span><span style="color: #75715E;">define a function if num==0</span>
 <span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">myFunc</span>;
 <span style="color: #F92672; font-weight: bold;">if</span> (num == 0){
   myFunc = <span style="color: #F92672; font-weight: bold;">function</span>(<span style="color: #FD971F;">theObject</span>) {
     theObject.make = <span style="color: #E6DB74;">"Toyota"</span>
   }
 }
<span style="color: #75715E;">// </span><span style="color: #75715E;">closure</span>
<span style="color: #75715E;">// </span><span style="color: #75715E;">The outer function defines a variable called "name"</span>
 <span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">pet</span> = <span style="color: #F92672; font-weight: bold;">function</span>(<span style="color: #FD971F;">name</span>) {
   <span style="color: #75715E;">// </span><span style="color: #75715E;">The inner function has access to the "name" variable of the outer function</span>
   <span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">getName</span> = <span style="color: #F92672; font-weight: bold;">function</span>() {
     <span style="color: #F92672; font-weight: bold;">return</span> name;
   }
   <span style="color: #75715E;">// </span><span style="color: #75715E;">Return the inner function, thereby exposing it to outer scopes</span>
   <span style="color: #F92672; font-weight: bold;">return</span> getName;
 },
     myPet = pet(<span style="color: #E6DB74;">"Vivie"</span>);
myPet();                            <span style="color: #75715E;">// </span><span style="color: #75715E;">Returns "Vivie"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4">作用域</h3>
<div class="outline-text-3" id="text-7-4">
<ol class="org-ol">
<li><code>var</code> 用来声明变量, 每一个变量都应该先声明, 后使用.
</li>
<li>如果省略了 <code>var</code> 那么会创建一个全局变量, 不要省略var是一个好的做法, 而且
特别要注意打字错误, jslint会提示没有用var声明的变量 <b>特别注意</b>.
</li>
<li>其它规则和lisp类似
</li>
</ol>
<div class="org-src-container">

<pre class="src src-js">scope = <span style="color: #E6DB74;">"global"</span>;         <span style="color: #75715E;">// </span><span style="color: #75715E;">Declare a global variable, even without var.</span>
<span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">scope2</span> = <span style="color: #E6DB74;">"global"</span>;    <span style="color: #75715E;">// </span><span style="color: #75715E;">Declare another global variable.</span>

<span style="color: #F92672; font-weight: bold;">function</span> <span style="color: #A6E22E;">checkscope2</span>() {
  scope = <span style="color: #E6DB74;">"local"</span>;          <span style="color: #75715E;">// </span><span style="color: #75715E;">Oops! We just changed the global variable.</span>
  <span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">scope2</span> = <span style="color: #E6DB74;">"local"</span>;     <span style="color: #75715E;">// </span><span style="color: #75715E;">Declare a local varible with the same name.</span>

  myscope = <span style="color: #E6DB74;">"local"</span>;        <span style="color: #75715E;">// </span><span style="color: #75715E;">This implicitly declares a new global variable.</span>
  <span style="color: #F92672; font-weight: bold;">return</span> [scope, myscope];  <span style="color: #75715E;">// </span><span style="color: #75715E;">Return two values.</span>
}
checkscope2()             <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; ["local", "local"]: has side effects!</span>
scope                     <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "local": global variable has changed.</span>
myscope                   <span style="color: #75715E;">// </span><span style="color: #75715E;">=&gt; "local": global namespace cluttered up.</span>
</pre>
</div>
<p>
js的作用域设计的比 python好, 因为变量需要声明, 所以就可以将创建绑定与修改变
量的值区分开, 也就不需要引入 <code>global</code> 这样的关键字, 也就不需要对全局作用域特
殊对待.
</p>
</div>
</div>

<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5">给类型增加方法</h3>
<div class="outline-text-3" id="text-7-5">
<div class="org-src-container">

<pre class="src src-js">Function.<span style="color: #AE81FF;">prototype</span>.method = <span style="color: #F92672; font-weight: bold;">function</span> (<span style="color: #FD971F;">name</span>, <span style="color: #FD971F;">func</span>){
  <span style="color: #F92672; font-weight: bold;">if</span> (!<span style="color: #AE81FF;">this</span>.<span style="color: #AE81FF;">prototype</span>[name]) {
    <span style="color: #AE81FF;">this</span>.<span style="color: #AE81FF;">prototype</span>[name] = func;
  }
};
</pre>
</div>
<p>
给 String 增加 trim方法:
</p>
<div class="org-src-container">

<pre class="src src-js">String.method(<span style="color: #E6DB74;">'trim'</span>, <span style="color: #F92672; font-weight: bold;">function</span>(){
  <span style="color: #AE81FF;">this</span>.replace(<span style="color: #E6DB74;">/^</span><span style="color: #E6DB74; font-weight: bold;">\s</span><span style="color: #E6DB74;">+|</span><span style="color: #E6DB74; font-weight: bold;">\s</span><span style="color: #E6DB74;">+$/</span>g, <span style="color: #E6DB74;">''</span>);
});
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6">内置的函数</h3>
<div class="outline-text-3" id="text-7-6">
<ol class="org-ol">
<li>eval:运行js代码, 不推荐使用.
</li>
<li>isFinite: test a number if it is a finite number
</li>
<li>isNaN: is not a number
</li>
<li>parseInt,parseFloat: 将字符串转换为整数或者浮点数
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">一些js技巧</h2>
<div class="outline-text-2" id="text-8">
<ol class="org-ol">
<li>在每个应用中仅创建一个全局的对象,然后将所有的函数都变成这个全局对象的属性,
减少与其它应用程序或者类库产生相互影响的可能性.
</li>
<li>每个语句结束要插入分号,不要依赖js解释器的自动插入分号功能.
</li>
<li>不要使用==, != 而应该一直使用===与!== .
</li>
<li>if, while这样的语句一定要使用 {}, 即便只有一条语句.
</li>
<li>不要使用 <code>++</code> 与 <code>--</code> , 因为这让程序不易理解.
</li>
<li>不要依赖 switch 中 case 的贯穿, 也就是说, 每一个case都要一个break.
</li>
<li>尽量不要使用位操作(&amp;, !, ^),因为js没有整数类型, 它只有双精度浮点数
</li>
<li>函数的声明应该用:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">var</span> <span style="color: #FD971F;">foo</span> = <span style="color: #F92672; font-weight: bold;">function</span>(){...};
</pre>
</div>
<p>
而不是
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #F92672; font-weight: bold;">function</span> <span style="color: #A6E22E;">foo</span>(){...}
</pre>
</div>
<p>
因为第二种方式会使得不管函数定义在什么地方,它都会被移到被定义时的作用域的
最开头, 这违背了函数先定义后使用规则(scheme, python都遵循该规则).
</p>
</li>
<li>尽量不要使用 new Object, new Array, 应该使用 {} [] 来代替
</li>
<li>不要使用new运算符.
</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_comment">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
        var url = window.location.pathname;
        var disqus_identifier = url.substring(url.lastIndexOf('/')+1);
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'yuyang'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
<!-- begin footer -->
<div id="footer">
  <ul class="links vertical-nav">
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a class="back-to-top" href="#">Back to Top</a></li>
  </ul>
  <span>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</span>
  <a href="#" class="back-to-top" id="fixed-back-to-top" ></a>
</div>
<!-- end footer -->
</div>
</body>
</html>
