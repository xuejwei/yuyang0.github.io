<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Dpark</title>
<!-- 2015-08-27 Thu 10:16 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Yu Yang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/>
<link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="site-title"><a href="/"> 编码者言 </a></h1>
        <div>
          <a href="###" id="site-nav-btn">菜单</a>
          <ul id="site-nav" class="vertical-nav mobi-hid">
            <li> <a href="/">Home</a></li>
            <li> <a href="/about.html">About</a></li>

            <li> <a href="/tags.html">Tags</a></li>

            <li> <a href="/atom.xml">RSS</a></li>
          </ul>

          <form id="site-search" method="get" action="https://google.com/search">
            <input type="hidden" name="q" value="site:yuyang0.github.io" />
            <input type="text" name="q" placeholder="Search..." />
            <button class="btn-search" type="submit">Search</button>
          </form>
          <div style="clear:both;"> </div>
        </div>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">Dpark</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Big Picture</a></li>
<li><a href="#sec-2">RDD</a>
<ul>
<li><a href="#sec-2-1">Transformations</a></li>
<li><a href="#sec-2-2">Actions</a></li>
<li><a href="#sec-2-3">Dependency</a>
<ul>
<li><a href="#sec-2-3-1">Narrow Dependency</a></li>
<li><a href="#sec-2-3-2">Wide Dependency</a></li>
</ul>
</li>
<li><a href="#sec-2-4">Partitioner</a></li>
<li><a href="#sec-2-5">Aggregator</a></li>
<li><a href="#sec-2-6">Merger</a></li>
<li><a href="#sec-2-7">rdd</a></li>
</ul>
</li>
<li><a href="#sec-3">Context(context.py)</a>
<ul>
<li><a href="#sec-3-1">DparkContext</a></li>
<li><a href="#sec-3-2">命令行参数</a></li>
</ul>
</li>
<li><a href="#sec-4">cache(cache.py)</a>
<ul>
<li><a href="#sec-4-1">Cache</a></li>
<li><a href="#sec-4-2">DiskCache</a></li>
<li><a href="#sec-4-3">CacheTracker</a></li>
</ul>
</li>
<li><a href="#sec-5">Tracker(tracker.py)</a>
<ul>
<li><a href="#sec-5-1">消息类型</a></li>
</ul>
</li>
<li><a href="#sec-6">shuffle</a></li>
<li><a href="#sec-7">env(env.py)</a></li>
<li><a href="#sec-8">conf(conf.py)</a></li>
<li><a href="#sec-9">调度系统</a>
<ul>
<li><a href="#sec-9-1">基本概念</a></li>
<li><a href="#sec-9-2">DAGScheduler</a></li>
<li><a href="#sec-9-3">Task(task.py)</a></li>
</ul>
</li>
<li><a href="#sec-10">Executor(executor.py)</a>
<ul>
<li><a href="#sec-10-1">web server</a></li>
<li><a href="#sec-10-2">进程池</a></li>
<li><a href="#sec-10-3">run_task</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Big Picture</h2>
<div class="outline-text-2" id="text-1">
<p>
dpark的计算过程是这样的：
</p>
<ol class="org-ol">
<li>先创建第一个RDD，这是通过Context类的textFile，CSVFile这类调用实现的，
</li>
<li>接着在这个rdd调用一系列的transformation.
</li>
<li>最后调用一个operation，调用operation才会触发真正的运算, 因为这类操作运算一般
都会调用Context对象的runJob方法，
</li>
<li>Context的runJob方法会执行如下动作：
<ul class="org-ul">
<li>调用Context的start方法，该方法会初始化env，scheduler, 
</li>
<li>调用scheduler的runJob方法，该方法就会根据你指定的运行模式(local,process,
mesos)来运行。
</li>
<li>将scheduler的runJob的返回值(一般rdd的一个分区对应一个值) yield 出来。
</li>
</ul>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">RDD</h2>
<div class="outline-text-2" id="text-2">
<p>
RDD可以理解为一个集合. 
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Transformations</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>groupBy: 先通过map得到key，然后reduceByKey
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">self</span>.<span style="color: #DCDCCC; font-weight: bold;">map</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> x: <span style="color: #BFEBBF;">(</span>f<span style="color: #D0BF8F;">(</span>x<span style="color: #D0BF8F;">)</span>, x<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>.reduceByKey<span style="color: #DCDCCC;">()</span>
</pre>
</div>
</li>
<li>pipe: 将分区丢给一个shell命令运行, 将结果返回
</li>
<li></li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Actions</h3>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Dependency</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Narrow Dependency</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
父RDD的一个分区最多只被子RDD的一个分区所依赖，为了实现方便，他又分为两种类型：
</p>
<ol class="org-ol">
<li>一对一：子RDD的一个分区只依赖父RDD的一个分区
</li>
<li>一对多：也就是说子RDD的一个分区依赖父RDD的多个分区
</li>
</ol>

<p>
<b>实现</b>: 都有一个getParents方法,给定子rdd的一个分区编号获得依赖的父分区编号.注意
 返回的是一个列表.
</p>
<ol class="org-ol">
<li>OneToOneDependency: 子rdd与父rdd有相同的分区编号(pid)
</li>
<li>OneToRangeDependency: 子rdd一个分区对应于父rdd的多个分区,注意splitSize指的是
子rdd一个分区对应父rdd的分区的个数,不是指分区的元素个数,同时length也是指父rdd
分区的个数.
</li>
<li>CartesianDependency: 笛卡尔积，通过cartesian(rdd1, rdd2)运算后得到的rdd它的分
区数是rdd1的分区数乘以rdd2的分区数，所以结果rdd中的一个分区实际只依赖rdd1中的
一个分区，以及rdd2中的一个分区。
</li>
<li>RangeDependency: 比如子rdd的第10~20分区依赖父rdd的1~11分区,也就是说分区是一一
对应的,只是有多个分区,其实我们可以把这种依赖拆成length个OneToOneDependency
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Wide Dependency</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
父RDD的一个分区被子RDD的多个分区所依赖，这种依赖意味着为了计算子RDD的一个分区，
我们必须进行shuffle操作。shuffle对性能的影响很大。
</p>
<ol class="org-ol">
<li>shuffleDependency: 一个id, 父rdd, aggregator, partitioner
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Partitioner</h3>
<div class="outline-text-3" id="text-2-4">
<p>
返回分区的相关的信息 <b>接口</b>:
</p>
<ol class="org-ol">
<li>numPartitions: 获得分区数量
</li>
<li>getPartition: 获得分区编号
</li>
</ol>
<p>
分区有两种类型：
</p>
<ol class="org-ol">
<li>HashPartitioner：也就是说rdd中元素是根据hash值来分区的, 初始化时，你需要传入
分区的个数, 要获得分区编号时实际是将hash值与分区个数取模
</li>
<li>RangePartitioner：rdd中的元素都是使用排序来分区，所以可以使用二分法来确定某个
给定元素所在的分区, 在初始化时你必须传入标示分区开始和结尾的key所组成的list,
在获得分区编号时是使用二分查找.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Aggregator</h3>
<div class="outline-text-3" id="text-2-5">
<p>
聚合器，实际上指定了如何把多个值聚合起来, 实现实际上包含三个函数：
</p>
<ol class="org-ol">
<li>createCombiner： 如何根据一个值来创建一个combiner
</li>
<li>mergeValue： 如何将一个值添加到一个combiner中
</li>
<li>mergeCombiner： 将两个combiner合并
</li>
</ol>
<p>
combiner可以是整数(AddAggregator),列表(MergeAggregator), 可以是
set(UniqAggregator), 还可以是其它的容器类型,这个东西主要是用在shuffle中,当产
生值之后如何把它们合并到一起, 不同的需求需要不同的合并方式.
</p>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Merger</h3>
<div class="outline-text-3" id="text-2-6">
<p>
合并K/V键值对
</p>
<ol class="org-ol">
<li>Merger: 内部有一个字典属性(combined)以及一个mergeCombiner(用来合并相同键
对应的值),有一个merge方法,调用该方法会将你传入的字典合并到内部的字典属性
上,如果一个键上有多个值,那么调用mergeCombiner来合并
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">rdd</h3>
<div class="outline-text-3" id="text-2-7">
<p>
这个类是用来描述rdd的，它有很多子类, 这些类都有以下几个比较重要的属性和方法:
</p>
<ol class="org-ol">
<li>iterator: 最终实际上返回的是compute的结果，只是会先到snapshot或者cache中找。
</li>
<li>compute：根据rdd的类型确定如何根据父rdd来计算本rdd。一般是返回一个生产器或者
可迭代对象。
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Context(context.py)</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">DparkContext</h3>
<div class="outline-text-3" id="text-3-1">
<p>
DparkContext类中中有几个非常重要的方法:
</p>
<ol class="org-ol">
<li>init: 实际根据运行模式插创建scheduler属性
</li>
<li>start: 调用init方法,接着调用env的start方法
</li>
<li>runJob: 调用start方法, 接着调用scheduler属性的runJob方法,这个方法实际就会进行实际的运行过程. 这个方法一般会被RDD的operation触发.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">命令行参数</h3>
<div class="outline-text-3" id="text-3-2">
<p>
add_default_options, parse_options都是用来获取命令行参数的。命令行参数有以下几个：
</p>
<ul class="org-ul">
<li>master: 运行模式，默认local
</li>
<li>self： 是不是将本脚本作为executor，默认为None
</li>
<li>cpus：一个task占用的cpu核数, 默认为1
</li>
<li>mem： 一个task占用的内存，默认为None
</li>
<li>snapshot_dir: 存储rdd的snapshot的dir，默认为""
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">cache(cache.py)</h2>
<div class="outline-text-2" id="text-4">
<p>
缓存相关
</p>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Cache</h3>
<div class="outline-text-3" id="text-4-1">
<p>
实际是对字典的一层包装, 提供get, put, clear三个方法.
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">DiskCache</h3>
<div class="outline-text-3" id="text-4-2">
<p>
文件cache，将rdd的每一个分区保存为一个文件$(WORK_DIR)/cache/rddId_splitId.pid
</p>
<ul class="org-ul">
<li>get
</li>
<li>put
</li>
<li>save
</li>
<li>load
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">CacheTracker</h3>
<div class="outline-text-3" id="text-4-3">
<p>
它内部有一个DiskCache对象，也就是用来缓存rdd的分区计算结果的。每一个split缓存在
哪个host都是会保存到TrackerServer上的。{“cache:rddIdx-splitIdx": hostname}
</p>
<ul class="org-ul">
<li>getOrCompute: 缓存上有，那么就返回缓存上的结果，如果没有那就是用compute来计算。
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Tracker(tracker.py)</h2>
<div class="outline-text-2" id="text-5">
<p>
实际上是使用zmq实现的一个服务器与客户端, 这个服务器会跟踪整个系统的信息，比如每
个rdd的split的缓存节点的url，shuffle的相关信息等等。像CacheTracker，
MapOutputTracker都需要和TrackServer进行交互。
</p>
<ol class="org-ol">
<li>TrackerServer: 服务器,内部有一个locs字典, 该字典的value都是列表,这个server
会接受客户端的消息,然后根据消息类型向locs字典添加,删除,修改等操作或者终止
服务器.
</li>
<li>TrackerClient: 客户端实现, 主要是一个call方法可以向服务端发送消息
</li>
</ol>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">消息类型</h3>
<div class="outline-text-3" id="text-5-1">
<ol class="org-ol">
<li>SetValueMessage: 设置key所对应的值,注意值必须为列表
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #DCDCCC; font-weight: bold;">isinstance</span><span style="color: #DCDCCC;">(</span>value, <span style="color: #DCDCCC; font-weight: bold;">list</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #DFAF8F;">value</span> = <span style="color: #DCDCCC;">[</span>value<span style="color: #DCDCCC;">]</span>

<span style="color: #F0DFAF; font-weight: bold;">self</span>.locs<span style="color: #DCDCCC;">[</span>key<span style="color: #DCDCCC;">]</span> = value
</pre>
</div>
</li>
<li>AddItemMessage: 向key所对应的值列表中添加一个值
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">if</span> key <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.locs:
    <span style="color: #F0DFAF; font-weight: bold;">self</span>.locs<span style="color: #DCDCCC;">[</span>key<span style="color: #DCDCCC;">]</span> = <span style="color: #DCDCCC;">[]</span>

<span style="color: #F0DFAF; font-weight: bold;">self</span>.locs<span style="color: #DCDCCC;">[</span>key<span style="color: #DCDCCC;">]</span>.append<span style="color: #DCDCCC;">(</span>item<span style="color: #DCDCCC;">)</span>
</pre>
</div>
</li>
<li>RemoveItemMessage: 从key所对应的值列表中移除item
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">if</span> item <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.locs<span style="color: #DCDCCC;">[</span>key<span style="color: #DCDCCC;">]</span>:
    <span style="color: #F0DFAF; font-weight: bold;">self</span>.locs<span style="color: #DCDCCC;">[</span>key<span style="color: #DCDCCC;">]</span>.remove<span style="color: #DCDCCC;">(</span>item<span style="color: #DCDCCC;">)</span>
</pre>
</div>
</li>
<li>GetValueMessage: 返回和key绑定的值列表
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">self</span>.locs.get<span style="color: #DCDCCC;">(</span>key, <span style="color: #BFEBBF;">[]</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</li>
<li>StopTrackerMessage: 通知服务器退出.
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">shuffle</h2>
<div class="outline-text-2" id="text-6">
<p>
shuffle实际就是将分布在不同split中的元素进行重组，所以为了计算当前rdd的一个split，
它要拿到父rdd的所有split, 然后对父rdd所有元素根据partitioner来确定它是否属于的这
个split。
</p>
<ol class="org-ol">
<li>MapOutputTracker: 用来跟踪shuffleId与该shuffle的输出的，内部实际上是一个
TrackerClient实例，它会和TrackerServer通信,它有两个方法:
<ul class="org-ul">
<li>registerMapOutputs: 将shuffleId与locs绑定.
</li>
<li>getServerUris:　根据shuffleID得到所有的locs
</li>
</ul>
</li>
<li>SimpleShuffleFetcher:　实际就是通过urlopen来获得数据块
<ul class="org-ul">
<li>fetch_one: 根据uri来下载数据,数据的格式是:
<ul class="org-ul">
<li>第一个字节:　标志, m 或者p, 指示到底是用marshal还是cPickle序列化数据
</li>
<li>2~4个字节:　整个长度, 主要是用来校验u数据是否有错误
</li>
<li>5~结尾: 数据,需要反序列化.
</li>
</ul>
<p>
该方法返回反序列化后的数据
</p>
</li>
<li>fetch:使用fetch_one获得数据,然后在数据上调用func,funcMerger实例的merge方
法,这个方法会将数据全部合并到Merger实例内部的一个字典属性上
</li>
</ul>
</li>
<li>ParallelShuffleFetcher:和SimpleShuffleFetcher的区别就是会使用多线程下载数据
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">env(env.py)</h2>
<div class="outline-text-2" id="text-7">
<p>
实际就是DparkEnv这个类, 内部有一个environ列表:
</p>
<ol class="org-ol">
<li>register:  将一个键值对放入environ列表
</li>
<li>get: 获得和一个键绑定的值
</li>
<li>start: 进行一些初始化设置
<ul class="org-ul">
<li>设置eviron中的属性,如果是master机器会设置如下的属性:
<ul class="org-ul">
<li>SERVER_URI: 一个file url,实际上是<a href="file://+WORKDIR[0">file://+WORKDIR[0</a>]
</li>
<li>WORKDIR: 一个目录列表,每一个元素是这样的格式, DPARK_WORK_DIR+时间+host+进程id
</li>
<li>COMPRESS: 压缩函数
</li>
</ul>
<p>
如果不是master,那么只设置COMPRESS.
</p>
</li>
<li>创建一个ctx属性, 这是一个zmq的context实例。
</li>
<li>如果是master机器,那么会启动一个TrackerServer实例, 所以会有一个
trackerServer属性.
</li>
<li>创建一个trackerClinet属性，它是一个TrackerClient实例
</li>
<li>创建一个cacheTracker属性，它是一个CacheTracker实例
</li>
<li>创建一个mapOutputTracker属性, 它是一个MapOutTracker实例。
</li>
<li>创建一个shuffleFetcher属性, 它是一个ParallelShuffleFetcher实例
</li>
</ul>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">conf(conf.py)</h2>
<div class="outline-text-2" id="text-8">
<ol class="org-ol">
<li>DPARK_WORK_DIR: 工作目录,shuffle等操作都会使用该目录.可能包含目录,以逗号分割
</li>
<li>MESOS_MASTER: mesos集群的master地址
</li>
<li>MEM_PER_TASK: 这个很重要如果设的太大会使机器启动失败
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">调度系统</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">基本概念</h3>
<div class="outline-text-3" id="text-9-1">
<ol class="org-ol">
<li>partitioner： 获得分区的个数，以及根据你传进去的key来获得分区的下标
</li>
<li>job：一个作业实际就是一次Action触发的整个任务
</li>
<li>stage：调度系统会根据RDD的血统将整个job切分成多个stage，切分依据主要是
shuffle dependence
</li>
<li>task：一次最小的执行过程，一般是对RDD的一个分区进行的操作。
</li>
<li>taskSet： 一个stage拆分成得到的多个task组成的一个聚合
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">DAGScheduler</h3>
<div class="outline-text-3" id="text-9-2">
<p>
这是一个很核心的类，也就是后面的LocalScheduler，ProcessScheduler，MesosScheduler
都是继承的这个类，下面详细的分析一下这个类：
</p>
<ol class="org-ol">
<li>runJob: 这个方法是被ctx的runJob方法触发的，它的基本流程是这样的：
<ol class="org-ol">
<li></li>
</ol>
</li>
<li>submitTasks: 这个方法在DAGScheduler中没有实现，但是这个需要在子类中实现，在子
类中会根据自己的运行模式来选择适当的方法来运行task。
</li>
</ol>
<p>
下面以MesosScheduler为例来说一说submitTasks的实现：
</p>
<ol class="org-ol">
<li>创建一个SimpleJob
</li>
<li>接着启动mesos的SchedulerDriver
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">Task(task.py)</h3>
<div class="outline-text-3" id="text-9-3">
<p>
task实际上是mesos中的运行单元，mesos的scheduler得到资源后就会提交一个task。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Executor(executor.py)</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">web server</h3>
<div class="outline-text-3" id="text-10-1">
<p>
在executor中启动了一个http server，这个server是用来获取本地文件系统的中的文件,
也就是work_dir中的文件的。
</p>
</div>
</div>
<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2">进程池</h3>
<div class="outline-text-3" id="text-10-2">
<p>
executor用一个进程池来运行task，这个进程池的创建主要在get_idle_workers中，使用
multiprocess的pool来创建的。之所以用进程池也是为了规避GIL的影响。多线程无法利用
多核的优势。在初始化process时先运行init_env，它会初始化dpark.env
</p>
</div>
</div>
<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3">run_task</h3>
<div class="outline-text-3" id="text-10-3">
<p>
这个函数就是运行task的关键函数。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<!-- 多说评论框 start -->
  <div id="duoshuo-id" class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
   var url = window.location.pathname;
   var duoshuo_identifier = url.substring(url.lastIndexOf('/')+1);
   if (!!! duoshuo_identifier) {
     duoshuo_identifier = "index.html";
   }
   var title = document.title;
   var ele = document.getElementById("duoshuo-id");
   ele.setAttribute("data-thread-key", duoshuo_identifier);
   ele.setAttribute("data-title", title);
   ele.setAttribute("data-url", url);

</script>

<script type="text/javascript">
var duoshuoQuery = {short_name:"yuyang0"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementById('postamble')
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end --><!-- begin footer -->
<div id="footer">
  <ul class="links vertical-nav">
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a class="back-to-top" href="#">Back to Top</a></li>
  </ul>
  <span>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</span>
  <a href="#" class="back-to-top" id="fixed-back-to-top" ></a>
</div>
<script src="http://apps.bdimg.com/libs/jquery/2.0.0/jquery.min.js"></script>
<script type="text/javascript">
	window.jQuery || document.write('<script src="static/js/jquery-2.0.0.min.js"><\/script>');
	</script>
<script type="text/javascript" src="static/js/custom.js"></script>
<!-- end footer -->
</div>
</body>
</html>
