<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-02-28 Sun 21:11 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>UNIX网络编程</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Yu Yang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/>
<link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="site-title"><a href="/"> 编码者言 </a></h1>
        <div>
          <a href="###" id="site-nav-btn">菜单</a>
          <ul id="site-nav" class="vertical-nav mobi-hid">
            <li> <a href="/">Home</a></li>
            <li> <a href="/about.html">About</a></li>

            <li> <a href="/tags.html">Tags</a></li>

            <li> <a href="/atom.xml">RSS</a></li>
          </ul>

          <form id="site-search" method="get" action="https://google.com/search">
            <input type="hidden" name="q" value="site:yuyang0.github.io" />
            <input type="text" name="q" placeholder="Search..." />
            <button class="btn-search" type="submit">Search</button>
          </form>
          <div style="clear:both;"> </div>
        </div>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">UNIX网络编程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline6">协议相关</a>
<ul>
<li><a href="#orgheadline5">TCP</a>
<ul>
<li><a href="#orgheadline1">协议详解</a></li>
<li><a href="#orgheadline2">三步握手</a></li>
<li><a href="#orgheadline3">连接关闭</a></li>
<li><a href="#orgheadline4">状态变化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline7">网络设备</a></li>
<li><a href="#orgheadline8">socket地址相关</a>
<ul>
<li><a href="#orgheadline9">常用代码</a></li>
</ul>
</li>
<li><a href="#orgheadline14">基本socket API</a>
<ul>
<li><a href="#orgheadline10">connect</a></li>
<li><a href="#orgheadline11">bind</a></li>
<li><a href="#orgheadline12">listen</a></li>
<li><a href="#orgheadline13">socket读写api</a></li>
</ul>
</li>
<li><a href="#orgheadline15">socket options</a>
<ul>
<li><a href="#orgheadline16">SO_KEEPALIVE</a></li>
<li><a href="#orgheadline17">SO_LINGER</a></li>
<li><a href="#orgheadline18">SO_RCVBUF/SO_SNDBUF</a></li>
<li><a href="#orgheadline19">SO_RCVLOWAT/SO_SNDLOWAT</a></li>
<li><a href="#orgheadline20">SO_REUSEADDR/SO_REUSEPORT</a></li>
</ul>
</li>
<li><a href="#orgheadline24">编程技巧</a>
<ul>
<li><a href="#orgheadline21">一些情形下tcp socket的行为</a></li>
<li><a href="#orgheadline22">异步非阻塞</a></li>
<li><a href="#orgheadline23">raw socket</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6">协议相关</h2>
<div class="outline-text-2" id="text-orgheadline6">
</div><div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">TCP</h3>
<div class="outline-text-3" id="text-orgheadline5">
</div><div id="outline-container-orgheadline1" class="outline-4">
<h4 id="orgheadline1">协议详解</h4>
<div class="outline-text-4" id="text-orgheadline1">
<p>
tcp的头部格式
</p>
<pre class="example">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|      Receive Window Size      |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p>
<b>几点解释:</b>
</p>
<ol class="org-ol">
<li>Source Port, Destination Port是端口号</li>
<li>Sequence Number: tcp对内部传送的每一个字节都会编号, 该字段代表的就是该数
据报第一个字节的编号.</li>
<li>Acknowledgment Number: 当接受端收到一个tcp数据报后,会发送一个确认报文,发
送端就是根据确认报文来判断该数据报是否发送成功,如果长时间没有收到确认报
文,那么发送端就会重发tcp数据报, 确认报文的ACK必须为1,同时Acknowledgment
Number代表该端期望接受数据的序号,比如接受端收到一个tcp报文,该报文的
Sequence Number是a, 同时报文长度是b, 那么对该报文的确认报文的
Acknowledgment Number字段就是a+b. <b>只有ACK标志为1时该字段才有效</b></li>
<li>Data Offset: 实际数据在报文中的偏移,也可以看作是tcp头部的大小,因为tcp头部
包含options所以他的大小是可变的,这就是该字段存在的原因.</li>
<li>标志:
<ul class="org-ul">
<li>URG: 紧急指针</li>
<li>ACK: Acknowledgement number有效</li>
<li>PSH:</li>
<li>RST: 重置连接, 万恶的GFW经常这么干.</li>
<li>SYN: Synchronize sequence numbers, 三步握手时需要.</li>
<li>FIN: finish, 关闭连接时会用到该标志</li>
</ul></li>
<li>Window size: 用来标示发送该数据报的一端希望接收的数据大小, 主要用来进行
流控制(flow control).</li>
</ol>
<p>
<b>其他说明:</b>
</p>
<ol class="org-ol">
<li>TCP可以看做是一个全双工管道,可读可写, 也就是说一个tcp socket的读写是分离,
互不干扰的.</li>
<li>TCP提供了流控制,也就是说内部有缓冲区,如果缓冲区满了那么相应的操作就会阻塞,举
个例子, 如果接受者的读缓冲区满了,那么你在发送者一端调用write就会阻塞.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-4">
<h4 id="orgheadline2">三步握手</h4>
<div class="outline-text-4" id="text-orgheadline2">
<p>
如下图所示:
<img src="static/img/tcp-three-way-handshake.png" alt="tcp-three-way-handshake.png" />
三个报文:
</p>
<ol class="org-ol">
<li>SYN标志为1, 同时为Sequence Number指定一个初始值J</li>
<li>SYN以及ACK标志为1,同时为Sequence Number指定一个初始值K, 同时将
Acknowledgement Number设为J+1.</li>
<li>ACK标志为1, 同时将Acknowledgement Number设为K+1, FIN报文会消耗一个编号</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3">连接关闭</h4>
<div class="outline-text-4" id="text-orgheadline3">
<p>
如下图所示
<img src="static/img/tcp-terminate.png" alt="tcp-terminate.png" />
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4">状态变化</h4>
<div class="outline-text-4" id="text-orgheadline4">
<p>
如下图所示
<img src="static/img/tcp-state-change.png" alt="tcp-state-change.png" />
</p>

<p>
<b>TIME_WAIT</b>: 关闭连接时, 执行主动关闭的一方的socket在发送了最后一个ACK后进入
TIME_WAIT状态,并保持该状态2SML(1-4分钟), 该状态存在的原因是:
</p>
<ol class="org-ol">
<li>如果最后一个ACK丢失,那么对方就会重发FIN报文,这时socket有机会发送ACK报文,
而不是由内核发送RST报文.</li>
<li>可以让网络中当前连接的tcp报文全部失效,因为TCP会超时重传,所以网络可能存在
一些没有被当前客户端接受的报文,等待2SML后这些报文就都失效了. 如果不等待
2SML, 同时你又在相同的interface上创建了socket,那么这些上一次连接的报文就
可能被本次连接认为有效.</li>
</ol>
<p>
<b>处于TIME_WAIT时,(ip, port)不可用, 所以有时重启服务器需要等一段时间.</b>, 当然
只有在服务器有客户端连接的情况下才会出现这种情况,因为如果这时重启服务器,那么
服务器端会执行主动关闭,所以就会进入TIME_WAIT状态. 如果没有客户端连接,那么服
务器一般就只有一个listen socket,关闭它不会进入TIME_WAIT.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7">网络设备</h2>
<div class="outline-text-2" id="text-orgheadline7">
<ol class="org-ol">
<li>集线器(HUB): 工作于第二层,基本已被淘汰, 目前基本用交换机, HUB最大的问题是当它接收到一个数据包后,
它会向所有连接到该hub的主机广播, 这样会造成一大堆无用流量. 这主要是因为HUB内部没有交换机内部的那种MAC地址表.</li>
<li>网桥: 也基本被淘汰.</li>
<li>交换机
<ul class="org-ul">
<li>二层交换机: 用来将链路层数据包发给相应的主机或者网络设备, 内部有个MAC地址表,
交换机会根据各个端口接受数据包的源MAC地址来自动的更新该表.因为这个表的存在,
交换机不用像HUB一样广播,它可以点对点的发送,所以效率要高得多.</li>
<li>三层交换机</li>
<li>四层交换机</li>
</ul></li>
<li>路由器</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8">socket地址相关</h2>
<div class="outline-text-2" id="text-orgheadline8">
<p>
有一个通用地址结构 <code>struct sockaddr_in</code>, bind, connect这样的API中都是使用这个
结构, 其它的地址结构必须类型转换为该结构. ipv6又定义了一个新的通用地址结构
<code>struct sock_storage</code>, 该结构可以包含所有的地址,包括ipv4,ipv6以及unix.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">-------------- &#36890;&#29992;&#22320;&#22336;&#32467;&#26500;(&#26087;) ----------------------- </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sockaddr</span> <span style="color: #DCDCCC;">{</span>
    <span style="color: #7CB8BB;">uint8_t</span>     <span style="color: #DFAF8F;">sa_len</span>;
    <span style="color: #7CB8BB;">sa_family_t</span> <span style="color: #DFAF8F;">sa_family</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">address family: AF_xxx value </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">char</span>        <span style="color: #DFAF8F;">sa_data</span><span style="color: #BFEBBF;">[</span><span style="color: #BFEBBF;">14</span><span style="color: #BFEBBF;">]</span>;  <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">protocol-specific address </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #DCDCCC;">}</span>;
<span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">---------------- ipv4 ----------------------------------- </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">in_addr</span> <span style="color: #DCDCCC;">{</span>
    <span style="color: #7CB8BB;">in_addr_t</span>  <span style="color: #DFAF8F;">s_addr</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">32-bit IPv4 address </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">network byte ordered </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #DCDCCC;">}</span>;
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sockaddr_in</span> <span style="color: #DCDCCC;">{</span>
    <span style="color: #7CB8BB;">uint8_t</span>         <span style="color: #DFAF8F;">sin_len</span>;       <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">length of structure (16) </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">sa_family_t</span>     <span style="color: #DFAF8F;">sin_family</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">AF_INET </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">in_port_t</span>       <span style="color: #DFAF8F;">sin_port</span>;      <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">16-bit TCP or UDP port number </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">network byte ordered </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">in_addr</span>  <span style="color: #DFAF8F;">sin_addr</span>;      <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">32-bit IPv4 address </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">network byte ordered </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">char</span>            <span style="color: #DFAF8F;">sin_zero</span><span style="color: #BFEBBF;">[</span><span style="color: #BFEBBF;">8</span><span style="color: #BFEBBF;">]</span>;   <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">unused </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #DCDCCC;">}</span>;

<span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">--------------&#36890;&#29992;&#22320;&#22336;&#32467;&#26500;(&#26032;, ipv6&#23450;&#20041;) ------------------ </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sockaddr_storage</span> <span style="color: #DCDCCC;">{</span>
    <span style="color: #7CB8BB;">uint8_t</span>      <span style="color: #DFAF8F;">ss_len</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">length of this struct (implementation dependent) </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">sa_family_t</span>  <span style="color: #DFAF8F;">ss_family</span>; <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">address family: AF_xxx value </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">implementation-dependent elements to provide:</span>
<span style="color: #7F9F7F;">     * a) alignment sufficient to fulfill the alignment requirements of</span>
<span style="color: #7F9F7F;">     *    all socket address types that the system supports.</span>
<span style="color: #7F9F7F;">     * b) enough storage to hold any type of socket address that the</span>
<span style="color: #7F9F7F;">     *    system supports.</span>
<span style="color: #7F9F7F;">      </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #DCDCCC;">}</span>;

<span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">------------------------ ipv6 --------------------------- </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">in6_addr</span> <span style="color: #DCDCCC;">{</span>
    <span style="color: #7CB8BB;">uint8_t</span>   <span style="color: #DFAF8F;">s6_addr</span><span style="color: #BFEBBF;">[</span><span style="color: #BFEBBF;">16</span><span style="color: #BFEBBF;">]</span>;   <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">128-bit IPv6 address </span><span style="color: #5F7F5F;">*/</span>
                             <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">network byte ordered </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #DCDCCC;">}</span>;
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">SIN6_LEN</span>         <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">required for compile-time tests </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sockaddr_in6</span> <span style="color: #DCDCCC;">{</span>
    <span style="color: #7CB8BB;">uint8_t</span>          <span style="color: #DFAF8F;">sin6_len</span>;      <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">length of this struct (28) </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">sa_family_t</span>      <span style="color: #DFAF8F;">sin6_family</span>;   <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">AF_INET6 </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">in_port_t</span>        <span style="color: #DFAF8F;">sin6_port</span>;     <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">transport layer port# </span><span style="color: #5F7F5F;">*/</span>
                                    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">network byte ordered </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">uint32_t</span>         <span style="color: #DFAF8F;">sin6_flowinfo</span>; <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">flow information, undefined </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">in6_addr</span>  <span style="color: #DFAF8F;">sin6_addr</span>;     <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">IPv6 address </span><span style="color: #5F7F5F;">*/</span>
                                    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">network byte ordered </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">uint32_t</span>         <span style="color: #DFAF8F;">sin6_scope_id</span>; <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">set of interfaces for a scope </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #DCDCCC;">}</span>;
</pre>
</div>
<ol class="org-ol">
<li><p>
有两个函数来转换ip地址,也就是在presentation format与numeric format之间转换,
presentation format是字符串,比如"127.0.0.1", 这种形式对人更友好,而numeric
format是数字,它是放在地址结构体中, 这两个函数能转换ipv4以及ipv6地址,原型如
下:
</p>
<pre class="example">
#include &lt;arpa/inet.h&gt;

int inet_pton(int af, const char *src, void *dst);
const char *inet_ntop(int af, const void *src,
                      char *dst, socklen_t size);
</pre>
<p>
常用 <code>inet_pton</code> 来将字符串表示的ip转换为地址结构体要求的数字ip
</p></li>
<li><p>
因为网络程序需要在不同的机器间通信,所以字节序很重要, 网络协议默认的字节序是
大端字节序, 所以需要函数来在 <b>主机字节序(host byte order)</b> 与 <b>网络字节序
(network byte order)</b> 之间转换, 有以下几个函数:
</p>
<pre class="example">
#include &lt;netinet/in.h&gt;
uint16_t htons(uint16_t host16bitvalue) ;
uint32_t htonl(uint32_t host32bitvalue) ;
                       Both return: value in network byte order
uint16_t ntohs(uint16_t net16bitvalue) ;
uint32_t ntohl(uint32_t net32bitvalue) ;
                       Both return: value in host byte order
</pre>
<p>
常用 <code>htons</code> 来转换端口号.
</p></li>
</ol>
</div>
<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">常用代码</h3>
<div class="outline-text-3" id="text-orgheadline9">
<ol class="org-ol">
<li><p>
客户端
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sockaddr_in</span> <span style="color: #DFAF8F;">servaddr</span>;
bzero<span style="color: #DCDCCC;">(</span>&amp;servaddr, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span><span style="color: #BFEBBF;">(</span>servaddr<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>;
servaddr.sin_family = AF_INET;
servaddr.sin_port = htons<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">13</span><span style="color: #DCDCCC;">)</span>;
<span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #DCDCCC;">(</span>inet_pton<span style="color: #BFEBBF;">(</span>AF_INET, argv<span style="color: #D0BF8F;">[</span><span style="color: #BFEBBF;">1</span><span style="color: #D0BF8F;">]</span>, &amp;servaddr.sin_addr<span style="color: #BFEBBF;">)</span> &lt; <span style="color: #BFEBBF;">0</span><span style="color: #DCDCCC;">)</span> <span style="color: #DCDCCC;">{</span>
    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">error </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #DCDCCC;">}</span>
</pre>
</div></li>
<li><p>
服务端
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sockaddr_in</span> <span style="color: #DFAF8F;">servaddr</span>;
bzero<span style="color: #DCDCCC;">(</span>&amp;servaddr, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span><span style="color: #BFEBBF;">(</span>servaddr<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>;
servaddr.sin_family = AF_INET;
servaddr.sin_port = htons<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">13</span><span style="color: #DCDCCC;">)</span>;
servaddr.sin_addr.s_addr = htonl<span style="color: #DCDCCC;">(</span>INADDR_ANY<span style="color: #DCDCCC;">)</span>;
<span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">or use inet_pton to set ip </span><span style="color: #5F7F5F;">*/</span>
</pre>
</div></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14">基本socket API</h2>
<div class="outline-text-2" id="text-orgheadline14">
</div><div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10">connect</h3>
<div class="outline-text-3" id="text-orgheadline10">
<p>
客户端使用该api建立连接,它可能返回以下错误:
</p>
<ol class="org-ol">
<li>ETIMEDOUT: 超时, 也就是说没有接收到server端的ACK报文.</li>
<li>ECONNREFUSED: 发送SYN报文后,收到了RST报文,也就是说server端没有进程在监听
你要连接的端口.</li>
<li>EHOSTUNREACH, ENETUNREACH:收到了ICMP的unreachable的报文</li>
</ol>
<p>
<b>connect一旦出错,那么该socket就不可用了,必须关闭.</b>
</p>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11">bind</h3>
</div>
<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">listen</h3>
<div class="outline-text-3" id="text-orgheadline12">
<p>
原型:
</p>
<pre class="example">
int listen (int sockfd, int backlog);
</pre>
<p>
内核会维护两个队列:
</p>
<ol class="org-ol">
<li>未完成队列:　当客户端发送３次握手的第一个SYN报文到服务端时,该队列就会增加
一项,完成三次握手后该项就会移到已完成队列的末尾</li>
<li>已完成队列: 当客户端完成三次握手,那么在队列的末尾增加一项,当你调用accept
时就从队列的开头移除一项,如果该队列为空,那么accept会阻塞.</li>
</ol>
<p>
从linux2.2开始backlog是已完成队列的最大值. 未完成队列的最大值由一个全局值设
定,该值在 /proc/sys/net/ipv4/tcp_max_syn_backlog中, 如果已完成队列满了,而此时
未完成队列的某个连接收到了三步握手的最后一个ACK, 这时内核会忽略这个ACK(意思就
是说就像没有收到这个ACK包一样), 因此一段时间后server端会重发第二步握手的
SYN/ACK包.
</p>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">socket读写api</h3>
<div class="outline-text-3" id="text-orgheadline13">
<ol class="org-ol">
<li>对于面向连接的socket(TCP), 有以下两组api, recv/send以及read/write, 前者比
后者多了一个flag参数, 当使用flag=0来调用recv, send时,他的行为和read,write
是一样的.</li>
<li>面向非连接的socket(UDP, RAW):有以下api, recvfrom/sendto, 这两个有一个地址
参数和一个指示地址结构长度的参数, 如果将这两个值设为NULL和0,那么行为实际
和recv/send一样.</li>
<li>send buffer: 在内核中,每一个socket都有一个 send buffer
<ul class="org-ul">
<li><b>TCP</b>: 当你调用write或者send时, 实际就是将数据从用户空间的buffer复制到
内核空间的send buffer, 如果send buffer的空间不够,那么write/send操作将阻
塞(前提是socket没有设为非阻塞).当write/send返回时,意味着数据已经都复制
到了send buffer,但不保证数据已经通过网络发送出去了. 只有收到对方的ACK报
文,这些数据才能从send buffer移除.</li>
<li><b>UDP</b>: 因为udp是直接将数据加上udp头部发往下层,也就是udp数据报要原子的发
送,它不能拆解,所以如果你传入的数据太大,比如比send buffer还大,那么内核会
返回错误EMSGSIZE. 如果只是当前的send buffer没有足够的空间,那么阻塞的
socket上的send调用会阻塞,非阻塞的send调用会返回EAGAIN或者EWOULDBLOCK.
<b>UDP上的send要么全部发送,要么出错,不会出现只发送一部分数据的情况</b></li>
</ul></li>
<li>receive buffer: 内核中每一个socket都有一个receive buffer.
<ul class="org-ul">
<li><b>TCP</b>: 通过tcp的流控制(tcp报文的Window字段), 可以通知peer该端目前能够接
受的数据大小,如果peer忽略该建议,同时发送来的数据大于该大小,那么内核会丢
弃这个数据报.因为receive buffer没有足够的空间容纳这些数据.丢弃后peer过
一段时间要重发,那么peer就会"慢下来", 这实际就是流量控制.</li>
<li><b>UDP</b>: udp没有流控制,如果receive buffer,内核会直接丢弃数据报</li>
</ul></li>
<li><p>
读就绪条件:满足下面四个条件之一的,read操作不会阻塞
</p>
<ol class="org-ol">
<li>socket的receive buffer中的数据大于等于"低水位"值(low-water mark)</li>
<li>socket的被读关闭,那么read会马上返回0</li>
<li>socket是listening socket,而且这时已完成队列不为空,那么accept会立即返回</li>
<li>socket上有错误在排队,read操作会直接出错返回</li>
</ol>
<p>
<b>当读就绪时, 阻塞读与非阻塞读的行为是相似的,都会立即返回.并且返回读到的字
节数.</b>
</p></li>
<li>写就绪条件: 满足下面四个条件之一的,write操作不会阻塞
<ol class="org-ol">
<li>socket的send buffer的空余空间大于"低水位"值,</li>
<li>socket被写关闭,那么写操作会产生SIGPIPE信号.</li>
<li>非阻塞的connect,或者connect出错</li>
<li>socket上有错误在排队, write会直接出错返回.</li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15">socket options</h2>
<div class="outline-text-2" id="text-orgheadline15">
<p>
使用下面的两个系统调用来获取以及设置socket选项
</p>
<pre class="example">
#include &lt;sys/socket.h&gt;
int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname, const void *optval socklen_t optlen);
</pre>
<p>
注意optval对于不同的选项是不同的值,所以你要optlen参数来通知获得optval的长度.
</p>
</div>
<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16">SO_KEEPALIVE</h3>
<div class="outline-text-3" id="text-orgheadline16">
<p>
如果socket设置了该选项, 那么当一个连接有两个小时没有交换数据了(这意味着程序
阻塞在某个系统调用上), 那么就会向对方发送一个keep-alive probe, 实际就是一个
tcp报文. 如果这个报文收到了正常的ACK,那么就什么也不做,如果超时或者收到RST报
文,那么被阻塞的系统调用会返回相应的错误.
</p>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17">SO_LINGER</h3>
<div class="outline-text-3" id="text-orgheadline17">
<p>
对面向连接的协议有效, 所以对UDP该选项无用, 该选项是用来改变socket调用close时的行
为.默认如果你调用close,那么close会立即返回,但是如果send buffer有数据,那么系统会
现将数据发送出去. 这种默认行为可以改变
</p>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18">SO_RCVBUF/SO_SNDBUF</h3>
<div class="outline-text-3" id="text-orgheadline18">
<p>
修改socket的send buffer以及receive buffer的大小. <b>这两个选项必须在connect与
listen之前设置</b>.
</p>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19">SO_RCVLOWAT/SO_SNDLOWAT</h3>
<div class="outline-text-3" id="text-orgheadline19">
<p>
低水位标志,用来判断一个socket是否可读或者可写, 如果接受缓冲区的数据量大于
SO_RCVLOWAT(默认为1)那么可读, 如果发送缓冲区的空闲空间大于SO_SNDLOWAT(默认通常为
2048)那么可写.
</p>
</div>
</div>
<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20">SO_REUSEADDR/SO_REUSEPORT</h3>
<div class="outline-text-3" id="text-orgheadline20">
<p>
主要是避免重启服务器程序时的address already in use的错误.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline24" class="outline-2">
<h2 id="orgheadline24">编程技巧</h2>
<div class="outline-text-2" id="text-orgheadline24">
</div><div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21">一些情形下tcp socket的行为</h3>
<div class="outline-text-3" id="text-orgheadline21">
<ul class="org-ul">
<li>server端的进程终止了,这时client端向socket写则会收到RST报文, 如果你接着向这个
socket写入数据,那么会收到SIGPIPE信号.如果你忽略了该信号,那么write会返回EPIPE
错误.</li>
<li>如果server崩溃(比如断电,比如断掉网线然后关掉进程, 总之让client无法收到正常
关闭时的FIN包), 这时有两种情况:
<ul class="org-ul">
<li>如果server端没有恢复正常(比如没有重启, 或者没有插上网线重启进程), 那么
client端会超时.</li>
<li>如果server恢复了正常,那么client向server写会收到RST, 这时读该socket会产生
ECONNRESET错误</li>
</ul></li>
<li>RST的产生条件：
<ol class="org-ol">
<li>connect连接一个服务器，可是服务器没有运行（在指定的端口没有 socket在listen），
该情况作为connect调用的错误检查（ECONNREFUSED）</li>
<li>当tcp要 abort一个连接时。</li>
<li>当tcp收到一个不存在的连接发来的数据包时。</li>
</ol></li>
<li>对于连接的任一端，如果发送FIN，就意味着该端不会再向该连接写数据，所以另一端
read该连接都会返回0也就是EOF。</li>
<li>Connect只能调用一次，不能像accept，read，write那样被信号打断后重启，一旦失败，
那么该socket fd就必须关闭，当然只是同步调用，如果指定了了O_NOBLOCK,如果connect
失败，且errno=EINPROGRESS，那么并不意味在调用失败。</li>
<li>如果向socket写入数据返回了RST，那么此时读该socket会返回ECONNRESET错误，如果此
时写该socket会产生SIGPIPE信号，该信号默认会终止该程序，所以必须处理。</li>
<li>如果一个A到B的连接，如果执行了B-&gt;A的半关闭，也就是B向A发送FIN，那么表明B不会再
向socket写数据，所以在A端读该socket会返回EOF，如果A端向socket写，那么分情况：
<ol class="org-ol">
<li>如果B端的进程已终止，那么连接已经不存在，所以会返回一个RST，</li>
<li>如果B端的进程没有终止，而只是执行了半关闭，那么A端的write是合法的，因为 半
关闭是合法的。</li>
</ol></li>
<li>对于tcp客户端，如果没有明确调用bind，那么socket的端口是在调用connect时由内核随
机指定，而udp socket的端口则是在第一次调用sendto 时由内核随机指定的，而且一旦
指定就不在改变，而udp socket的ip地址是可变的，如果客户端主机是一个多接口（有多
块网卡）的主机，那么每一次发送udp数据包内核都可以随机选择可用的ip地址。（ip地
址是在ip层指定，而端口则是在udp层指定，所以没有调用bind的socket，它的端口不可
变，ip却可变）。</li>
<li>对于缓冲区：对tcp而言，向socket写，会将数据从用户缓冲区复制到内核的发送缓冲区，
然后内核将这些数据发送给目的端，但是此时内核发送缓冲区的数据没有丢弃，只有当接
到ack时这些数据才会丢弃，因为网络数据包可能丢失，所以这些可能需要重传。而对于
udp则并没有发送缓冲区，因为udp是unreliable的，它无连接，所以不需要重传，直接将
数据加上udp头，ip头发送出去，然后数据就丢弃了。对于内核的接收缓冲区，tcp与udp
基本一致，udp的内核接受缓冲区会限制接受的数据报的数量，一旦 超出缓冲区的大小，
后续的udp包都会丢弃。（unp 8.13）。</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline22" class="outline-3">
<h3 id="orgheadline22">异步非阻塞</h3>
<div class="outline-text-3" id="text-orgheadline22">
<ol class="org-ol">
<li><p>
<code>connect</code>: 在调用之前将socket设置为非阻塞, 那么connect可能会出错, 那么这时候
要检查errno, 如果为EINPROGRESS, 那么意味着connect需要阻塞, 这时候你应该监听
socket的可写事件, 如果发现可写,那么使用 <code>getsockopt</code> 来获取错误, 如果没有错误,那
么connect执行成功, 否则执行失败,示例代码
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">flags</span>;

<span style="color: #F0DFAF; font-weight: bold;">if</span><span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">(</span>flags = fcntl<span style="color: #D0BF8F;">(</span>fd, F_GETFL<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span> &lt; <span style="color: #BFEBBF;">0</span><span style="color: #DCDCCC;">)</span> <span style="color: #5F7F5F;">//</span><span style="color: #7F9F7F;">&#33719;&#21462;&#24403;&#21069;&#30340;flags&#26631;&#24535;</span>
  err_sys<span style="color: #DCDCCC;">(</span>&#8220;F_GETFL error<span style="color: #F0DFAF; font-weight: bold;">!</span>&#8221;<span style="color: #DCDCCC;">)</span>;

flags |= O_NONBLOCK; <span style="color: #5F7F5F;">//</span><span style="color: #7F9F7F;">&#20462;&#25913;&#38750;&#38459;&#22622;&#26631;&#24535;&#20301;</span>

<span style="color: #F0DFAF; font-weight: bold;">if</span><span style="color: #DCDCCC;">(</span>fcntl<span style="color: #BFEBBF;">(</span>fd, F_SETFL, flags<span style="color: #BFEBBF;">)</span> &lt; <span style="color: #BFEBBF;">0</span><span style="color: #DCDCCC;">)</span>
  err_sys<span style="color: #DCDCCC;">(</span>&#8220;F_SETFL error<span style="color: #F0DFAF; font-weight: bold;">!</span>&#8221;<span style="color: #DCDCCC;">)</span>;
<span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #DCDCCC;">(</span>connect<span style="color: #BFEBBF;">(</span>fd, <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sockaddr</span>*<span style="color: #D0BF8F;">)</span>&amp;sa, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span><span style="color: #D0BF8F;">(</span>sa<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span> == -<span style="color: #BFEBBF;">1</span><span style="color: #DCDCCC;">)</span> <span style="color: #DCDCCC;">{</span>
  <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #BFEBBF;">(</span>errno != EINPROGRESS<span style="color: #BFEBBF;">)</span> <span style="color: #BFEBBF;">{</span>
    <span style="color: #F0DFAF; font-weight: bold;">return</span> -<span style="color: #BFEBBF;">1</span>;
  <span style="color: #BFEBBF;">}</span>
 <span style="color: #DCDCCC;">}</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#30417;&#21548;&#21487;&#20889;&#20107;&#20214;, &#22914;&#26524;&#21487;&#20889;&#25191;&#34892;&#19979;&#38754;&#20195;&#30721;</span>
err = <span style="color: #BFEBBF;">0</span>;
errlen = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span><span style="color: #DCDCCC;">(</span>err<span style="color: #DCDCCC;">)</span>;
<span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #DCDCCC;">(</span>getsockopt<span style="color: #BFEBBF;">(</span>fd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;errlen<span style="color: #BFEBBF;">)</span> == -<span style="color: #BFEBBF;">1</span><span style="color: #DCDCCC;">)</span> <span style="color: #DCDCCC;">{</span>
  sprintf<span style="color: #BFEBBF;">(</span><span style="color: #CC9393;">"getsockopt(SO_ERROR): %s"</span>, strerror<span style="color: #D0BF8F;">(</span>errno<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span>;
  close<span style="color: #BFEBBF;">(</span>fd<span style="color: #BFEBBF;">)</span>;
  <span style="color: #F0DFAF; font-weight: bold;">return</span> ERR;
 <span style="color: #DCDCCC;">}</span>
<span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #DCDCCC;">(</span>err<span style="color: #DCDCCC;">)</span> <span style="color: #DCDCCC;">{</span>

  errno = err;

  close<span style="color: #BFEBBF;">(</span>fd<span style="color: #BFEBBF;">)</span>;

  <span style="color: #F0DFAF; font-weight: bold;">return</span> ERR;
 <span style="color: #DCDCCC;">}</span>
</pre>
</div></li>
<li>服务端在accept之前将socket设置为非阻塞, 这样你就可以监听listenfd的可读事件,
如果可读,那么就意味着有新连接进来,那么你就可以调用accept来获得连接了, 如果没
有连接的时候你调用accept, 那么会出错返回, errno为EAGAIN或者EWOULDBLOCK.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23">raw socket</h3>
<div class="outline-text-3" id="text-orgheadline23">
<p>
raw socket 是用来获取IP报文的, 但是内核不会把所有的报文都发给raw socket.
</p>
<ol class="org-ol">
<li>TCP/UDP的IP报文不会发给raw socket, 所以要抓这种报文只能去链路层抓包</li>
<li>ICMP/IGMP的IP报文会发送给raw socket</li>
<li>如果内核不认识IP报文的协议类型字段,那么发给raw socket</li>
<li>如果IP报文有分片,那么只有把所有的分片组合成一个完整的IP报文后才会发送给raw socket.</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<!-- 多说评论框 start -->
  <div id="duoshuo-id" class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
   var url = window.location.pathname;
   var duoshuo_identifier = url.substring(url.lastIndexOf('/')+1);
   if (!!! duoshuo_identifier) {
     duoshuo_identifier = "index.html";
   }
   var title = document.title;
   var ele = document.getElementById("duoshuo-id");
   ele.setAttribute("data-thread-key", duoshuo_identifier);
   ele.setAttribute("data-title", title);
   ele.setAttribute("data-url", url);

</script>

<script type="text/javascript">
var duoshuoQuery = {short_name:"yuyang0"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementById('postamble')
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end --><!-- begin footer -->
<div id="footer">
  <ul class="links vertical-nav">
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a class="back-to-top" href="#">Back to Top</a></li>
  </ul>
  <span>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</span>
  <a href="#" class="back-to-top" id="fixed-back-to-top" ></a>
</div>
<script src="http://apps.bdimg.com/libs/jquery/2.0.0/jquery.min.js"></script>
<script type="text/javascript">
	window.jQuery || document.write('<script src="static/js/jquery-2.0.0.min.js"><\/script>');
	</script>
<script type="text/javascript" src="static/js/custom.js"></script>
<!-- end footer -->
</div>
</body>
</html>
