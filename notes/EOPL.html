<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>The Essential of Programming language</title>
<!-- 2014-02-01 Sat 10:57 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Yu Yang" />
<meta  name="keywords" content="EOPL programming-language  scheme" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/> <link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
            config: ["MMLorHTML.js"], jax: ["input/TeX"],
        //  jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="blog-title"><a href="/"> Yu Yang's Blog</a></h1>
        <ul class="nav">
          <li> <a href="/">Home</a></li>
          <li> <a href="/about.html">About</a></li>
          <li> <a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" action="https://google.com/search" id="search">
          <input type="hidden" name="q" value="site:yuyang.farbox.com" />
          <input type="text" name="q" placeholder="Search..." />
        </form>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">The Essential of Programming language</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Forward</a></li>
<li><a href="#sec-2">1. Inductive Sets and Data</a>
<ul>
<li><a href="#sec-2-1">1.1</a>
<ul>
<li><a href="#sec-2-1-1">top-down definition</a></li>
<li><a href="#sec-2-1-2">bottom-up definition</a></li>
<li><a href="#sec-2-1-3">rules of inference</a></li>
</ul>
</li>
<li><a href="#sec-2-2">1.2</a>
<ul>
<li><a href="#sec-2-2-1">用语法规则定义集合</a></li>
<li><a href="#sec-2-2-2">The Smaller-Subproblem Principle</a>
<ul>
<li><a href="#sec-2-2-2-1">nth-element</a></li>
<li><a href="#sec-2-2-2-2">remove-first</a></li>
<li><a href="#sec-2-2-2-3">occurs-free?</a></li>
<li><a href="#sec-2-2-2-4">subst</a></li>
</ul>
</li>
<li><a href="#sec-2-2-3">Follow the Grammar!</a></li>
</ul>
</li>
<li><a href="#sec-2-3">Exercise</a></li>
</ul>
</li>
<li><a href="#sec-3">2 Data Abstraction</a>
<ul>
<li><a href="#sec-3-1">2.3 Interfaces for Recursive Data Types</a></li>
<li><a href="#sec-3-2">2.4 A Tool for Defining Recursive Data Types</a></li>
<li><a href="#sec-3-3">Exercise</a></li>
</ul>
</li>
<li><a href="#sec-4">3 Expressions</a>
<ul>
<li><a href="#sec-4-1">Some Concepts</a></li>
</ul>
</li>
<li><a href="#sec-5">4 State</a>
<ul>
<li><a href="#sec-5-1">返回值与副作用的区别</a></li>
<li><a href="#sec-5-2">4.1 Computational Effects</a></li>
</ul>
</li>
<li><a href="#sec-6">Continuation-Passing Interpreter</a>
<ul>
<li><a href="#sec-6-1">Serveral Concepts</a></li>
</ul>
</li>
<li><a href="#sec-7">lambda calculus</a>
<ul>
<li><a href="#sec-7-1">Church Encode</a></li>
<li><a href="#sec-7-2">Y Combinator</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Forward</h2>
<div class="outline-text-2" id="text-1">
<p>
  Perhaps the whole distinction between program and programming language is a
misleading idea, and future programmers will see themselves not as writing
programs in particular, but as creating new languages for each new application.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">1. Inductive Sets and Data</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1.1</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">top-down definition</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
自顶向下意味着从宏观的角度向微观细分
A Scheme list is a list of integers if and only if either
</p>
<ol class="org-ol">
<li>it is the empty list, or
</li>
<li>it is a pair whose car is an integer and whose cdr is a list of integers.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">bottom-up definition</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
自底向上意味着从微观的角度向宏观归纳
The set List-of-Int is the smallest set of Scheme lists satisfying the
following two properties:
</p>
<ol class="org-ol">
<li>() ∈ List-of-Int, and
</li>
<li>if n ∈ Int and l ∈ List-of-Int, then (n . l) ∈ List-of-Int.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3">rules of inference</h4>
<div class="outline-text-4" id="text-2-1-3">
\begin{align}
  () \in List-of-Int  \\
  \frac {n \in Int \quad l \in List-of-Int} {(n . l) \in List-of-Int}
\end{align}
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">1.2</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">用语法规则定义集合</h4>
<div class="outline-text-4" id="text-2-2-1">
\begin{align}
  List-of-Int &::= ()  \\
              &::= (Int . List-of-Int)
\end{align}

<p>
可以缩写为:
</p>

\begin{equation}
  List-of-Int ::= () | (Int . List-of-Int)
\end{equation}
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">The Smaller-Subproblem Principle</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
If we can reduce a problem to a smaller subproblem, we can call the
procedure that solves the problem to solve the subproblem.
</p>
</div>
<div id="outline-container-sec-2-2-2-1" class="outline-5">
<h5 id="sec-2-2-2-1">nth-element</h5>
<div class="outline-text-5" id="text-2-2-2-1">
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">nth-element</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lst n)
    (<span style="color: #F92672; font-weight: bold;">if</span> (null? lst)
        (report-list-too-short n)
        (<span style="color: #F92672; font-weight: bold;">if</span> (zero&#65311;n)
            (car lst)
            (nth-element (cdr lst) (- n 1))))))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">report-list-too-short</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (n)
    (eopl:error &#8217;nth-element
<span style="color: #E6DB74;">"List too short by ~s elements.~%"</span> (+ n 1))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2-2" class="outline-5">
<h5 id="sec-2-2-2-2">remove-first</h5>
<div class="outline-text-5" id="text-2-2-2-2">
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">remove-first</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (s los)
    (<span style="color: #F92672; font-weight: bold;">if</span> (null? los)
        '()
        (<span style="color: #F92672; font-weight: bold;">if</span> (eqv? s (car los))
            (cdr los)
            (cons (car los) (remove-first s (cdr los)))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2-3" class="outline-5">
<h5 id="sec-2-2-2-3">occurs-free?</h5>
</div>
<div id="outline-container-sec-2-2-2-4" class="outline-5">
<h5 id="sec-2-2-2-4">subst</h5>
<div class="outline-text-5" id="text-2-2-2-4">
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">subst</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (new old slist)
    ()))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">Follow the Grammar!</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
When defining a procedure that operates on inductively defined data, the
structure of the program should be patterned after the structure of the
data.
</p>

<p>
更准确的说:
</p>
<ol class="org-ol">
<li>Write one procedure for each nonterminal in the grammar. The procedure
will be responsible for handling the data corresponding to that
nonterminal, and nothing else.
</li>
<li>In each procedure, write one alternative for each production correspond-
ing to that nonterminal. You may need additional case structure, but
this will get you started. For each nonterminal that appears in the
right-hand side, write a recursive call to the procedure for that
nonterminal.
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Exercise</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>1.1
{3n + 2 | n ∈ N }
<ol class="org-ol">
<li>top-down: A natural number <code>n</code> is in S if and only if
<ol class="org-ol">
<li>n=2 or
</li>
<li>n-3 \(\in\) S
</li>
</ol>
</li>

<li>buttom-up: Define S is the smallest set contained in N and satisfying
the following two property:
<ol class="org-ol">
<li>2 \(\in\) S
</li>
<li>if n \(\in\) S then n+3 \(\in\) S
</li>
</ol>
</li>
<li>rules of inference

\begin{align}
  2 \in S \\
  \frac {n \in S} {n+3 \in S}
\end{align}
</li>
</ol>
</li>

<li>1.2
<ol class="org-ol">
<li>(i, 7i+1) (0, 1), (1, 8), (2, 15) &#x2026;
</li>
<li>(i, 2^i)  (0, 1), (1, 2), (2, 4)
</li>
</ol>
</li>
<li>1.6
当n&gt;=length(lst)时,会导致(cdr lst)出错
</li>
<li>1.7
<div class="org-src-container">

<pre class="src src-scheme"></pre>
</div>
</li>
<li>1.8
使用 <code>(remove-first s (cdr los))</code> 替换 <code>remove-first</code> 的最后一行会导致los中第一
个s之前的元素都丢失
</li>
<li>1.9
<pre class="example">
remove: Sym * Listof(Sym) --&gt; Listof(Sym)
Usage: (remove s los) return a list with the same element arranged in the
same order as los, except that all the occurrence of symbol s is removed
</pre>

<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">remove</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (s los)
    (<span style="color: #F92672; font-weight: bold;">if</span> (null? los)
        '()
        (<span style="color: #F92672; font-weight: bold;">if</span> (eqv? s (car los))
            (remove s (cdr los))
            (cons (car los) (remove s (cdr los)))))))
</pre>
</div>
</li>
<li>1.15
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">duple</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (n lst)
    (<span style="color: #F92672; font-weight: bold;">if</span> (eq? n 1)
        (cons  lst '())
        (cons lst (duple (- n 1) lst)))))
</pre>
</div>
</li>
<li>1.16
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">invert</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lst)
    (<span style="color: #F92672; font-weight: bold;">if</span> (null? lst)
        '()
        (cons (invert-2-elt-lst (car lst))
              (invert (cdr lst)))
        )))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">invert-2-elt-lst</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lst)
    (cons (cadr lst)
          (cons (car lst) '()))))
</pre>
</div>
</li>
<li>1.17
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">down</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lst)
    (<span style="color: #F92672; font-weight: bold;">if</span> (null? lst)
        '()
        (cons (cons (car lst) '())
              (down (cdr lst))))))
</pre>
</div>
</li>
<li>1.18
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">swapper</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (s1 s2 lst)
    (<span style="color: #F92672; font-weight: bold;">if</span> (null? lst)
        '()
        (<span style="color: #F92672; font-weight: bold;">let</span> ((1st-elt (car lst)))
          (<span style="color: #F92672; font-weight: bold;">cond</span>
           ((eq? 1st-elt s1) (cons s2 (swapper s1 s2 (cdr lst))))
           ((eq? 1st-elt s2) (cons s1 (swapper s1 s2 (cdr lst))))
           ((list? 1st-elt) (cons (swapper s1 s2 1st-elt) (swapper s1 s2 (cdr ls<span style="color: #F92672; background-color: #272822;">t))))</span>
           (<span style="color: #F92672; font-weight: bold;">else</span> (cons 1st-elt (swapper s1 s2 (cdr lst))))
           )))))
</pre>
</div>
</li>
<li>1.19
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">list-set</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lst n x)
    (<span style="color: #F92672; font-weight: bold;">cond</span>
     ((null? lst) (message <span style="color: #E6DB74;">"the list is too short"</span>))
     ((zero? n) (cons x (cdr lst)))
     (<span style="color: #F92672; font-weight: bold;">else</span> (cons (car lst)
                 (list-set (cdr lst) (- n 1) x))))))
</pre>
</div>
</li>
<li>1.20
</li>
<li>1.34
打印二叉树搜索路径
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">path</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (elt bst)
    (<span style="color: #F92672; font-weight: bold;">cond</span>
     ((null? bst) '())
     ((eq? elt (car bst)) '())
     ((&lt; elt (car bst)) (cons 'left (path elt (cadr bst))))
     ((&gt; elt (car bst)) (cons 'right (path elt (caddr bst))))
     )))
</pre>
</div>
</li>
<li>1.35
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">number-leaves</span>)
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">interior-node</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (root left right)
    ))
</pre>
</div>
</li>
<li>1.36
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">g</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (car-elt cdr-elt)
    (<span style="color: #F92672; font-weight: bold;">define</span> (<span style="color: #A6E22E;">add1-elt-number</span> lst)
      (<span style="color: #F92672; font-weight: bold;">if</span> (null? lst) '()
          (cons (cons (+ 1 (caar lst))
                      (cdar lst))
                (add1-elt-number (cdr lst)))))
    (add1-elt-number (cons car-elt cdr-elt))))

(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">number-elements</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lst)
    (<span style="color: #F92672; font-weight: bold;">if</span> (null? lst) '()
        (g (list 0 (car lst)) (number-elements (cdr lst))))))
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">2 Data Abstraction</h2>
<div class="outline-text-2" id="text-3">
<p>
\(\lceil v \rceil\) 代表数据 <code>v</code> 的实现
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">2.3 Interfaces for Recursive Data Types</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Designing an interface for a recursive data type:
</p>
<ol class="org-ol">
<li>Include one constructor for each kind of data in the data type.
</li>
<li>Include one predicate for each kind of data in the data type.
</li>
<li>Include one extractor for each piece of data passed to a constructor of
the data type.
</li>
</ol>
<p>
举个例子, 比如lambda calculus的语法定义是这样:
</p>

\begin{align}
  Lc-exp &::= Identifier \\
         &::= (lambda (Identifier) Lc-exp) \\
         &::= (Lc-exp Lc-exp)
\end{align}

<p>
我们来定义它的interface(<b>注意是接口,不是实现</b>).
</p>
<ol class="org-ol">
<li>Constructor
<ul class="org-ul">
<li>var-exp : Var → Lc-exp
</li>
<li>lambda-exp : Var × Lc-exp → Lc-exp
</li>
<li>app-exp : Lc-exp × Lc-exp → Lc-exp
</li>
</ul>
</li>
<li>Predicates
<ul class="org-ul">
<li>var-exp? : Lc-exp → Bool
</li>
<li>lambda-exp? : Lc-exp → Bool
</li>
<li>app-exp? : Lc-exp → Bool
</li>
</ul>
</li>
<li>Extractors
<ul class="org-ul">
<li><b>var-exp-&gt;var</b> :Lc-exp → Var
</li>
<li><b>lambda-exp-&gt;bound-var</b> :Lc-exp → Var
</li>
<li><b>lambda-exp-&gt;body</b> :Lc-exp → Lc-exp
</li>
<li><b>app-exp-&gt;rator</b> :Lc-exp → Lc-exp
</li>
<li><b>app-exp-&gt;rand</b> :Lc-exp → Lc-exp
</li>
</ul>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">2.4 A Tool for Defining Recursive Data Types</h3>
<div class="outline-text-3" id="text-3-2">
<p>
使用define-datatype来自动的定义一个递归数据类型(<b>接口</b>),以lambda calculus的语法定义
为例子
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define-datatype lc-exp lc-exp?
  (var-exp
   (var identifier?))
  (lambda-exp
   (bound-var identifier?)
   (body lc-exp?))
  (app-exp
   (rator lc-exp?)
   (rand lc-exp?)))
</pre>
</div>
<p>
上面声明了3个constructor: var-exp, lambda-exp, app-exp以及一个
predicate:Lc-exp?.然后可以使用cases来使用上述定义:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">occurs-free?</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (search-var exp)
    (cases lc-exp exp
           (var-exp (var) (eqv? var search-var))
           (lambda-exp (bound-var body)
                       (<span style="color: #F92672; font-weight: bold;">and</span>
                        (not (eqv? search-var bound-var))
                        (occurs-free? search-var body)))
           (app-exp (rator rand)
                    (<span style="color: #F92672; font-weight: bold;">or</span>
                     (occurs-free? search-var rator)
                     (occurs-free? search-var rand))))))
</pre>
</div>
<p>
使用cases可以匹配出一个lc-exp的类型,它到底是var-exp, lambda-exp还是app-exp,
根据不同的情况你可以分支处理,很像一个模式匹配的过程
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Exercise</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>2.1
</li>
</ul>
\begin{equation}
  ⌈n⌉ = \left\{\begin{array}{ll}
      () & \textrm{n = 0} \\
      (r . \lceil q \rceil ) & \textrm{n = qN + r, 0 ≤ r < N}
      \end{array} \right.
\end{equation}

<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">N</span> 16)
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">zero</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> () '()))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">is-zero?</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> (n) (null? n)))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">successor</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> (n)
                    (<span style="color: #F92672; font-weight: bold;">cond</span>
                     [(null? n) '(1)]
                     [(eq? (car n) (- N 1))
                      (cons 0
                            (successor (cdr n)))]
                     [else (cons (+ 1 (car n)) (cdr n))])))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">predecessor</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> (n)
                      (<span style="color: #F92672; font-weight: bold;">cond</span>
                       [(equal? n '(1)) '()]
                       [(zero? (car n))
                        (cons (- N 1)
                              (predecessor (cdr n)))]
                       [else (cons (- (car n) 1) (cdr n))])))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">one</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> () (successor (zero))))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">factorial</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (n)
    (<span style="color: #F92672; font-weight: bold;">if</span> (is-zero? n) (one)
        (multiple n (factorial (predecessor n))))))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">multiple</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (a b)
    (<span style="color: #F92672; font-weight: bold;">if</span> (is-zero? (predecessor a)) b
        (plus b (multiple (predecessor a) b)))))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">plus</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (a b)
    (<span style="color: #F92672; font-weight: bold;">if</span> (is-zero? a) b
        (plus (predecessor a) (successor b)))))
</pre>
</div>
<ul class="org-ul">
<li>2.3
</li>
</ul>
<p>
Diff-tree ::= (one) | (diff Diff-tree Diff-tree)
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">zero</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> () '(diff (one) (one))))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">negative-one</span> (<span style="color: #F92672; font-weight: bold;">lambda</span> () (list 'diff (zero) '(one))))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">is-zero?</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (n)
    (equal? n (zero))))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">successor</span>
  <span style="color: #E6DB74;">"n+1 = n - (-1)"</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (n)
    (list 'diff n (negative-one))))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">predecessor</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (n)
    (list 'diff n '(one))))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">diff-tree-plus</span>
  <span style="color: #E6DB74;">"a+b = a - (-b)"</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (a b)
    (list 'diff a (list 'diff (zero) b))))

(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">left</span> cadr)
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">right</span> caddr)
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">the number a diff-tree represented is identical to the number of left leaves</span>
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">minus the number of the right leaves</span>
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">left-minus-right-leaves</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (n)
    (<span style="color: #F92672; font-weight: bold;">cond</span>
     [(<span style="color: #F92672; font-weight: bold;">and</span> (equal? (left n) '(one))
           (equal? (right n) '(one)))
      0]
     [(equal? (left n) '(one))
      (+ 1 (left-minus-right-leaves (right n)))]
     [(equal? (left n) '(one))
      (- (left-minus-right-leaves (left n)) 1)]
     [else (+ (left-minus-right-leaves (left n))
              (left-minus-right-leaves (right n)))])))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">is-zero?</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (n)
    (zero? (left-minus-right-leaves n))))
</pre>
</div>
<ul class="org-ul">
<li>2.4
</li>
</ul>


\begin{align}
  (empty-stack) &= \lceil \Phi \rceil  \\
  (push \lceil f \rceil var) &= \lceil g \rceil  \\
  (pop ⌈ f ⌉) &= cc  \\
  (top ⌈ f ⌉) &= f(top)  \\
  (empty-stack? ⌈ f ⌉) &= dd
\end{align}

<ul class="org-ul">
<li>2.5
</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">empty-env</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> () '()))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">extend-env</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (var val env)
    (cons (cons var val)
          env)))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">apply-env</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (var env)
    (<span style="color: #F92672; font-weight: bold;">cond</span> [(equal? env (empty-env))
           (report-no-binding-found var)]
          [(<span style="color: #F92672; font-weight: bold;">and</span> (list? env)
                (pair? (car env))
                (list? (cdr env)))
           (<span style="color: #F92672; font-weight: bold;">let</span> ([saved-var (caar env)]
                 [saved-val (cdar env)]
                 [saved-env (cdr env)])
             (<span style="color: #F92672; font-weight: bold;">if</span> (eq? var saved-var)
                 saved-val
                 (apply-env var saved-env)))]
          [else (report-invalid-env env)])))

(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">report-no-binding-found</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (search-var)
    (eopl:error 'apply-env <span style="color: #E6DB74;">"No binding for ~s"</span> search-var)))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">report-invalid-env</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (env)
    (eopl:error 'apply-env <span style="color: #E6DB74;">"Bad environment: ~s"</span> env)))
</pre>
</div>
<ul class="org-ul">
<li>2.8
</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">empty-env?</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (env)
    (eqv? env (empty-env))))
</pre>
</div>
<ul class="org-ul">
<li>2.9
</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">apply-env</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (var env)
    (<span style="color: #F92672; font-weight: bold;">cond</span> [(equal? env (empty-env)) #f]
          [(<span style="color: #F92672; font-weight: bold;">and</span> (list? env)
                (pair? (car env))
                (list? (cdr env)))
           (<span style="color: #F92672; font-weight: bold;">let</span> ([saved-var (caar env)]
                 [saved-val (cdar env)]
                 [saved-env (cdr env)])
             (<span style="color: #F92672; font-weight: bold;">if</span> (eq? var saved-var)
                 #t
                 (apply-env var saved-env)))]
          [else (report-invalid-env env)])))
</pre>
</div>
<ul class="org-ul">
<li>2.10
</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">extend-env*</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (var-lst val-lst env)
    (<span style="color: #F92672; font-weight: bold;">if</span> (<span style="color: #F92672; font-weight: bold;">or</span> (null? var-lst)
            (null? val-lst))
        env
        (extend-env* (cdr var-lst) (cdr val-lst)
                     (extend-env (car var-lst) (car val-lst) env)))))
</pre>
</div>
<ul class="org-ul">
<li>2.11
</li>
</ul>
<p>
ribcage representation of environment
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">empty-env</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> () '()))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">extend-env</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (var val env)
    (cons (cons (list var) (list val)) env)))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">extend-env*</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (var-lst val-lst env)
    (cons (cons var-lst val-lst) env)))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">apply-env</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (var env)
    (<span style="color: #F92672; font-weight: bold;">cond</span>
     [(equal? env (empty-env))
      (report-no-binding-found var)]
     [else (<span style="color: #F92672; font-weight: bold;">let*</span> ([var-lst (caar env)]
                  [val-lst (cdar env)]
                  [saved-env (cdr env)]
                  [ret (search-lst var var-lst val-lst)])
             (<span style="color: #F92672; font-weight: bold;">if</span> ret ret
                 (apply-env var saved-env)))])))

(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">search-lst</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (var var-lst val-lst)
    (<span style="color: #F92672; font-weight: bold;">cond</span>
     [(<span style="color: #F92672; font-weight: bold;">or</span> (null? var-lst)
          (null? val-lst))
      #f]
     [(eqv? var (car var-lst)) (car val-lst)]
     [else (search-lst var (cdr var-lst) (cdr val-lst))])))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">report-no-binding-found</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (search-var)
    (eopl:error 'apply-env <span style="color: #E6DB74;">"No binding for ~s"</span> search-var)))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">report-invalid-env</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (env)
    (eopl:error 'apply-env <span style="color: #E6DB74;">"Bad environment: ~s"</span> env)))
</pre>
</div>
<ul class="org-ul">
<li>2.15
</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #75715E;">;;; </span><span style="color: #75715E;">constructor</span>
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">var-exp</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (var) var))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">lambda-exp</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (var lc-exp)
    (list 'lambda (list var) lc-exp)))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">app-exp</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lc-exp1 lc-exp2)
    (list lc-exp1 lc-exp2)))
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">predicates</span>
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">var-exp?</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lc-exp)
    (symbol? lc-exp)))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">lambda-exp?</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lc-exp)
    (eqv? (car lc-exp) 'lambda)))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">app-exp?</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (exp)
    (<span style="color: #F92672; font-weight: bold;">and</span> (lc-exp? (car exp))
         (lc-exp? (cadr exp)))))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">lc-exp?</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (exp)
    (<span style="color: #F92672; font-weight: bold;">or</span> (var-exp? exp)
        (lambda-exp? exp)
        (app-exp? exp))))
<span style="color: #75715E;">;;; </span><span style="color: #75715E;">extractors</span>
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">var-exp-&gt;var</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lc-exp)
    lc-exp))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">lambda-exp-&gt;bound-var</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lc-exp)
    (caadr lc-exp)))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">lambda-exp-&gt;body</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lc-exp)
    (cddr lc-exp)))

(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">app-exp-&gt;rator</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lc-exp)
    (car lc-exp)))
(<span style="color: #F92672; font-weight: bold;">define</span> <span style="color: #A6E22E;">app-exp-rand</span>
  (<span style="color: #F92672; font-weight: bold;">lambda</span> (lc-exp)
    (cadr lc-exp)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">3 Expressions</h2>
<div class="outline-text-2" id="text-4">
<p>
本章的目的实际就是用scheme来写一个program来解释执行EOPL中let语言的AST,其实就
是写一个解释器,只是这个解释器直接接受AST,而不是字符串
</p>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Some Concepts</h3>
<div class="outline-text-3" id="text-4-1">
<ol class="org-ol">
<li>AST(aka: abstract syntax tree or just syntax tree): 抽象语法树,和Concrete
syntax tree像对应,AST不包含一些细节, 比如一个if表达式,在 AST就不会包含 if
这样的关键词,因此无论你使用 if(..){..} 还是 if &#x2026; then &#x2026; fi, 还是其他,
它们的AST都是一样的
</li>
<li>scanning: 根据词法规则将字符串切分为一个一个的token
</li>
<li>parsing: 根据语法规则将scanning生成的token生成一个AST
</li>
<li>expressed value: 表达式的值
</li>
<li>denoted value: 变量所代表的值
</li>
<li>变量的声明与引用(declaration reference): lambda的形参是声明,let内的参数是
声明
</li>
<li>作用域(scope): 一个变量起作用的部分就是变量的作用域
</li>
<li>lexical depth: 词法深度,用来表示一个变量的引用与该变量声明之间的作用域的
个数,以0为开始
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">4 State</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">返回值与副作用的区别</h3>
<div class="outline-text-3" id="text-5-1">
<p>
   What’s the difference between producing a value and producing an effect?
An effect is <b>global</b>: it is seen by the entire computation. An effect affects the
entire computation (pun intended).
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">4.1 Computational Effects</h3>
<div class="outline-text-3" id="text-5-2">
<ol class="org-ol">
<li>reference: 引用,(left value)
</li>
<li>location: 包含reference指向的数据
</li>
</ol>
<p>
二者的可以这样类比:reference可以看作是url,而location可以看作是文件,文件包含
数据,而url指向该文件
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Continuation-Passing Interpreter</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Serveral Concepts</h3>
<div class="outline-text-3" id="text-6-1">
<ol class="org-ol">
<li>Context: According to wikipedia, A task context is the minimal set of
data used by this task at the point it has been interrupted
</li>
<li>Data Context: Environment is the abstraction of Data Context
</li>
<li>Control Context: Continuation is the abstraction of Control Context
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">lambda calculus</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Church Encode</h3>
<div class="outline-text-3" id="text-7-1">
<pre class="example">
true = λt.λf.t
false = λt.λf.f
if = λv.λt.λf. v t f

0 = λf.λx.x
1 = λf.λx.f x
2 = λf.λx.f (f x)
3 = λf.λx.f (f (f x))
...
add1 = λn.λf.λx. f (n f x )
add  = λn.λm.λf.λx. m f (n f x) = λn.λm.λf.λx. m add1 n
iszero = λn. n (λx. false) true
mul = λn.λm.λf.λx. n (add m) zero
</pre>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Y Combinator</h3>
<div class="outline-text-3" id="text-7-2">
<p>
假设要在lambda calculus中构造递归函数mul,那么最直观的想法就是:
</p>

<p>
mult = λn.λm.if (iszero n) 0 (add m (mult (sub1 n) m))
</p>

<p>
可是上述构造是不合法的:
</p>

<p>
mkmult0 = λt.λn.λm.if (iszero n) 0 (add m (t (sub1 n) m))
</p>

<p>
假设我们已经构造出了mult,那么 (mkmult0 mult) 就是mult了,可是实际上我们没有构
造出mult,所以mkmult0 仍然不能定义出mult
</p>

<p>
mkmult1 = λt.λn.λm.if (iszero n) 0 (add m ((t t) (sub1 n) m))
</p>

<p>
(mkmult1 mkmult1)就是mult了,这就是一个定义递归函数的常用方法了,可是这个方法
比较笨拙,因为我们每一次调用必须将mkmult1应用于自身.更好的做法应该是能将自我
应用的部分提取出来,现在我们假设有一个 <code>mk</code> 函数
</p>

<p>
mk = λt.t (mk t)
</p>

<p>
这个函数可以构造出mult: (mk mkmult0),可是 <code>mk</code> 的定义是递归的也犯了最开始定
义mul时同样的错误,所以我们使用 <code>mkmult1</code> 类似的方式来变换一下:
</p>

<p>
mkmk = λk.λt.t ((k k) t)
</p>

<p>
mk = (mkmk mkmk)
</p>

<p>
因此我们得到了一个很重要的性质:
</p>

<p>
(mkmult0 (mk mkmult0)) = (mk mkmult0)
</p>

<p>
那么 <code>(mk mkmult0)</code> 产生的函数就是 <code>mkmult0</code> 的不动点,而 <code>mk</code> 就是不动点算子,也
就是说将 <code>mk</code> 作用于一个函数就可以得到该函数的不动点, Y Combinator是一个更常
用的不动点算子:
</p>

<p>
Y = λf.(λx.f (x x)) (λx.f (x x))
</p>

<p>
这是一个Y combinator的推导过程(slideshare需翻墙):
</p>
<iframe src="http://www.slideshare.net/slideshow/embed_code/12319464"
width="427" height="356" frameborder="0" marginwidth="0" marginheight="0"
scrolling="no" style="border:1px solid #CCC;border-width:1px 1px
0;margin-bottom:5px" allowfullscreen> </iframe> <div
style="margin-bottom:5px"> <strong> <a
href="https://www.slideshare.net/yinwang0/reinventing-the-ycombinator"
title="Reinventing the Y combinator" target="_blank">Reinventing the Y
combinator</a> </strong> from <strong><a
href="http://www.slideshare.net/yinwang0" target="_blank">Ian
Wang</a></strong> </div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_comment">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
        var url = window.location.pathname;
        var disqus_identifier = url.substring(url.lastIndexOf('/')+1);
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'yuyang'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
<!-- begin footer -->
<div id="footer">
  <hr />
  <ul class="links">
    <li>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</li>
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a href="#">Back to Top</a></li>
  </ul>
</div>
<!-- end footer -->
</div>
</body>
</html>
