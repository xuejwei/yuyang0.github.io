<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-02-22 Mon 20:57 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>python笔记</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Yu Yang" />
<meta  name="keywords" content="python" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/>
<link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="site-title"><a href="/"> 编码者言 </a></h1>
        <div>
          <a href="###" id="site-nav-btn">菜单</a>
          <ul id="site-nav" class="vertical-nav mobi-hid">
            <li> <a href="/">Home</a></li>
            <li> <a href="/about.html">About</a></li>

            <li> <a href="/tags.html">Tags</a></li>

            <li> <a href="/atom.xml">RSS</a></li>
          </ul>

          <form id="site-search" method="get" action="https://google.com/search">
            <input type="hidden" name="q" value="site:yuyang0.github.io" />
            <input type="text" name="q" placeholder="Search..." />
            <button class="btn-search" type="submit">Search</button>
          </form>
          <div style="clear:both;"> </div>
        </div>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">python笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">python的编码规范</a></li>
<li><a href="#orgheadline2">python 文件处理</a></li>
<li><a href="#orgheadline3">作用域规则</a></li>
<li><a href="#orgheadline10">杂七杂八</a>
<ul>
<li><a href="#orgheadline4">除法</a></li>
<li><a href="#orgheadline5">一些内置函数的解释</a></li>
<li><a href="#orgheadline6">dir</a></li>
<li><a href="#orgheadline7">globals  And lolcals</a></li>
<li><a href="#orgheadline8">getattr,__getattr__,__getattribute__</a></li>
<li><a href="#orgheadline9">__import__(接字符串而不是name)</a></li>
</ul>
</li>
<li><a href="#orgheadline16">装饰器</a>
<ul>
<li><a href="#orgheadline11">装饰器的基本形式</a></li>
<li><a href="#orgheadline12">使用类作为装饰器(推荐的做法)</a></li>
<li><a href="#orgheadline13">使用类作为装饰器装饰类方法</a></li>
<li><a href="#orgheadline14">给装饰器添加参数</a></li>
<li><a href="#orgheadline15">functools模块</a></li>
</ul>
</li>
<li><a href="#orgheadline20">迭代器</a>
<ul>
<li><a href="#orgheadline17">迭代器的基本知识</a></li>
<li><a href="#orgheadline18">生成器generator</a></li>
<li><a href="#orgheadline19">for循环的迭代过程</a></li>
</ul>
</li>
<li><a href="#orgheadline21">with</a></li>
<li><a href="#orgheadline22">模块</a>
<ul>
<li><a href="#orgheadline23">relative import</a></li>
</ul>
</li>
<li><a href="#orgheadline31">OOP</a>
<ul>
<li><a href="#orgheadline24">基本OOP代码示例</a></li>
<li><a href="#orgheadline25">属性搜索树</a></li>
<li><a href="#orgheadline28">类的设计</a>
<ul>
<li><a href="#orgheadline26">is a</a></li>
<li><a href="#orgheadline27">has a</a></li>
</ul>
</li>
<li><a href="#orgheadline29">常见的运算符重载</a></li>
<li><a href="#orgheadline30">Descriptor</a></li>
</ul>
</li>
<li><a href="#orgheadline32">metaclass</a></li>
<li><a href="#orgheadline33">python异常</a>
<ul>
<li><a href="#orgheadline34">try &#x2026; except语句</a></li>
<li><a href="#orgheadline35">raise</a></li>
<li><a href="#orgheadline36">异常</a></li>
</ul>
</li>
<li><a href="#orgheadline37">python中文处理</a></li>
<li><a href="#orgheadline39">一些很诡异的问题</a>
<ul>
<li><a href="#orgheadline38">传引用</a></li>
</ul>
</li>
<li><a href="#orgheadline58">一些标准库的使用说明</a>
<ul>
<li><a href="#orgheadline40">python 正则表达式</a></li>
<li><a href="#orgheadline41">logging</a>
<ul>
<li><a href="#orgheadline42">基本概念</a></li>
<li><a href="#orgheadline43">logger层次关系</a></li>
<li><a href="#orgheadline44">日志输出的过程</a></li>
<li><a href="#orgheadline45">常用api</a></li>
</ul>
</li>
<li><a href="#orgheadline48">多线程</a>
<ul>
<li><a href="#orgheadline46">Thread</a></li>
<li><a href="#orgheadline47">threading</a></li>
</ul>
</li>
<li><a href="#orgheadline54">collections</a>
<ul>
<li><a href="#orgheadline49">Counter</a></li>
<li><a href="#orgheadline50">deque 双端队列</a></li>
<li><a href="#orgheadline51">defaultdict</a></li>
<li><a href="#orgheadline52">namedtuple</a></li>
<li><a href="#orgheadline53">OrderedDict</a></li>
</ul>
</li>
<li><a href="#orgheadline55">pickle</a></li>
<li><a href="#orgheadline56">json</a></li>
<li><a href="#orgheadline57">HTMLParser</a></li>
</ul>
</li>
<li><a href="#orgheadline64">一些第三方库的使用方法</a>
<ul>
<li><a href="#orgheadline59">requests</a></li>
<li><a href="#orgheadline60">pip</a></li>
<li><a href="#orgheadline61">pyquery</a></li>
<li><a href="#orgheadline62">watchdog</a></li>
<li><a href="#orgheadline63">rauth</a></li>
</ul>
</li>
<li><a href="#orgheadline67">常用工具的使用方法</a>
<ul>
<li><a href="#orgheadline65">virtualenv</a></li>
<li><a href="#orgheadline66">ipython</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">python的编码规范</h2>
<div class="outline-text-2" id="text-orgheadline1">
<ol class="org-ol">
<li>用4个空格缩进</li>
<li>每一行不超过80个字符,当一行超过80个字符时,可以用\来连接下一行,当对一个二元操作符断行时,应该将操作符留在
上一行, 对于函数定义以及调用,那么根据括号来对齐.</li>
<li>模块内容的顺序：
<ul class="org-ul">
<li>模块说明和docstring</li>
<li>import</li>
<li>__all__(optional)</li>
<li>globals and constants</li>
<li>其他定义</li>
</ul></li>
<li>一行只导入一个模块(不推荐 import sys, os)</li>
<li>模块导入顺序: 标准库, 第三方库, 自己编写的库. 三者之间用空行分割, 而且三者应该紧挨着模块字符串的后面</li>
<li>模块级别的函数定义, 类定义用2个空行分割, 类方法用一个空行分割</li>
<li>空格的添加:
<ul class="org-ul">
<li><p>
二元操作的两边各放一个空格, 但是对于有多个操作符的情况,可以只在低优先级
的操作符两边放空格
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #DFAF8F;">i</span> = i + <span style="color: #BFEBBF;">1</span>
<span style="color: #DFAF8F;">submitted</span> += <span style="color: #BFEBBF;">1</span>
<span style="color: #DFAF8F;">x</span> = x*<span style="color: #BFEBBF;">2</span> - <span style="color: #BFEBBF;">1</span>
<span style="color: #DFAF8F;">hypot2</span> = x*x + y*y
<span style="color: #DFAF8F;">c</span> = <span style="color: #DCDCCC;">(</span>a+b<span style="color: #DCDCCC;">)</span> * <span style="color: #DCDCCC;">(</span>a-b<span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li><p>
标点符号的后面放空格,前面不要放空格,在(, {, [之后以及), }, ]之前不要放空格,函数调用时函数名与左括号之间
不要放空格
</p>
<pre class="example">
Yes: spam(ham[1], {eggs: 2})
No:  spam( ham[ 1 ], { eggs: 2 } )
No:  spam (ham[1], {eggs:2})

Yes: if x == 4: print x, y; x, y = y, x
No:  if x == 4 : print x , y ; x , y = y , x

Yes: spam(1)
No:  spam (1)

Yes: dict['key'] = list[index]
No:  dict ['key'] = list [index]
</pre></li>
<li>不要在用于指定关键字参数 (keyword argument) 或默认参数值的 '=' 号周围使用空格。</li>
</ul></li>
<li>命名
<ul class="org-ul">
<li>模块名与包名: 全部用小写字母, 模块名可以添加下划线来增加可读性, 包名不建议添加下划线,名字尽量短一点,因
为有些文件系统对文件长度有要求</li>
<li>类名: 使用驼峰命名法,如果是内部类,则在前面加一个下划线</li>
<li>异常名: 异常是类, 所以使用驼峰命名法,但是必须有Error后缀</li>
<li>函数名: 必须是小写字母, 用下划线去增加可读性</li>
<li>类方法: 和函数名相同, 对于non-public函数, 可以在前面加一个下划线, 前面加两个下划线主要是避免与子类命名
冲突(一般用户命名变量不推荐使用)</li>
<li>常量名: 全部大写, 用下划线分割增加可读性</li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">python 文件处理</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
open打开文件时的选项：
</p>
<ul class="org-ul">
<li>w, w+: 如果文件已存在，那么二者都会将文件内容清除</li>
<li><p>
r+: 如果写文件，那么会从当前位置覆盖写，而不是插入，当用该模式打开文件，读
入文件内容，然后用覆盖该文件时应使用如下代码
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">with</span> <span style="color: #DCDCCC; font-weight: bold;">open</span><span style="color: #DCDCCC;">(</span>filename, <span style="color: #CC9393;">'r+'</span><span style="color: #DCDCCC;">)</span> <span style="color: #F0DFAF; font-weight: bold;">as</span>  f:
    <span style="color: #DFAF8F;">content</span> = f.read<span style="color: #DCDCCC;">()</span>
    <span style="color: #DFAF8F;">new_content</span> = do_something<span style="color: #DCDCCC;">()</span>
    f.seek<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">0</span><span style="color: #DCDCCC;">)</span>
    f.write<span style="color: #DCDCCC;">(</span>new_content<span style="color: #DCDCCC;">)</span>
    f.truncate<span style="color: #DCDCCC;">()</span>                <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#21024;&#38500;&#24403;&#21069;&#35835;&#20889;&#20301;&#32622;&#21040;&#25991;&#20214;&#26411;&#23614;&#30340;&#20869;&#23481;</span>
</pre>
</div></li>
<li>b: 在python2中，linux指定与不指定问题不大，但是建议对于二进制文件比如图片还
是指定该选项比较好，避免移植到windows出现问题，在python3中，对于文本文件，
如果不指定该选项，那么会返回unicode string， 而如果指定该选项则返回byte
string, 所以对于二进制文件,你必须指定b</li>
</ul>

<p>
遍历一个文件夹的所有文件
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> os
<span style="color: #F0DFAF; font-weight: bold;">import</span> os.path

<span style="color: #F0DFAF; font-weight: bold;">import</span> os
<span style="color: #F0DFAF; font-weight: bold;">from</span> os.path <span style="color: #F0DFAF; font-weight: bold;">import</span> join, getsize
<span style="color: #F0DFAF; font-weight: bold;">for</span> root, dirs, files <span style="color: #F0DFAF; font-weight: bold;">in</span> os.walk<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'python/Lib/email'</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">for</span> afile <span style="color: #F0DFAF; font-weight: bold;">in</span> files:
        <span style="color: #DFAF8F;">full_name</span> = os.path.join<span style="color: #DCDCCC;">(</span>root, afile<span style="color: #DCDCCC;">)</span>
        do_something<span style="color: #DCDCCC;">(</span>full_name<span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">作用域规则</h2>
<div class="outline-text-2" id="text-orgheadline3">
<ol class="org-ol">
<li>if, for, while等不会创建新的作用域, 也就是说它们不同于c中block structure.</li>
<li>每一个模块会创建一个模块作用域</li>
<li>每一个函数(包括嵌套定义的函数) 都创建一个函数作用域</li>
<li>在一个作用域内第一次赋值会创建一个新的 <b>绑定</b>, 以后对该变量的赋值都是对该
绑定的 <b>修改</b>.</li>
<li>在内层作用域可以引用外层作用域的变量, 但是你不能修改外层作用域的变量, 因为
你在在内层作用域一旦对该变量使用赋值,那么就是创建一个新的绑定, 所以为了改
变模块作用域中的变量你必须使用global来申明, 但是你永远也不能在内层函数中改
变外层函数的变量(当然你可以通过subscript或者attribute來修改可变对象的值,
只是这是引用的关系, 和作用域关系不大),这是python设计的不够好的地方.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10">杂七杂八</h2>
<div class="outline-text-2" id="text-orgheadline10">
</div><div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">除法</h3>
<div class="outline-text-3" id="text-orgheadline4">
<ul class="org-ul">
<li>X/Y: python2中的行为和C语言类似，3/2=1, 3/2.0=1.5; 在python3中，这是真除法，也就是会一直保留小数位,3/2 = 1.5</li>
<li>X//Y: 在python2以及3中都是floor除法，也就是取整数区间的左边边界，5//2 = 2, 5//-2 = -3</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">一些内置函数的解释</h3>
</div>
<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">dir</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
获得对象的所有属性,也就是顶层的那些names
</p>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">globals  And lolcals</h3>
<div class="outline-text-3" id="text-orgheadline7">
<ol class="org-ol">
<li>globals(): 返回一个字典,字典包括当前模块(也就是调用globals()的模块)的所有模块级属性, 同时还包
括'<span class="underline"><span class="underline">builtins</span></span>'属性, 还包括几个特殊变量__file__, <span class="underline"><span class="underline">package</span></span>, <span class="underline"><span class="underline">doc</span></span></li>
<li>locals(): 这个只返回局部空间(比如函数的局部变量)的变量与值的字典,注意这个字典不能修改,如果强行修改会引发
严重后果,比如解释器崩溃</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">getattr,__getattr__,__getattribute__</h3>
<div class="outline-text-3" id="text-orgheadline8">
<ol class="org-ol">
<li><p>
__getattr__只有在属性不存在时才调用,该方法用的多
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">ClassName</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__getattr__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, name<span style="color: #DCDCCC;">)</span>:
        dosomething<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #DCDCCC; font-weight: bold;">super</span><span style="color: #DCDCCC;">(</span>ClassName, <span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>.__getattr__<span style="color: #DCDCCC;">(</span>name<span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li>__getattribute__是每一次obj.attr时都会调用,所以它可以拦截所有的属性查询, 用的很少</li>
<li>getattr: 原型getattr(object, name[, default]), getattr(x, 'foobar')等价于x.foobar优势就在于getattr可以
使用字符串,注意如果是获得类实例的方法,那么self参数就可以忽略了,只需要传入除self之外的其它参数就好</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">__import__(接字符串而不是name)</h3>
<div class="outline-text-3" id="text-orgheadline9">
<p>
原型：  __import__(name[, globals[, locals[, fromlist[, level]]]])
</p>
<ul class="org-ul">
<li>fromlist： 指定需要从name中导入的属性名，一般而言也就是from module1 import attr1, attr2&#x2026;中的
attr1,attr2&#x2026; <b>这个参数一般需要指定</b></li>
<li>level: 指定使用绝对导入还是相对导入，-1是默认会同时尝试二者，0是绝对导入，正数是相当于加几个. ,比如如果
为1,那就是加一个.也就是当前目录，如果是2,那就是加两个点，在当前模块的父目录中导入，和import中的相
对导入语法类似</li>
</ul>


<div class="org-src-container">

<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">snippet 1</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> spam.ham <span style="color: #F0DFAF; font-weight: bold;">import</span> eggs, sausage <span style="color: #F0DFAF; font-weight: bold;">as</span> saus

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">snippet 2</span>
<span style="color: #DFAF8F;">_temp</span> = <span style="color: #DCDCCC; font-weight: bold;">__import__</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'spam.ham'</span>, <span style="color: #DCDCCC; font-weight: bold;">globals</span><span style="color: #BFEBBF;">()</span>, <span style="color: #DCDCCC; font-weight: bold;">locals</span><span style="color: #BFEBBF;">()</span>, <span style="color: #BFEBBF;">[</span><span style="color: #CC9393;">'eggs'</span>, <span style="color: #CC9393;">'sausage'</span><span style="color: #BFEBBF;">]</span>, -<span style="color: #BFEBBF;">1</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DFAF8F;">eggs</span> = _temp.eggs
<span style="color: #DFAF8F;">saus</span> = _temp.sausage
</pre>
</div>
<p>
两段代码等价, __import__接的是字符串
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline16" class="outline-2">
<h2 id="orgheadline16">装饰器</h2>
<div class="outline-text-2" id="text-orgheadline16">
</div><div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11">装饰器的基本形式</h3>
<div class="outline-text-3" id="text-orgheadline11">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">deco</span><span style="color: #DCDCCC;">(</span>func<span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">_deco</span><span style="color: #DCDCCC;">()</span>:
        <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"before myfunc() called."</span><span style="color: #DCDCCC;">)</span>
        func<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"  after myfunc() called."</span><span style="color: #DCDCCC;">)</span>

    <span style="color: #F0DFAF; font-weight: bold;">return</span> _deco

<span style="color: #7CB8BB;">@deco</span>
<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">myfunc</span><span style="color: #DCDCCC;">()</span>:
    <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">" myfunc() called."</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
上面的@deco 等价于 myfunc = deco(myfunc), 这就是装饰器的本质所在, 注意_deco必须与myfunc有相同的参数,因为
装饰后调用myfunc实际是调用_deco, 当然_deco可以使用*args, **kargs这样的可变参数
</p>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">使用类作为装饰器(推荐的做法)</h3>
<div class="outline-text-3" id="text-orgheadline12">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">deco</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__init__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, func<span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.func = func

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__call__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, *args, **kwargs<span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"before myfunc() called."</span><span style="color: #DCDCCC;">)</span>
        func<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"  after myfunc() called."</span><span style="color: #DCDCCC;">)</span>

<span style="color: #7CB8BB;">@deco</span>
<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">myfunc</span><span style="color: #DCDCCC;">()</span>:
    <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">" myfunc() called."</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
myfunc = deco(myfunc) 所以myfunc就是一个deco类的实例，然后myfunc(*args, **kwargs),实际就是调用类实例
的__call__方法
</p>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">使用类作为装饰器装饰类方法</h3>
<div class="outline-text-3" id="text-orgheadline13">
<p>
下面的代码也可以装饰非类方法,也就是装饰普通函数,也就意味着下面的代码可以替代2,因为如果装饰的是普通函数,
那么会直接调用该函数,所以不会触发descriptor的__get__方法
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">deco</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__init__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, func<span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.func = func

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__call__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, *args, **kwargs<span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"before myfunc() called."</span><span style="color: #DCDCCC;">)</span>
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.func<span style="color: #DCDCCC;">(</span>*args, **kwargs<span style="color: #DCDCCC;">)</span>
        <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"  after myfunc() called."</span><span style="color: #DCDCCC;">)</span>

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__get__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, obj, objtype<span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">import</span> functools
        <span style="color: #F0DFAF; font-weight: bold;">return</span> functools.partial<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>.__call__, obj<span style="color: #DCDCCC;">)</span>

<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Test</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #7CB8BB;">@deco</span>
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">myfunc</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">" myfunc() called."</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
这与2最大的区别就是使用了descriptor，也就是__get__, 之所以这么写是因为，如果像2一样，那么就没有给myfunc
传递self参数，所以python会报缺少参数的错误，下面解释一下代码运行的流程，deco装饰后，myfunc变成一个deco的
类实例，注意deco定义了__get__, 所以myfunc就变成了一个descriptor对象，当你使用test_obj.myfunc(*args,
**kwargs)调用的时候，也就触发了test_obj.myfunc的属性搜索，那么根据descriptor的规则，就变成了
myfunc.__get__(test_obj),该函数返回已将test_obj绑定到myfunc.__call__的第一个参数的partial 函数，接着这个
函数在接受*args, **kwargs参数，总之就是通过descriptor将test_obj传递给了__call__,从而消除了缺少self的问题
</p>
</div>
</div>
<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14">给装饰器添加参数</h3>
<div class="outline-text-3" id="text-orgheadline14">
<div class="org-src-container">

<pre class="src src-python"> <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">deco</span><span style="color: #DCDCCC;">(</span>arg<span style="color: #DCDCCC;">)</span>:
     <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">_deco</span><span style="color: #DCDCCC;">(</span>func<span style="color: #DCDCCC;">)</span>:
         <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__deco</span><span style="color: #DCDCCC;">()</span>:
             <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"before %s called [%s]."</span> % <span style="color: #BFEBBF;">(</span>func.<span style="color: #DCDCCC; font-weight: bold;">__name__</span>, arg<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
             func<span style="color: #DCDCCC;">()</span>
             <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"  after %s called [%s]."</span> % <span style="color: #BFEBBF;">(</span>func.<span style="color: #DCDCCC; font-weight: bold;">__name__</span>, arg<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
         <span style="color: #F0DFAF; font-weight: bold;">return</span> __deco
     <span style="color: #F0DFAF; font-weight: bold;">return</span> _deco
<span style="color: #7CB8BB;">@deco</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"mymodule"</span><span style="color: #DCDCCC;">)</span>
 <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">myfunc</span><span style="color: #DCDCCC;">()</span>:
     <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">" myfunc() called."</span><span style="color: #DCDCCC;">)</span>
<span style="color: #7CB8BB;">@deco</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"module2"</span><span style="color: #DCDCCC;">)</span>
 <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">myfunc2</span><span style="color: #DCDCCC;">()</span>:
     <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">" myfunc2() called."</span><span style="color: #DCDCCC;">)</span>
myfunc<span style="color: #DCDCCC;">()</span>
 myfunc2<span style="color: #DCDCCC;">()</span>
</pre>
</div>
<p>
需要给装饰器加参数.那么就给多添加一个嵌套函数, 这个参数可以是类以及其它对象
</p>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15">functools模块</h3>
<div class="outline-text-3" id="text-orgheadline15">
<ul class="org-ul">
<li><p>
wraps: 这个装饰器可以确保函数在装饰后属性的一致,比如上面的例子 myfunc=deco(myfunc), 那么此时
myfunc的__name__, __doc__等属性都不在是原myfunc的值了,而是_deco的值,每一次装饰之后这些函数对象的元信
息都丢失的话,那么这显然是一个大问题,而wraps可以用来应付这个问题
</p>
<div class="org-src-container">

<pre class="src src-python"> <span style="color: #F0DFAF; font-weight: bold;">import</span> functools
<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">deco</span><span style="color: #DCDCCC;">(</span>func<span style="color: #DCDCCC;">)</span>:
     <span style="color: #7CB8BB;">@functools.wraps</span><span style="color: #DCDCCC;">(</span>func<span style="color: #DCDCCC;">)</span>
     <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">_deco</span><span style="color: #DCDCCC;">()</span>:
         <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"before myfunc() called."</span><span style="color: #DCDCCC;">)</span>
         func<span style="color: #DCDCCC;">()</span>
         <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"  after myfunc() called."</span><span style="color: #DCDCCC;">)</span>
    <span style="color: #F0DFAF; font-weight: bold;">return</span> _deco
<span style="color: #7CB8BB;">@deco</span>
 <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">myfunc</span><span style="color: #DCDCCC;">()</span>:
     <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">" myfunc() called."</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
@functools.wraps(func)这行代码可以保证,通过装饰器调用后,函数__name__,
__doc__仍然和原来的函数一致
</p></li>
<li><p>
partial: 有时候你知道一个函数的一部分参数,这个时候你可以先绑定这些参数,绑
定这些参数之后会返回一个partial对象,你可以当这个对象就是一个以绑定了一些参
数的函数,就是函数式语言中的curry,partial大体上等于以下代码
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">partial</span><span style="color: #DCDCCC;">(</span>func, *args, **keywords<span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">newfunc</span><span style="color: #DCDCCC;">(</span>*fargs, **fkeywords<span style="color: #DCDCCC;">)</span>:
        <span style="color: #DFAF8F;">newkeywords</span> = keywords.copy<span style="color: #DCDCCC;">()</span>
        newkeywords.update<span style="color: #DCDCCC;">(</span>fkeywords<span style="color: #DCDCCC;">)</span>
        <span style="color: #F0DFAF; font-weight: bold;">return</span> func<span style="color: #DCDCCC;">(</span>*<span style="color: #BFEBBF;">(</span>args + fargs<span style="color: #BFEBBF;">)</span>, **newkeywords<span style="color: #DCDCCC;">)</span>
    <span style="color: #DFAF8F;">newfunc.func</span> = func
    <span style="color: #DFAF8F;">newfunc.args</span> = args
    <span style="color: #DFAF8F;">newfunc.keywords</span> = keywords
    <span style="color: #F0DFAF; font-weight: bold;">return</span> newfunc
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline20" class="outline-2">
<h2 id="orgheadline20">迭代器</h2>
<div class="outline-text-2" id="text-orgheadline20">
</div><div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17">迭代器的基本知识</h3>
<div class="outline-text-3" id="text-orgheadline17">
<p>
迭代器对象是序列对象的一般化,每一个迭代器对象都有一个next方法,该方法每调用一次都会返回下一个元素,当没有元素
可返回时要触发StopIteration异常,这就是迭代对象的实质了
</p>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18">生成器generator</h3>
<div class="outline-text-3" id="text-orgheadline18">
<p>
从大多数方面看生成器函数和普通函数一致,它们二者最大的不同时,普通函数是直接通过return返回一个值,而生成器函
数是通过yield返回一个迭代器对象,所以每一个生成器函数调用后都是返回一个迭代器对象,这是本质的区别
</p>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19">for循环的迭代过程</h3>
<div class="outline-text-3" id="text-orgheadline19">
<p>
for item in obj语句的执行过程其实是这样
</p>
<ol class="org-ol">
<li>先运行iter(obj) 获得迭代器对象 iter_obj</li>
<li>重复的调用iter_obj.next() 直到出现StopIteration异常</li>
<li>如果上述两步已成功,那么for循环就结束了,如果上述两步没成功,这意味着obj不支持迭代协议,那么for就会尝试使用
下标来遍历那么会使用下标来遍历,也就是从0开始每一轮循环都对下标加一,而且每一轮循环都使用obj[i] 来访问元
素,直到触发异常</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline21" class="outline-2">
<h2 id="orgheadline21">with</h2>
<div class="outline-text-2" id="text-orgheadline21">
<p>
基本模型：
</p>
<pre class="example">
with exp as name:
    body
</pre>
<p>
先对exp求值得到val，然后调用val的__enter__ 方法，最后将val绑定到name，接着运
行body，在要退出body时运行val的__exit__方法。File对象已经自带了这两个特殊方法，
所以打开文件时，with用的很多。
</p>
</div>
</div>
<div id="outline-container-orgheadline22" class="outline-2">
<h2 id="orgheadline22">模块</h2>
<div class="outline-text-2" id="text-orgheadline22">
<p>
模块的_X与__all__: 当调用from XX import * 时, 如果指定了__all__, 那么就只导
入__all__中的名字,如果没指定__all__,那么导入所有除了以下划线开头的全部模块级
名字, 也就是说不会导入 _X 这样的名字
</p>
</div>
<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23">relative import</h3>
<div class="outline-text-3" id="text-orgheadline23">
<p>
相对导入必须使用from xxx import yyy 的形式, 而且xxx必须以点号开头, import
xxx 的形式都是绝对导入, python默认是绝对导入,也就是搜索sys.path, 一般来说
sys.path的第一项就是主模块的所在的目录,相对导入需要以下的语法:对于如下的一个
目录结构
</p>
<pre class="example">
package/
 __init__.py
 subpackage1/
     __init__.py
     moduleX.py
     moduleY.py
 subpackage2/
     __init__.py
     moduleZ.py
 moduleA.py
</pre>
<p>
假设在moduleX.py or subpackage1/__init__.py中，那么下列的相对导入是合法的
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> .moduleY <span style="color: #F0DFAF; font-weight: bold;">import</span> spam
<span style="color: #F0DFAF; font-weight: bold;">from</span> .moduleY <span style="color: #F0DFAF; font-weight: bold;">import</span> spam <span style="color: #F0DFAF; font-weight: bold;">as</span> ham
<span style="color: #F0DFAF; font-weight: bold;">from</span> . <span style="color: #F0DFAF; font-weight: bold;">import</span> moduleY
<span style="color: #F0DFAF; font-weight: bold;">from</span> ..subpackage1 <span style="color: #F0DFAF; font-weight: bold;">import</span> moduleY
<span style="color: #F0DFAF; font-weight: bold;">from</span> ..subpackage2.moduleZ <span style="color: #F0DFAF; font-weight: bold;">import</span> eggs
<span style="color: #F0DFAF; font-weight: bold;">from</span> ..moduleA <span style="color: #F0DFAF; font-weight: bold;">import</span> foo
<span style="color: #F0DFAF; font-weight: bold;">from</span> ...package <span style="color: #F0DFAF; font-weight: bold;">import</span> bar
<span style="color: #F0DFAF; font-weight: bold;">from</span> ...sys <span style="color: #F0DFAF; font-weight: bold;">import</span> path
</pre>
</div>
<p>
一个点代表当前文件所在的目录，两个点代表当前文件所在目录的父目录，以此类推，
注意相对导入使用__name__属性实现的，所以对于执行模块必须小心，因为他的__name__属
性是__main__, 所以这些模块中不能使用相对导入
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline31" class="outline-2">
<h2 id="orgheadline31">OOP</h2>
<div class="outline-text-2" id="text-orgheadline31">
</div><div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24">基本OOP代码示例</h3>
<div class="outline-text-3" id="text-orgheadline24">
<p>
类,类的实例和模块都只是一个命名空间,命名空间的属性都可以修改,所以非常灵活,对于基于类的对象而言,可以使用dir内
置函数来查看命名空间, <b>类与类的实例都是对象,二者都是使用字典对象实现的命名空间,二者的__dict__属性基本就是命名空间
字典</b>, 看如下代码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Test</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #CC9393;">"""</span>
<span style="color: #CC9393;">    a Test Class</span>
<span style="color: #CC9393;">    """</span>
    <span style="color: #DFAF8F;">val1</span> = <span style="color: #BFEBBF;">1</span>
    <span style="color: #DFAF8F;">val2</span> = <span style="color: #BFEBBF;">2</span>
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__init__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, arg1, arg2<span style="color: #DCDCCC;">)</span>:
        <span style="color: #CC9393;">"""</span>
<span style="color: #CC9393;">        """</span>
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.arg1 = arg1
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.arg2 = arg2

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">display</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #CC9393;">"""</span>
<span style="color: #CC9393;">        """</span>
        <span style="color: #F0DFAF; font-weight: bold;">print</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.arg1, <span style="color: #F0DFAF; font-weight: bold;">self</span>.arg2

<span style="color: #DFAF8F;">obj1</span> = Test<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">1</span>, <span style="color: #BFEBBF;">2</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> <span style="color: #DCDCCC; font-weight: bold;">dir</span><span style="color: #DCDCCC;">(</span>Test<span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> <span style="color: #DCDCCC; font-weight: bold;">dir</span><span style="color: #DCDCCC;">(</span>obj1<span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
val1, val2, <span class="underline"><span class="underline">init</span></span>, display都是类Test本身的属性, 而arg1, arg2就是类实例(obj1)的属性,实际上self产生的就是
类实例对象的属性, 当然类的实例也会继承
类的属性
</p>
</div>
</div>
<div id="outline-container-orgheadline25" class="outline-3">
<h3 id="orgheadline25">属性搜索树</h3>
<div class="outline-text-3" id="text-orgheadline25">
<p>
当调用obj.attr时,python有一个属性的搜索过程,比如下面的代码
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">D1</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">pass</span>

<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">D2</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">pass</span>

<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">D3</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">pass</span>

<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">C1</span><span style="color: #DCDCCC;">(</span>D1, D2<span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">pass</span>

<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">C2</span><span style="color: #DCDCCC;">(</span>D3<span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">pass</span>

<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">B</span><span style="color: #DCDCCC;">(</span>C1, C2<span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">pass</span>

<span style="color: #DFAF8F;">a1</span> = B<span style="color: #DCDCCC;">()</span>
<span style="color: #DFAF8F;">a2</span> = B<span style="color: #DCDCCC;">()</span>
</pre>
</div>
<p>
上面的代码会构成一颗属性搜索树:
</p>

<div class="figure">
<p><img src="static/img/attribute-search-tree.png" alt="attribute-search-tree.png" />
</p>
</div>

<p>
因为类本身也是对象,所以类本身也有属性,类的属性就是类的方法,以及类的变量, 比如当调用a1.x时,那么搜索的过程就
是这样的: a1, B, C1, D1, D2, C2, D3注意这是深度优先搜索,python的经典类与新式类都是这种搜索模式，但是新式类
有一个diamond pattern，也就是钻石模式，这种模式下有一个以上的超类会通往相同的更高层次的超类，这时候会使用
广度优先搜索(只是有相同超类的那一部分)，举个例子：
</p>

<div class="figure">
<p><img src="static/img/diamond-pattern.png" alt="diamond-pattern.png" />
</p>
</div>

<p>
如上图所示，如果C2有个w属性，D2也有个w属性，那么当使用a1.w进行属性搜索时，如果使用深度优先搜索，那么会得到
D2.w， 但是C2是D2的子类，并且重载了w属性，这种情况下应该用子类的属性也就是C2的w属性，钻石继承就是为这种情
况准备的，在这种情况下，在C1,D2, C2会使用广度优先算法搜索，这样就可以先得到C2.w .这个特例需要注意
</p>
</div>
</div>
<div id="outline-container-orgheadline28" class="outline-3">
<h3 id="orgheadline28">类的设计</h3>
<div class="outline-text-3" id="text-orgheadline28">
</div><div id="outline-container-orgheadline26" class="outline-4">
<h4 id="orgheadline26">is a</h4>
<div class="outline-text-4" id="text-orgheadline26">
<p>
如何现实中两个事物是is a的关系，那么就应该用继承，比如teacher is a person，那么Teacher就应该继承Person
</p>
</div>
</div>
<div id="outline-container-orgheadline27" class="outline-4">
<h4 id="orgheadline27">has a</h4>
<div class="outline-text-4" id="text-orgheadline27">
<p>
比如一个商店有商品，有营业员，有顾客，那么商店与商品，营业员，顾客就是has a的关系，这时候应该使用组合，也
就是说商店是一个容器，在该容器对象的构造函数中创建营业员对象，创建商品对象，创建顾客对象，具体到python就
是在__init__中创建这些对象
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29">常见的运算符重载</h3>
<div class="outline-text-3" id="text-orgheadline29">
<ol class="org-ol">
<li>__getattr__ <span class="underline"><span class="underline">setattr___使用obj.attr时如果该属性obj中没有attr属性，这时会调用__getattr</span></span>, __setattr___会
拦截所有的属性赋值，也就是obj.attr = val这样的语句都等价于obj.__setattr___('attr', val)，这是
和__getattr__不同的地方，要特别注意</li>
<li>__getitem__ <span class="underline"><span class="underline">setitem_</span></span>
当出现x[i], x[i] = val, 会分别调用上述方法， 当使用for 迭代时会先尝试__iter__, 如果行不通，那么就使用索
引，也就是用不断递增的索引调用__getitem__, 直到出现IndexError</li>
<li>__iter__
必须返回一个迭代器对象，一个拥有next方法的对象就是迭代器对象，如果使用for 在该对象上迭代，它会先使用
iter内置函数来调用__iter__ 方法获得迭代器对象，然后重复的调用该迭代器对象的next方法，直到该next方法产生
StopIteration异常。</li>
<li>__call__
将类实例作为函数调用时就是使用的该方法，比如obj是一个类实例，那么obj('a', 'b')等价于
obj.__call__('a','b'),这是一个很常用的方法</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline30" class="outline-3">
<h3 id="orgheadline30">Descriptor</h3>
<div class="outline-text-3" id="text-orgheadline30">
<p>
任何对象只要定义了__get__, <span class="underline"><span class="underline">set</span></span>, __del__三者之一，那么就是descriptor，这
是一份不错的<a href="http://docs.python.org/2/howto/descriptor.html">tutorial</a>， 示例代码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">RevealAccess</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #CC9393;">"""A data descriptor that sets and returns values</span>
<span style="color: #CC9393;">       normally and prints a message logging their access.</span>
<span style="color: #CC9393;">    """</span>

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__init__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, initval=<span style="color: #BFEBBF;">None</span>, name=<span style="color: #CC9393;">'var'</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.val = initval
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.name = name

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__get__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, obj, objtype<span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">print</span> <span style="color: #CC9393;">'Retrieving'</span>, <span style="color: #F0DFAF; font-weight: bold;">self</span>.name
        <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.val

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__set__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, obj, val<span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">print</span> <span style="color: #CC9393;">'Updating'</span> , <span style="color: #F0DFAF; font-weight: bold;">self</span>.name
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.val = val

<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">MyClass</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #DFAF8F;">x</span> = RevealAccess<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">10</span>, <span style="color: #CC9393;">'var "x"'</span><span style="color: #DCDCCC;">)</span>
    <span style="color: #DFAF8F;">y</span> = <span style="color: #BFEBBF;">5</span>
</pre>
</div>
<p>
输出
</p>
<pre class="example">
&gt;&gt;&gt; m = MyClass()
&gt;&gt;&gt; m.x
Retrieving var "x"
10
&gt;&gt;&gt; m.x = 20
Updating var "x"
&gt;&gt;&gt; m.x
Retrieving var "x"
20
&gt;&gt;&gt; m.y
5
</pre>
<p>
上例中 m.x 是一个descriptor，因为它是RevealAccess的类实例，而该类定义了__get__与__set__,所以 m.x 实际上等价
于 x.__get__(m)
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline32" class="outline-2">
<h2 id="orgheadline32">metaclass</h2>
<div class="outline-text-2" id="text-orgheadline32">
<p>
在python中类也是对象，生成instance的叫class，生成class的就叫metaclass。type就是
python中内建的一个metaclass
</p>
</div>
</div>
<div id="outline-container-orgheadline33" class="outline-2">
<h2 id="orgheadline33">python异常</h2>
<div class="outline-text-2" id="text-orgheadline33">
<p>
只说明基于类的异常, 老版的python中基于字符串的异常不考虑
</p>
</div>
<div id="outline-container-orgheadline34" class="outline-3">
<h3 id="orgheadline34">try &#x2026; except语句</h3>
<div class="outline-text-3" id="text-orgheadline34">
<pre class="example">
try:
    main-block
except class1:
    handler1
except class2, instance:
    handler2
except (class3, class4):
    handler3
except (class5, class6), instance:
    handler4
except:
    handler5
else:
    else-block finally: finally-block
</pre>
<p>
python2.5以后版本才可以else,finally混在一起,执行try 中语句块时如果没有出现异常,那么就执行else 语句块,如果出
现了异常,那么就从上到下的匹配ecxept子句,最后执行第一个匹配的except 语句块, finally是无论是否发生异常,以及无
论是否捕捉了异常都会执行的
</p>
</div>
</div>
<div id="outline-container-orgheadline35" class="outline-3">
<h3 id="orgheadline35">raise</h3>
<div class="outline-text-3" id="text-orgheadline35">
<p>
raise语句的几种形式
</p>
<ol class="org-ol">
<li>raise : 重新触发上一次产生的异常</li>
<li>raise instance  : 触发为name的异常</li>
<li>raise class, instance : 和2类似,只是data是额外数据</li>
</ol>
<p>
<b>上述的instance应该是一个异常类的实例</b>,目前第二种最常用,为了兼容raise instance还有以下的几种衍生形式
</p>
<ul class="org-ul">
<li>raise class : 等同于 raise class()</li>
<li>raise class, arg :等同于raise class(arg)</li>
<li>raise class, (arg1, arg2,&#x2026;) : 等同于raise class(arg1, arg2,&#x2026;)</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline36" class="outline-3">
<h3 id="orgheadline36">异常</h3>
<div class="outline-text-3" id="text-orgheadline36">
<p>
异常都是类, exceptions must be old-style classes or derived from BaseException.也就是说,要么是老式类,要么
是BaseException的子类,实践中用户自定义的类最好继承于Exception,并且必须以Error结尾, <b>注意except语句是基于超
类匹配的</b>
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline37" class="outline-2">
<h2 id="orgheadline37">python中文处理</h2>
<div class="outline-text-2" id="text-orgheadline37">
<p>
中文处理一直是一个比较棘手的问题,各种乱码一直让程序员苦不堪言,这里主要介绍
python中文处理的一般原则, 先介绍几个基本概念(强烈建议看看这篇<a href="http://nedbatchelder.com/text/unipain.html">文章</a>):
</p>
<ol class="org-ol">
<li>unicode: 简单点说你可以将unicode看成一种映射,地球上的每一个符号都在unicode
中有一个数(准确的说叫code point)与之对应</li>
<li>utf8, utf16: 刚刚说了地球上的每一个符号在unicode中有一个数与之对应,那么这
个数如何存储在计算机上呢?utf8, utf16, utf32就是存储策略</li>
<li>big5, gb2312等: 这些都是各个地区自行发明的双字节码,也就是两个字节代表一个
符号</li>
</ol>
<p>
python字符处理的基本概念:
</p>
<ol class="org-ol">
<li>byte string: 字节流, utf8,utf16, gb2312等编码后得到的string都是字节流,通过
decode方法可以得到unicode string</li>
<li>unicode string: unicode字符串的每一个字符都是一个code point, 它可以通过
encode方法转换为各种byte string</li>
</ol>

<p>
因此python中文处理的实质就是在byte string与unicode string之间来回转换, 因为
python解释器在解释python源文件时,也是需要编码信息的,所以在文件的前两行必须指
定编码信息(coding:utf8), <b>指定的编码必须与python源文件保存时的编码一致</b>
</p>

<p>
python2与python3的区别:
</p>
<ol class="org-ol">
<li><p>
python2中字面字符串是byte string, 而3中是unicode string
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #DFAF8F;">ss</span> = <span style="color: #CC9393;">'&#20320;&#22909;'</span>                     <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">python2&#20026;byte string, python3&#20026;unicode string</span>
<span style="color: #DFAF8F;">ss</span> = u<span style="color: #CC9393;">'&#20320;&#22909;'</span>                    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">python2&#24471;&#21040;unicode string</span>
<span style="color: #DFAF8F;">ss</span> = b<span style="color: #CC9393;">'&#20320;&#22909;'</span>                    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">python3&#24471;&#21040;byte string</span>
</pre>
</div></li>
<li><p>
对二者名称不同
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">category</th>
<th scope="col" class="org-left">python2</th>
<th scope="col" class="org-left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">byte string</td>
<td class="org-left">str</td>
<td class="org-left">bytes</td>
</tr>

<tr>
<td class="org-left">unicode string</td>
<td class="org-left">unicode</td>
<td class="org-left">str</td>
</tr>
</tbody>
</table></li>
<li>读取文件时,python2得到byte string, 而python3调用open时如果指定了b则得到
byte string, 如果没有指定b, 那么就会使用local.getpreferredencoding()返回的
编码方式来decode,然后得到unicode string. python3中调用open时有一个可选参数
来指定解码方式..</li>
<li>混合时的处理方式不同,如一个byte string与一个unicode string相加,那么python2
会使用sys.getdefaultencoding()返回的编码方式来decode那个byte string, 然后
与unicode string相加得到一个unicode string,但是python3会返回异常因为
python3不允许二者混合.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline39" class="outline-2">
<h2 id="orgheadline39">一些很诡异的问题</h2>
<div class="outline-text-2" id="text-orgheadline39">
</div><div id="outline-container-orgheadline38" class="outline-3">
<h3 id="orgheadline38">传引用</h3>
<div class="outline-text-3" id="text-orgheadline38">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #DFAF8F;">gg</span> = <span style="color: #BFEBBF;">None</span>
<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">test</span><span style="color: #DCDCCC;">(</span>aa=<span style="color: #BFEBBF;">{}</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">print</span> aa
    <span style="color: #F0DFAF; font-weight: bold;">global</span> gg
    <span style="color: #DFAF8F;">gg</span> = aa

test<span style="color: #DCDCCC;">()</span>
<span style="color: #DFAF8F;">gg</span><span style="color: #DCDCCC;">[</span><span style="color: #CC9393;">"hello"</span><span style="color: #DCDCCC;">]</span> = <span style="color: #CC9393;">"world"</span>
test<span style="color: #DCDCCC;">()</span>
</pre>
</div>
<p>
第一次调用test, aa是{}, 第二次调用就是{"hello": "world"}了, 所以默认参数可是
可变对象时,要特别注意, 一定要确定是否需要使用copy.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline58" class="outline-2">
<h2 id="orgheadline58">一些标准库的使用说明</h2>
<div class="outline-text-2" id="text-orgheadline58">
</div><div id="outline-container-orgheadline40" class="outline-3">
<h3 id="orgheadline40">python 正则表达式</h3>
<div class="outline-text-3" id="text-orgheadline40">
<p>
python的正则表达式是通过re这个标准库支持的,这是一篇写的不错的<a href="https://www.evernote.com/shard/s89/sh/8d66ae55-5f2e-4a68-b11d-c8ae8ad3de56/00bfb7913d34061da0083d8286ff1592">文章</a>, 我可耻的用evernote保存下来
了,上面有原文章的连接.
</p>
</div>
</div>
<div id="outline-container-orgheadline41" class="outline-3">
<h3 id="orgheadline41">logging</h3>
<div class="outline-text-3" id="text-orgheadline41">
<p>
和log4j类似,先说几个基本概念
</p>
</div>
<div id="outline-container-orgheadline42" class="outline-4">
<h4 id="orgheadline42">基本概念</h4>
<div class="outline-text-4" id="text-orgheadline42">
<ol class="org-ol">
<li>Logger: 用户程序主要调用的就是该类的实例的方法</li>
<li>Handler:　指定日志应该保存到何处，比如console,file等等.</li>
<li>Filters: 指定过滤条件,他可以确定哪些日志输出</li>
<li>Formatters: 确定日志格式的</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline43" class="outline-4">
<h4 id="orgheadline43">logger层次关系</h4>
<div class="outline-text-4" id="text-orgheadline43">
<p>
获得logger一般使用 <code>logging.getLogger</code> 这个api, 它会接受一个name参数, name
如果不指定那么获得root logger, 假设如下代码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> logging

<span style="color: #DFAF8F;">root</span> = logging.getLogger<span style="color: #DCDCCC;">()</span>
<span style="color: #DFAF8F;">logger1</span> = logging.getLogger<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"aa"</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DFAF8F;">logger2</span> = logging.getLogger<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"aa.bb"</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
<b>root是所有logger的父logger</b>, 所以root是logger1的父logger, logger1又是
logger2的父logger, 实际上就是将logger像python的模块那样建立层次结构, 子
logger的消息会传递给父logger, 所以你运行这行代码 <code>logger2.info("hello..")</code>,
那么消息也会传递到logger1, root, 如果这两个logger的设置允许输出消息,那么该
消息可能logger2,logger1,root分别输出
</p>
</div>
</div>
<div id="outline-container-orgheadline44" class="outline-4">
<h4 id="orgheadline44">日志输出的过程</h4>
<div class="outline-text-4" id="text-orgheadline44">
<p>
假设你运行 <code>logger.info("hello")</code>, 那么这条消息如何输出呢?
</p>
<ol class="org-ol">
<li>如果logger的level比info高,那么不输出, 如果有注册的filter返回false那么不
输出.</li>
<li>将消息发送给注册在logger上的所有handler,有handler来局定消息如何处理</li>
<li>对单个handler而言,如果hander的level比info高,那么不输出,有注册的filter返
回false那么不输出,否则就输出</li>
</ol>
<p>
<b>不管logger是否输出该消息,该消息都会发往父logger.</b>
</p>
</div>
</div>
<div id="outline-container-orgheadline45" class="outline-4">
<h4 id="orgheadline45">常用api</h4>
<div class="outline-text-4" id="text-orgheadline45">
<ol class="org-ol">
<li>logging.basicConfig: 用来设置root logger的handler, 如果发现handler已设置,那
么什么也不做.</li>
<li>logging.getLogger: 用来创建logger, 如果参数为空,那么返回root logger.</li>
</ol>
<p>
logger对象的方法:
</p>
<ol class="org-ol">
<li><code>logger.debug(msg, *args, **kwargs)</code>: msg是字符串,其中可以包含%s, %d这样
的格式化信息, args包含提供给msg的字符格式化参数, kwags中有两个key会检查:
<ul class="org-ul">
<li>exc_info: 如果为True, 那么logger会调用 <code>sys.exc_info</code> 来获得一个记录异
常信息的三元组, 接着就会将三元组记录的异常调用栈记录进日志, 注意 <b>只在
except语句块中有效</b>, 因为你必须在处理异常时, sys.exc_info才能获得调用栈.
当然你可以明确的指定一个三元组, 而不是简单的指定True, 这样logger就会使
用你指定的三元组的异常信息,而不是调用 <code>sys.exc_info</code> 来获得, 因此也就
不存在只在except块有效的限制.</li>
<li>extra: 指定参数来初始化log record, 可以用它来修改本条日志的一些格式</li>
</ul></li>
<li>logger.info</li>
<li>logger.warning</li>
<li>logger.error</li>
<li>logger.critical</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline48" class="outline-3">
<h3 id="orgheadline48">多线程</h3>
<div class="outline-text-3" id="text-orgheadline48">
</div><div id="outline-container-orgheadline46" class="outline-4">
<h4 id="orgheadline46">Thread</h4>
</div>
<div id="outline-container-orgheadline47" class="outline-4">
<h4 id="orgheadline47">threading</h4>
<div class="outline-text-4" id="text-orgheadline47">
<p>
threading是一个更高层的模块，它使用更加方便，所以一般情况都是使用该模块
</p>
<ol class="org-ol">
<li>threading.Thread: 要创建一个线程，那么需要先创建threading.Thread的子类，并且重写它的run方法，每一个
Thread对象都要调用start方法，该方法启动线程，该线程会运行该对象的run方法
daemon： 如果已经没有活动的non-daemon(daemon=False)线程的话, 整个进程都会退出,所以经常将子线程的daemon
设为True,并且子线程做成一个while True的死循环,这样如果主线程退出,那么整个进程都会退出,那些死循环的子线
程自然也会退出</li>
<li><p>
Queue: 同步队列
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> Queue <span style="color: #F0DFAF; font-weight: bold;">import</span> Queue
<span style="color: #DFAF8F;">q</span> = Queue<span style="color: #DCDCCC;">()</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">thread1</span>
<span style="color: #DFAF8F;">item</span> = q.get<span style="color: #DCDCCC;">()</span>
do_something<span style="color: #DCDCCC;">(</span>item<span style="color: #DCDCCC;">)</span>
q.task_done<span style="color: #DCDCCC;">()</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">main thread</span>
q.join<span style="color: #DCDCCC;">()</span>
</pre>
</div>
<p>
实际上task_done就是将内部的计数器减一, 而put会将内部的计数器加1,然后join会测试如果内部的计数器为0就返
回,不为0就阻塞
</p></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline54" class="outline-3">
<h3 id="orgheadline54">collections</h3>
<div class="outline-text-3" id="text-orgheadline54">
</div><div id="outline-container-orgheadline49" class="outline-4">
<h4 id="orgheadline49">Counter</h4>
<div class="outline-text-4" id="text-orgheadline49">
<p>
字典的子类，可以用于统计可迭代对象中重复元素出现的次数,这是<a href="http://docs.python.org/2/library/collections.html#counter-objects">文档</a>
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> collections <span style="color: #F0DFAF; font-weight: bold;">import</span> Counter
<span style="color: #DFAF8F;">cn_str</span> = Counter<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'hello world'</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> cn_str

<span style="color: #DFAF8F;">cn_list</span> = Counter<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">[</span><span style="color: #CC9393;">'red'</span>, <span style="color: #CC9393;">'blue'</span>, <span style="color: #CC9393;">'red'</span>, <span style="color: #CC9393;">'green'</span>, <span style="color: #CC9393;">'blue'</span>, <span style="color: #CC9393;">'blue'</span><span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> cn_list

<span style="color: #DFAF8F;">cn_dict</span> = Counter<span style="color: #DCDCCC;">(</span>cats=<span style="color: #BFEBBF;">4</span>, dogs=<span style="color: #BFEBBF;">8</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> cn_dict
</pre>
</div>

<pre class="example">
Counter({'l': 3, 'o': 2, ' ': 1, 'e': 1, 'd': 1, 'h': 1, 'r': 1, 'w': 1})
Counter({'blue': 3, 'red': 2, 'green': 1})
Counter({'dogs': 8, 'cats': 4})
</pre>

<p>
Counter除了有dict的方法外，还有几个特有的方法
</p>
<ol class="org-ol">
<li>elements(): 返回可迭代对象，比如调用cn_list.elements() 就会返回['red', 'blue', 'red', 'green',
'blue', 'blue']</li>
<li>most_common([n]) : 根据字典色value从大到小排出n个item组成一个list</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline50" class="outline-4">
<h4 id="orgheadline50">deque 双端队列</h4>
<div class="outline-text-4" id="text-orgheadline50">
<p>
可以从左边或者右边添加或者删除元素,这是<a href="http://docs.python.org/2/library/collections.html#deque-objects">文档</a> ,主要有append,appendleft(单个元素),extend,extendleft(可迭代对
象),pop, popleft等等
</p>
</div>
</div>

<div id="outline-container-orgheadline51" class="outline-4">
<h4 id="orgheadline51">defaultdict</h4>
<div class="outline-text-4" id="text-orgheadline51">
<p>
提供了一个default_factory属性,通过初始化defaultdict实例时对该属性赋值,那么以后如果出现key不存在的情况,不
会出现KeyError,而是调用这个默认工厂函数,然后返回该工厂函数的返回值,这是<a href="http://docs.python.org/2/library/collections.html#defaultdict-objects">文档</a> ,这是几段代码示例:
</p>
<pre class="example">
# 以list 作为default_factory
&gt;&gt;&gt; s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; for k, v in s:
...     d[k].append(v)
...
&gt;&gt;&gt; d.items()
[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]

# 以整数作为default_factory
&gt;&gt;&gt; s = 'mississippi'
&gt;&gt;&gt; d = defaultdict(int)
&gt;&gt;&gt; for k in s:
...     d[k] += 1
...
&gt;&gt;&gt; d.items()
[('i', 4), ('p', 2), ('s', 4), ('m', 1)]
</pre>
</div>
</div>
<div id="outline-container-orgheadline52" class="outline-4">
<h4 id="orgheadline52">namedtuple</h4>
<div class="outline-text-4" id="text-orgheadline52">
<p>
一个tuple的子类,可以给tuple的每一项添加一个名字,以后就可以通过 X.y这样的方式来访问了,看代码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> collections <span style="color: #F0DFAF; font-weight: bold;">import</span> namedtuple

<span style="color: #DFAF8F;">Point</span> = namedtuple<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'Point'</span>, <span style="color: #BFEBBF;">[</span><span style="color: #CC9393;">'x'</span>, <span style="color: #CC9393;">'y'</span><span style="color: #BFEBBF;">]</span>, verbose=<span style="color: #BFEBBF;">False</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DFAF8F;">p</span> = Point<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">11</span>, y=<span style="color: #BFEBBF;">22</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> p

<span style="color: #DFAF8F;">s</span> = p<span style="color: #DCDCCC;">[</span><span style="color: #BFEBBF;">0</span><span style="color: #DCDCCC;">]</span> + p<span style="color: #DCDCCC;">[</span><span style="color: #BFEBBF;">1</span><span style="color: #DCDCCC;">]</span>                 <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">like normal tuple</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> s

<span style="color: #DFAF8F;">s</span> = p.x + p.y
<span style="color: #F0DFAF; font-weight: bold;">print</span> s
</pre>
</div>

<pre class="example">
Point(x=11, y=22)
33
33
</pre>
<p>
上述代码代表一个点,点有x,y两个值,要访问点的x,可以通过p.x 或者 <code>p[0]</code> (也就是和普通的tuple一样)
</p>
</div>
</div>
<div id="outline-container-orgheadline53" class="outline-4">
<h4 id="orgheadline53">OrderedDict</h4>
<div class="outline-text-4" id="text-orgheadline53">
<p>
OrderedDict是dict的子类,它会记住key插入的顺序,默认的dict是会排序的, 比如下面的代码
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> collections <span style="color: #F0DFAF; font-weight: bold;">import</span> OrderedDict
<span style="color: #DFAF8F;">l</span> = <span style="color: #DCDCCC;">[</span><span style="color: #BFEBBF;">(</span><span style="color: #CC9393;">'b'</span>, <span style="color: #BFEBBF;">3</span><span style="color: #BFEBBF;">)</span>, <span style="color: #BFEBBF;">(</span><span style="color: #CC9393;">'f'</span>, <span style="color: #BFEBBF;">2</span><span style="color: #BFEBBF;">)</span>, <span style="color: #BFEBBF;">(</span><span style="color: #CC9393;">'a'</span>, <span style="color: #BFEBBF;">1</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">]</span>
<span style="color: #DFAF8F;">d</span> = <span style="color: #DCDCCC; font-weight: bold;">dict</span><span style="color: #DCDCCC;">(</span>l<span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> d

<span style="color: #DFAF8F;">od</span> = OrderedDict<span style="color: #DCDCCC;">(</span>l<span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> od
</pre>
</div>

<pre class="example">
{'a': 1, 'b': 3, 'f': 2}
OrderedDict([('b', 3), ('f', 2), ('a', 1)])
</pre>
<p>
popitem(last=True): last为True,那么就是LIFO, 比如上例就是先弹出(a, 1) 然后(f, 2), 如果last为False,那么就
是FIFO
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline55" class="outline-3">
<h3 id="orgheadline55">pickle</h3>
<div class="outline-text-3" id="text-orgheadline55">
<ul class="org-ul">
<li>dump(self, obj, file) 将对象序列化到文件</li>
<li>dumps(self, obj)      会返回序列化的字符串</li>
<li>load(file)      从文件加载对象</li>
<li>loads(str)      从字符串加载对象</li>
</ul>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> pickle
<span style="color: #DFAF8F;">d</span> = <span style="color: #DCDCCC;">{</span><span style="color: #CC9393;">'tag'</span>:<span style="color: #CC9393;">'django'</span><span style="color: #DCDCCC;">}</span>
<span style="color: #F0DFAF; font-weight: bold;">with</span> <span style="color: #DCDCCC; font-weight: bold;">open</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'aa.pickle'</span>, <span style="color: #CC9393;">'wb'</span><span style="color: #DCDCCC;">)</span> <span style="color: #F0DFAF; font-weight: bold;">as</span> fp:
    pickle.dump<span style="color: #DCDCCC;">(</span>d, fp<span style="color: #DCDCCC;">)</span>

<span style="color: #F0DFAF; font-weight: bold;">with</span> <span style="color: #DCDCCC; font-weight: bold;">open</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'aa.pickle'</span>, <span style="color: #CC9393;">'rb'</span><span style="color: #DCDCCC;">)</span> <span style="color: #F0DFAF; font-weight: bold;">as</span> fp:
    <span style="color: #DFAF8F;">d</span> = pickle.load<span style="color: #DCDCCC;">(</span>fp<span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline56" class="outline-3">
<h3 id="orgheadline56">json</h3>
<div class="outline-text-3" id="text-orgheadline56">
<p>
和pickle类似,也是dump,dumps,load,loads这几个接口(以s结尾的就是字符串,否则就
是文件),json模块默认只能encode与decode python的内置类型，比如数字，字符串，
list，tuple，dict等，如果你要endcode自定义的类，那么你需要扩展，代码示例如下：
</p>
<script src="https://gist.github.com/yuyang0/6945963.js"></script>
<p>
调用的时候直接使用如下代码：
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #DFAF8F;">d</span> = <span style="color: #DCDCCC;">{</span>
    <span style="color: #CC9393;">'status'</span>: <span style="color: #BFEBBF;">0</span>,
    <span style="color: #CC9393;">'data'</span>: <span style="color: #DCDCCC; font-weight: bold;">list</span><span style="color: #BFEBBF;">(</span>comments<span style="color: #BFEBBF;">)</span>,
<span style="color: #DCDCCC;">}</span>

json.dumps<span style="color: #DCDCCC;">(</span>d, cls=CustomTypeEncoder,
           user=request.user<span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
cls参数指定用来encode的class，后面的user参数用来向自定义的encoder中添加额外
的参数，可以在自定义的encoder的init函数中获取，可以参见上面的encoder的代码
</p>
</div>
</div>
<div id="outline-container-orgheadline57" class="outline-3">
<h3 id="orgheadline57">HTMLParser</h3>
<div class="outline-text-3" id="text-orgheadline57">
<p>
文档中的示例代码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> HTMLParser <span style="color: #F0DFAF; font-weight: bold;">import</span> HTMLParser

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">create a subclass and override the handler methods</span>
<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">MyHTMLParser</span><span style="color: #DCDCCC;">(</span>HTMLParser<span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">handle_starttag</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, tag, attrs<span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">print</span> <span style="color: #CC9393;">"Encountered a start tag:"</span>, tag
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">handle_endtag</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, tag<span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">print</span> <span style="color: #CC9393;">"Encountered an end tag :"</span>, tag
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">handle_data</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, data<span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">print</span> <span style="color: #CC9393;">"Encountered some data  :"</span>, data

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">instantiate the parser and fed it some HTML</span>
<span style="color: #DFAF8F;">parser</span> = MyHTMLParser<span style="color: #DCDCCC;">()</span>
parser.feed<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;'</span>
            <span style="color: #CC9393;">'&lt;body&gt;&lt;h1&gt;Parse me!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
从上面的代码可以看出:该库的使用方法就是在类中处理starttag, endtag, data(标签中间的文本)
然后调用feed方法就好,实际是一个流式html解析器
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline64" class="outline-2">
<h2 id="orgheadline64">一些第三方库的使用方法</h2>
<div class="outline-text-2" id="text-orgheadline64">
</div><div id="outline-container-orgheadline59" class="outline-3">
<h3 id="orgheadline59">requests</h3>
<div class="outline-text-3" id="text-orgheadline59">
<p>
python的标准库中的urllib,urllib2的接口并不好用,requests的接口更简洁一致,这是官方<a href="http://docs.python-requests.org/en/latest/">文档</a>
</p>
<ol class="org-ol">
<li><p>
get
requests.get(url, **kwargs)
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #DFAF8F;">payload</span> = <span style="color: #DCDCCC;">{</span><span style="color: #CC9393;">'key1'</span>: <span style="color: #CC9393;">'value1'</span>, <span style="color: #CC9393;">'key2'</span>: <span style="color: #CC9393;">'value2'</span><span style="color: #DCDCCC;">}</span>
<span style="color: #DFAF8F;">r</span> = requests.get<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"http://httpbin.org/get"</span>, params=payload<span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li><p>
post
requests.post(url, data=None, **kwargs)
</p>
<ul class="org-ul">
<li>data: 是要post的数据</li>
<li>kwargs: 可以使用headers =  {&#x2026;.}指定http request header</li>
</ul>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> json
<span style="color: #DFAF8F;">url</span> = <span style="color: #CC9393;">'https://api.github.com/some/endpoint'</span>
<span style="color: #DFAF8F;">payload</span> = <span style="color: #DCDCCC;">{</span><span style="color: #CC9393;">'some'</span>: <span style="color: #CC9393;">'data'</span><span style="color: #DCDCCC;">}</span>
<span style="color: #DFAF8F;">headers</span> = <span style="color: #DCDCCC;">{</span><span style="color: #CC9393;">'content-type'</span>: <span style="color: #CC9393;">'application/json'</span><span style="color: #DCDCCC;">}</span>

<span style="color: #DFAF8F;">r</span> = requests.post<span style="color: #DCDCCC;">(</span>url, data=json.dumps<span style="color: #BFEBBF;">(</span>payload<span style="color: #BFEBBF;">)</span>, headers=headers<span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li>put
requests.put(url, **kwargs)</li>
<li><p>
response object
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> requests
<span style="color: #DFAF8F;">r</span> = requests.get<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'http://www.baidu.com'</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> r.text
<span style="color: #F0DFAF; font-weight: bold;">print</span> r.url
<span style="color: #F0DFAF; font-weight: bold;">print</span> r.encoding
<span style="color: #F0DFAF; font-weight: bold;">print</span> r.status_code                    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">response status code(eg:200)</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> r.headers                        <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">a dict</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> r.headers<span style="color: #DCDCCC;">[</span><span style="color: #CC9393;">'Content-Type'</span><span style="color: #DCDCCC;">]</span>        <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">response headers</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> r.cookies<span style="color: #DCDCCC;">[</span><span style="color: #CC9393;">'example_cookie_name'</span><span style="color: #DCDCCC;">]</span> <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">cookies</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span> r.json<span style="color: #DCDCCC;">()</span>                         <span style="color: #5F7F5F;">#  </span><span style="color: #7F9F7F;">built-in json function</span>

<span style="color: #F0DFAF; font-weight: bold;">print</span> r.request.headers         <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">http request headers</span>
</pre>
</div></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline60" class="outline-3">
<h3 id="orgheadline60">pip</h3>
<div class="outline-text-3" id="text-orgheadline60">
<p>
从github安装包
pip install git+git://github.com/yourname/package.git
或者pip install git+<a href="https://github.com/yourname/package.git">https://github.com/yourname/package.git</a>
</p>
</div>
</div>
<div id="outline-container-orgheadline61" class="outline-3">
<h3 id="orgheadline61">pyquery</h3>
<div class="outline-text-3" id="text-orgheadline61">
<p>
一个使用jquery语法的html解析器,非常方便,比BeautifulSoup好用,这是它的<a href="http://pythonhosted.org/pyquery/index.html">文档</a>
</p>
<div class="org-src-container">

<pre class="src src-python">form pyquery <span style="color: #F0DFAF; font-weight: bold;">import</span> PyQuery
<span style="color: #DFAF8F;">html</span> = <span style="color: #CC9393;">'&lt;html&gt;&lt;title&gt;hello world&lt;/title&gt;&lt;/html&gt;'</span>
<span style="color: #DFAF8F;">d</span> = PyQuery<span style="color: #DCDCCC;">(</span>html, parser = <span style="color: #CC9393;">'html'</span><span style="color: #DCDCCC;">)</span>
d<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'title'</span><span style="color: #DCDCCC;">)</span>.text<span style="color: #DCDCCC;">()</span>
</pre>
</div>
<p>
在调用PyQuery时尽量指定parser, 因为默认判断有时会出错,比如用xml的parser去解析html会得到不正确的结果.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #DFAF8F;">d</span> = PyQuery<span style="color: #DCDCCC;">(</span>html, parser = <span style="color: #CC9393;">'html'</span><span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">selector</span>
d<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'body'</span><span style="color: #DCDCCC;">)</span>
d<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'div#header'</span><span style="color: #DCDCCC;">)</span>
d<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'div.class ul'</span><span style="color: #DCDCCC;">)</span>
d<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'meta[name=keywords]'</span><span style="color: #DCDCCC;">)</span> <span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">attribute</span>

<span style="color: #DFAF8F;">links</span> = d<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'div.links a'</span><span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#35813;&#22788;&#24212;&#20351;&#29992;&#19979;&#26631;,&#32780;&#19981;&#26159;for link in links</span>
<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span><span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">0</span>, <span style="color: #DCDCCC; font-weight: bold;">len</span><span style="color: #BFEBBF;">(</span>links<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">print</span> links.eq<span style="color: #DCDCCC;">(</span>i<span style="color: #DCDCCC;">)</span>.attr<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'href'</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline62" class="outline-3">
<h3 id="orgheadline62">watchdog</h3>
<div class="outline-text-3" id="text-orgheadline62">
<p>
看门狗,用来监控文件系统改变,这是<a href="http://pythonhosted.org/watchdog/">文档</a>, 基本使用:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> time
<span style="color: #F0DFAF; font-weight: bold;">from</span> watchdog.observers <span style="color: #F0DFAF; font-weight: bold;">import</span> Observer
<span style="color: #F0DFAF; font-weight: bold;">from</span> watchdog.events <span style="color: #F0DFAF; font-weight: bold;">import</span> LoggingEventHandler

<span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #DCDCCC; font-weight: bold;">__name__</span> == <span style="color: #CC9393;">"__main__"</span>:
    <span style="color: #DFAF8F;">event_handler</span> = LoggingEventHandler<span style="color: #DCDCCC;">()</span>
    <span style="color: #DFAF8F;">observer</span> = Observer<span style="color: #DCDCCC;">()</span>
    observer.schedule<span style="color: #DCDCCC;">(</span>event_handler, path=<span style="color: #CC9393;">'.'</span>, recursive=<span style="color: #BFEBBF;">True</span><span style="color: #DCDCCC;">)</span>
    observer.start<span style="color: #DCDCCC;">()</span>
    <span style="color: #F0DFAF; font-weight: bold;">try</span>:
        <span style="color: #F0DFAF; font-weight: bold;">while</span> <span style="color: #BFEBBF;">True</span>:
            time.sleep<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">1</span><span style="color: #DCDCCC;">)</span>
    <span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">KeyboardInterrupt</span>:
        observer.stop<span style="color: #DCDCCC;">()</span>
    observer.join<span style="color: #DCDCCC;">()</span>
</pre>
</div>
<p>
关键的部分有两个:
</p>
<ol class="org-ol">
<li>recursive=True,默认是False,如果不指定那么那么就不会监控子目录</li>
<li>event_handler:这个是文件系统事件的处理对象,可以自己继承watchdog.events.FileSystemEventHandler,
然后重载<a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_created">on_create</a>d, <a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_deleted">on_deleted</a>, <a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_modified">on_modified</a>, <a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_moved">on_moved</a>,</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline63" class="outline-3">
<h3 id="orgheadline63">rauth</h3>
<div class="outline-text-3" id="text-orgheadline63">
<p>
一个Oauth库,这是<a href="https://rauth.readthedocs.org/en/latest/">文档</a>, 这是一份示例
<a href="https://gist.github.com/yuyang0/5949932">代码</a>, 基本上照着流程走就OK了
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline67" class="outline-2">
<h2 id="orgheadline67">常用工具的使用方法</h2>
<div class="outline-text-2" id="text-orgheadline67">
</div><div id="outline-container-orgheadline65" class="outline-3">
<h3 id="orgheadline65">virtualenv</h3>
<div class="outline-text-3" id="text-orgheadline65">
<p>
这是一份不错的<a href="http://docs.python-guide.org/en/latest/dev/virtualenvs.html">tutorial</a>
</p>
<ol class="org-ol">
<li>virtualenv venv</li>
<li>source venv/bin/activate</li>
<li>deactivate</li>
</ol>
<p>
virtualenvwrapper可以对virtualenv进行一定的增强
</p>
<ol class="org-ol">
<li><p>
install
</p>
<pre class="example">
sudo pip install virtualenvwrapper
export WORKON_HOME=~/envs
source /usr/local/bin/virtualenvwrapper.sh
</pre></li>
<li>mkvirtualenv my_env
      在WORKON_HOME中创建一个名为my_env虚拟环境</li>
<li>workon my_env
      切换到my_env环境</li>
<li>deactivate</li>
<li>lssitepackages</li>
<li>lsvirtualenv</li>
<li>rmvirtualenv my_env</li>
</ol>

<p>
和zsh的整合：
安装virtualenvwrapper插件，然后在每一个仓库中放一个.venv文件，文件的内容
是你创建的env的名字
</p>
</div>
</div>
<div id="outline-container-orgheadline66" class="outline-3">
<h3 id="orgheadline66">ipython</h3>
<div class="outline-text-3" id="text-orgheadline66">
<p>
ipython是一个增强的python interpreter,有许多有趣的功能
</p>
<ol class="org-ol">
<li>magic function
以 % 或者 %% 开头的都是magic function,其中
<ul class="org-ul">
<li>以%开头会将本行余下的部分作为一个参数传递给该命令,如果%automagic为on(默认), 那么可以省略前面的 %, 可以
使用 %lsmagic 来列出有多少这种命令.</li>
<li>以%%开头的命令不仅会将本行余下的部分作为参数,本行下面独立的行也会作为参数</li>
</ul></li>
<li>TAB补全, 可以补全内置的函数,模块以及变量文件名等等</li>
<li>%run命令: 该命令可以用来运行脚本(实际是把所有的属性导入当前的namespace,和import功能类似),测试脚本时用该
命令,而不是import,因为该命令可以让改动立即生效,有以下几个选项:
<ul class="org-ul">
<li>t: 可以用来获得脚本的运行时间</li>
<li>p: 性能分析,会列出程序中每个函数调用的时间, %prun命令与该选项功能相似,但是它是对一条python命令或者一个函数调
用进行性能测试</li>
<li>d: 调试,激活pdb,并在开始处暂停,和gdb类似</li>
</ul></li>
<li>剖析对象,给定一个对象,观察这个对象的文档,函数定义以及源代码,有以下命令
<ul class="org-ul">
<li>%pdoc: print doc string</li>
<li>%pdef: print definition of function</li>
<li>%psource: print source code</li>
<li>%pfile: get file of this object</li>
</ul></li>
<li>调试: %pdb命令会打开或关闭在任何未捕捉的异常点调用pdb调试器的功能, 如果该功能打开了,那么遇到任何未捕捉的
异常,会自动调用调试器,这样就可以打印异常点的变量值,执行代码了</li>
<li>运行shell命令: !开头,比如 !ping www.baidu.com ,可以将shell命令的输出赋给python变量, 比如
output = !ping www..baidu.com, 那么output就会是ping的输出</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<!-- 多说评论框 start -->
  <div id="duoshuo-id" class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
   var url = window.location.pathname;
   var duoshuo_identifier = url.substring(url.lastIndexOf('/')+1);
   if (!!! duoshuo_identifier) {
     duoshuo_identifier = "index.html";
   }
   var title = document.title;
   var ele = document.getElementById("duoshuo-id");
   ele.setAttribute("data-thread-key", duoshuo_identifier);
   ele.setAttribute("data-title", title);
   ele.setAttribute("data-url", url);

</script>

<script type="text/javascript">
var duoshuoQuery = {short_name:"yuyang0"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementById('postamble')
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end --><!-- begin footer -->
<div id="footer">
  <ul class="links vertical-nav">
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a class="back-to-top" href="#">Back to Top</a></li>
  </ul>
  <span>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</span>
  <a href="#" class="back-to-top" id="fixed-back-to-top" ></a>
</div>
<script src="http://apps.bdimg.com/libs/jquery/2.0.0/jquery.min.js"></script>
<script type="text/javascript">
	window.jQuery || document.write('<script src="static/js/jquery-2.0.0.min.js"><\/script>');
	</script>
<script type="text/javascript" src="static/js/custom.js"></script>
<!-- end footer -->
</div>
</body>
</html>
