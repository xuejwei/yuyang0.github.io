<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>python笔记</title>
<!-- 2014-12-01 Mon 20:12 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Yu Yang" />
<meta  name="keywords" content="python" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/>
<link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="site-title"><a href="/"> 编码者言 </a></h1>
        <div>
          <a href="###" id="site-nav-btn">菜单</a>
          <ul id="site-nav" class="vertical-nav mobi-hid">
            <li> <a href="/">Home</a></li>
            <li> <a href="/about.html">About</a></li>

            <li> <a href="/tags.html">Tags</a></li>

            <li> <a href="/atom.xml">RSS</a></li>
          </ul>

          <form id="site-search" method="get" action="https://google.com/search">
            <input type="hidden" name="q" value="site:yuyang0.github.io" />
            <input type="text" name="q" placeholder="Search..." />
            <button class="btn-search" type="submit">Search</button>
          </form>
          <div style="clear:both;"> </div>
        </div>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">python笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">python的编码规范</a></li>
<li><a href="#sec-2">python 文件处理</a></li>
<li><a href="#sec-3">作用域规则</a></li>
<li><a href="#sec-4">杂七杂八</a>
<ul>
<li><a href="#sec-4-1">除法</a></li>
<li><a href="#sec-4-2">一些内置函数的解释</a></li>
<li><a href="#sec-4-3">dir</a></li>
<li><a href="#sec-4-4">globals  And lolcals</a></li>
<li><a href="#sec-4-5">getattr,__getattr__,__getattribute__</a></li>
<li><a href="#sec-4-6">__import__(接字符串而不是name)</a></li>
</ul>
</li>
<li><a href="#sec-5">装饰器</a>
<ul>
<li><a href="#sec-5-1">装饰器的基本形式</a></li>
<li><a href="#sec-5-2">使用类作为装饰器(推荐的做法)</a></li>
<li><a href="#sec-5-3">使用类作为装饰器装饰类方法</a></li>
<li><a href="#sec-5-4">给装饰器添加参数</a></li>
<li><a href="#sec-5-5">functools模块</a></li>
</ul>
</li>
<li><a href="#sec-6">迭代器</a>
<ul>
<li><a href="#sec-6-1">迭代器的基本知识</a></li>
<li><a href="#sec-6-2">生成器generator</a></li>
<li><a href="#sec-6-3">for循环的迭代过程</a></li>
</ul>
</li>
<li><a href="#sec-7">with</a></li>
<li><a href="#sec-8">模块</a>
<ul>
<li><a href="#sec-8-1">relative import</a></li>
</ul>
</li>
<li><a href="#sec-9">OOP</a>
<ul>
<li><a href="#sec-9-1">基本OOP代码示例</a></li>
<li><a href="#sec-9-2">属性搜索树</a></li>
<li><a href="#sec-9-3">类的设计</a>
<ul>
<li><a href="#sec-9-3-1">is a</a></li>
<li><a href="#sec-9-3-2">has a</a></li>
</ul>
</li>
<li><a href="#sec-9-4">常见的运算符重载</a></li>
<li><a href="#sec-9-5">Descriptor</a></li>
</ul>
</li>
<li><a href="#sec-10">python异常</a>
<ul>
<li><a href="#sec-10-1">try &#x2026; except语句</a></li>
<li><a href="#sec-10-2">raise</a></li>
<li><a href="#sec-10-3">异常</a></li>
</ul>
</li>
<li><a href="#sec-11">python中文处理</a></li>
<li><a href="#sec-12">一些很诡异的问题</a>
<ul>
<li><a href="#sec-12-1">传引用</a></li>
</ul>
</li>
<li><a href="#sec-13">一些标准库的使用说明</a>
<ul>
<li><a href="#sec-13-1">python 正则表达式</a></li>
<li><a href="#sec-13-2">多线程</a>
<ul>
<li><a href="#sec-13-2-1">Thread</a></li>
<li><a href="#sec-13-2-2">threading</a></li>
</ul>
</li>
<li><a href="#sec-13-3">collections</a>
<ul>
<li><a href="#sec-13-3-1">Counter</a></li>
<li><a href="#sec-13-3-2">deque 双端队列</a></li>
<li><a href="#sec-13-3-3">defaultdict</a></li>
<li><a href="#sec-13-3-4">namedtuple</a></li>
<li><a href="#sec-13-3-5">OrderedDict</a></li>
</ul>
</li>
<li><a href="#sec-13-4">pickle</a></li>
<li><a href="#sec-13-5">json</a></li>
<li><a href="#sec-13-6">HTMLParser</a></li>
</ul>
</li>
<li><a href="#sec-14">一些第三方库的使用方法</a>
<ul>
<li><a href="#sec-14-1">requests</a></li>
<li><a href="#sec-14-2">pip</a></li>
<li><a href="#sec-14-3">pyquery</a></li>
<li><a href="#sec-14-4">watchdog</a></li>
<li><a href="#sec-14-5">rauth</a></li>
</ul>
</li>
<li><a href="#sec-15">常用工具的使用方法</a>
<ul>
<li><a href="#sec-15-1">virtualenv</a></li>
<li><a href="#sec-15-2">ipython</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">python的编码规范</h2>
<div class="outline-text-2" id="text-1">
<ol class="org-ol">
<li>用4个空格缩进
</li>
<li>每一行不超过80个字符,当一行超过80个字符时,可以用\来连接下一行,当对一个二元操作符断行时,应该将操作符留在
上一行, 对于函数定义以及调用,那么根据括号来对齐.
</li>
<li>模块内容的顺序：
<ul class="org-ul">
<li>模块说明和docstring
</li>
<li>import
</li>
<li>__all__(optional)
</li>
<li>globals and constants
</li>
<li>其他定义
</li>
</ul>
</li>
<li>一行只导入一个模块(不推荐 import sys, os)
</li>
<li>模块导入顺序: 标准库, 第三方库, 自己编写的库. 三者之间用空行分割, 而且三者应该紧挨着模块字符串的后面
</li>
<li>模块级别的函数定义, 类定义用2个空行分割, 类方法用一个空行分割
</li>
<li>空格的添加:
<ul class="org-ul">
<li>二元操作的两边各放一个空格, 但是对于有多个操作符的情况,可以只在低优先级
的操作符两边放空格
<div class="org-src-container">

<pre class="src src-python"><span style="color: #6c71c4;">i</span> = i + 1
<span style="color: #6c71c4;">submitted</span> += 1
<span style="color: #6c71c4;">x</span> = x*2 - 1
<span style="color: #6c71c4;">hypot2</span> = x*x + y*y
<span style="color: #6c71c4;">c</span> = (a+b) * (a-b)
</pre>
</div>
</li>
<li>标点符号的后面放空格,前面不要放空格,在(, {, [之后以及), }, ]之前不要放空格,函数调用时函数名与左括号之间
不要放空格
<pre class="example">
Yes: spam(ham[1], {eggs: 2})
No:  spam( ham[ 1 ], { eggs: 2 } )
No:  spam (ham[1], {eggs:2})

Yes: if x == 4: print x, y; x, y = y, x
No:  if x == 4 : print x , y ; x , y = y , x

Yes: spam(1)
No:  spam (1)

Yes: dict['key'] = list[index]
No:  dict ['key'] = list [index]
</pre>
</li>
<li>不要在用于指定关键字参数 (keyword argument) 或默认参数值的 '=' 号周围使用空格。
</li>
</ul>
</li>
<li>命名
<ul class="org-ul">
<li>模块名与包名: 全部用小写字母, 模块名可以添加下划线来增加可读性, 包名不建议添加下划线,名字尽量短一点,因
为有些文件系统对文件长度有要求
</li>
<li>类名: 使用驼峰命名法,如果是内部类,则在前面加一个下划线
</li>
<li>异常名: 异常是类, 所以使用驼峰命名法,但是必须有Error后缀
</li>
<li>函数名: 必须是小写字母, 用下划线去增加可读性
</li>
<li>类方法: 和函数名相同, 对于non-public函数, 可以在前面加一个下划线, 前面加两个下划线主要是避免与子类命名
冲突(一般用户命名变量不推荐使用)
</li>
<li>常量名: 全部大写, 用下划线分割增加可读性
</li>
</ul>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">python 文件处理</h2>
<div class="outline-text-2" id="text-2">
<p>
open打开文件时的选项：
</p>
<ul class="org-ul">
<li>w, w+: 如果文件已存在，那么二者都会将文件内容清除
</li>
<li>r+: 如果写文件，那么会从当前位置覆盖写，而不是插入，当用该模式打开文件，读
入文件内容，然后用覆盖该文件时应使用如下代码
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">with</span> <span style="color: #6c71c4;">open</span>(filename, <span style="color: #2aa198;">'r+'</span>) <span style="color: #859900;">as</span>  f:
    <span style="color: #6c71c4;">content</span> = f.read()
    <span style="color: #6c71c4;">new_content</span> = do_something()
    f.seek(0)
    f.write(new_content)
    f.truncate()                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">&#21024;&#38500;&#24403;&#21069;&#35835;&#20889;&#20301;&#32622;&#21040;&#25991;&#20214;&#26411;&#23614;&#30340;&#20869;&#23481;</span>
</pre>
</div>
</li>
<li>b: 在python2中，linux指定与不指定问题不大，但是建议对于二进制文件比如图片还
是指定该选项比较好，避免移植到windows出现问题，在python3中，对于文本文件，
如果不指定该选项，那么会返回unicode string， 而如果指定该选项则返回byte
string, 所以对于二进制文件,你必须指定b
</li>
</ul>

<p>
遍历一个文件夹的所有文件
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">import</span> os
<span style="color: #859900;">import</span> os.path

<span style="color: #859900;">import</span> os
<span style="color: #859900;">from</span> os.path <span style="color: #859900;">import</span> join, getsize
<span style="color: #859900;">for</span> root, dirs, files <span style="color: #859900;">in</span> os.walk(<span style="color: #2aa198;">'python/Lib/email'</span>):
    <span style="color: #859900;">for</span> afile <span style="color: #859900;">in</span> files:
        <span style="color: #6c71c4;">full_name</span> = os.path.join(root, afile)
        do_something(full_name)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">作用域规则</h2>
<div class="outline-text-2" id="text-3">
<ol class="org-ol">
<li>if, for, while等不会创建新的作用域, 也就是说它们不同于c中block structure.
</li>
<li>每一个模块会创建一个模块作用域
</li>
<li>每一个函数(包括嵌套定义的函数) 都创建一个函数作用域
</li>
<li>在一个作用域内第一次赋值会创建一个新的 <b>绑定</b>, 以后对该变量的赋值都是对该
绑定的 <b>修改</b>.
</li>
<li>在内层作用域可以引用外层作用域的变量, 但是你不能修改外层作用域的变量, 因为
你在在内层作用域一旦对该变量使用赋值,那么就是创建一个新的绑定, 所以为了改
变模块作用域中的变量你必须使用global来申明, 但是你永远也不能在内层函数中改
变外层函数的变量(当然你可以通过subscript或者attribute來修改可变对象的值,
只是这是引用的关系, 和作用域关系不大),这是python设计的不够好的地方.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">杂七杂八</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">除法</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>X/Y: python2中的行为和C语言类似，3/2=1, 3/2.0=1.5; 在python3中，这是真除法，也就是会一直保留小数位,3/2 = 1.5
</li>
<li>X//Y: 在python2以及3中都是floor除法，也就是取整数区间的左边边界，5//2 = 2, 5//-2 = -3
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">一些内置函数的解释</h3>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">dir</h3>
<div class="outline-text-3" id="text-4-3">
<p>
获得对象的所有属性,也就是顶层的那些names
</p>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">globals  And lolcals</h3>
<div class="outline-text-3" id="text-4-4">
<ol class="org-ol">
<li>globals(): 返回一个字典,字典包括当前模块(也就是调用globals()的模块)的所有模块级属性, 同时还包
括'<span class="underline"><span class="underline">builtins</span></span>'属性, 还包括几个特殊变量__file__, <span class="underline"><span class="underline">package</span></span>, <span class="underline"><span class="underline">doc</span></span>
</li>
<li>locals(): 这个只返回局部空间(比如函数的局部变量)的变量与值的字典,注意这个字典不能修改,如果强行修改会引发
严重后果,比如解释器崩溃
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">getattr,__getattr__,__getattribute__</h3>
<div class="outline-text-3" id="text-4-5">
<ol class="org-ol">
<li>__getattr__只有在属性不存在时才调用,该方法用的多
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">class</span> <span style="color: #268bd2;">ClassName</span>(<span style="color: #6c71c4;">object</span>):
    <span style="color: #859900;">def</span> <span style="color: #b58900;">__getattr__</span>(<span style="color: #859900;">self</span>, name):
        dosomething()
        <span style="color: #859900;">return</span> <span style="color: #6c71c4;">super</span>(ClassName, <span style="color: #859900;">self</span>).__getattr__(name)
</pre>
</div>
</li>
<li>__getattribute__是每一次obj.attr时都会调用,所以它可以拦截所有的属性查询, 用的很少
</li>
<li>getattr: 原型getattr(object, name[, default]), getattr(x, 'foobar')等价于x.foobar优势就在于getattr可以
使用字符串,注意如果是获得类实例的方法,那么self参数就可以忽略了,只需要传入除self之外的其它参数就好
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">__import__(接字符串而不是name)</h3>
<div class="outline-text-3" id="text-4-6">
<p>
原型：  __import__(name[, globals[, locals[, fromlist[, level]]]])
</p>
<ul class="org-ul">
<li>fromlist： 指定需要从name中导入的属性名，一般而言也就是from module1 import attr1, attr2&#x2026;中的
attr1,attr2&#x2026; <b>这个参数一般需要指定</b>
</li>
<li>level: 指定使用绝对导入还是相对导入，-1是默认会同时尝试二者，0是绝对导入，正数是相当于加几个. ,比如如果
为1,那就是加一个.也就是当前目录，如果是2,那就是加两个点，在当前模块的父目录中导入，和import中的相
对导入语法类似
</li>
</ul>


<div class="org-src-container">

<pre class="src src-python"><span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">snippet 1</span>
<span style="color: #859900;">from</span> spam.ham <span style="color: #859900;">import</span> eggs, sausage <span style="color: #859900;">as</span> saus

<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">snippet 2</span>
<span style="color: #6c71c4;">_temp</span> = <span style="color: #6c71c4;">__import__</span>(<span style="color: #2aa198;">'spam.ham'</span>, <span style="color: #6c71c4;">globals</span>(), <span style="color: #6c71c4;">locals</span>(), [<span style="color: #2aa198;">'eggs'</span>, <span style="color: #2aa198;">'sausage'</span>], -1)
<span style="color: #6c71c4;">eggs</span> = _temp.eggs
<span style="color: #6c71c4;">saus</span> = _temp.sausage
</pre>
</div>
<p>
两段代码等价, __import__接的是字符串
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">装饰器</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">装饰器的基本形式</h3>
<div class="outline-text-3" id="text-5-1">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">def</span> <span style="color: #b58900;">deco</span>(func):
    <span style="color: #859900;">def</span> <span style="color: #b58900;">_deco</span>():
        <span style="color: #859900;">print</span>(<span style="color: #2aa198;">"before myfunc() called."</span>)
        func()
        <span style="color: #859900;">print</span>(<span style="color: #2aa198;">"  after myfunc() called."</span>)

    <span style="color: #859900;">return</span> _deco

<span style="color: #268bd2;">@deco</span>
<span style="color: #859900;">def</span> <span style="color: #b58900;">myfunc</span>():
    <span style="color: #859900;">print</span>(<span style="color: #2aa198;">" myfunc() called."</span>)
</pre>
</div>
<p>
上面的@deco 等价于 myfunc = deco(myfunc), 这就是装饰器的本质所在, 注意_deco必须与myfunc有相同的参数,因为
装饰后调用myfunc实际是调用_deco, 当然_deco可以使用*args, **kargs这样的可变参数
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">使用类作为装饰器(推荐的做法)</h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">class</span> <span style="color: #268bd2;">deco</span>(<span style="color: #6c71c4;">object</span>):
    <span style="color: #859900;">def</span> <span style="color: #b58900;">__init__</span>(<span style="color: #859900;">self</span>, func):
        <span style="color: #859900;">self</span>.func = func

    <span style="color: #859900;">def</span> <span style="color: #b58900;">__call__</span>(<span style="color: #859900;">self</span>, *args, **kwargs):
        <span style="color: #859900;">print</span>(<span style="color: #2aa198;">"before myfunc() called."</span>)
        func()
        <span style="color: #859900;">print</span>(<span style="color: #2aa198;">"  after myfunc() called."</span>)

<span style="color: #268bd2;">@deco</span>
<span style="color: #859900;">def</span> <span style="color: #b58900;">myfunc</span>():
    <span style="color: #859900;">print</span>(<span style="color: #2aa198;">" myfunc() called."</span>)
</pre>
</div>
<p>
myfunc = deco(myfunc) 所以myfunc就是一个deco类的实例，然后myfunc(*args, **kwargs),实际就是调用类实例
的__call__方法
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">使用类作为装饰器装饰类方法</h3>
<div class="outline-text-3" id="text-5-3">
<p>
下面的代码也可以装饰非类方法,也就是装饰普通函数,也就意味着下面的代码可以替代2,因为如果装饰的是普通函数,
那么会直接调用该函数,所以不会触发descriptor的__get__方法
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">class</span> <span style="color: #268bd2;">deco</span>(<span style="color: #6c71c4;">object</span>):
    <span style="color: #859900;">def</span> <span style="color: #b58900;">__init__</span>(<span style="color: #859900;">self</span>, func):
        <span style="color: #859900;">self</span>.func = func

    <span style="color: #859900;">def</span> <span style="color: #b58900;">__call__</span>(<span style="color: #859900;">self</span>, *args, **kwargs):
        <span style="color: #859900;">print</span>(<span style="color: #2aa198;">"before myfunc() called."</span>)
        <span style="color: #859900;">self</span>.func(*args, **kwargs)
        <span style="color: #859900;">print</span>(<span style="color: #2aa198;">"  after myfunc() called."</span>)

    <span style="color: #859900;">def</span> <span style="color: #b58900;">__get__</span>(<span style="color: #859900;">self</span>, obj, objtype):
        <span style="color: #859900;">import</span> functools
        <span style="color: #859900;">return</span> functools.partial(<span style="color: #859900;">self</span>.__call__, obj)

<span style="color: #859900;">class</span> <span style="color: #268bd2;">Test</span>(<span style="color: #6c71c4;">object</span>):
    <span style="color: #268bd2;">@deco</span>
    <span style="color: #859900;">def</span> <span style="color: #b58900;">myfunc</span>(<span style="color: #859900;">self</span>):
        <span style="color: #859900;">print</span>(<span style="color: #2aa198;">" myfunc() called."</span>)
</pre>
</div>
<p>
这与2最大的区别就是使用了descriptor，也就是__get__, 之所以这么写是因为，如果像2一样，那么就没有给myfunc
传递self参数，所以python会报缺少参数的错误，下面解释一下代码运行的流程，deco装饰后，myfunc变成一个deco的
类实例，注意deco定义了__get__, 所以myfunc就变成了一个descriptor对象，当你使用test_obj.myfunc(*args,
**kwargs)调用的时候，也就触发了test_obj.myfunc的属性搜索，那么根据descriptor的规则，就变成了
myfunc.__get__(test_obj),该函数返回已将test_obj绑定到myfunc.__call__的第一个参数的partial 函数，接着这个
函数在接受*args, **kwargs参数，总之就是通过descriptor将test_obj传递给了__call__,从而消除了缺少self的问题
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">给装饰器添加参数</h3>
<div class="outline-text-3" id="text-5-4">
<div class="org-src-container">

<pre class="src src-python"> <span style="color: #859900;">def</span> <span style="color: #b58900;">deco</span>(arg):
     <span style="color: #859900;">def</span> <span style="color: #b58900;">_deco</span>(func):
         <span style="color: #859900;">def</span> <span style="color: #b58900;">__deco</span>():
             <span style="color: #859900;">print</span>(<span style="color: #2aa198;">"before %s called [%s]."</span> % (func.<span style="color: #6c71c4;">__name__</span>, arg))
             func()
             <span style="color: #859900;">print</span>(<span style="color: #2aa198;">"  after %s called [%s]."</span> % (func.<span style="color: #6c71c4;">__name__</span>, arg))
         <span style="color: #859900;">return</span> __deco
     <span style="color: #859900;">return</span> _deco
<span style="color: #268bd2;">@deco</span>(<span style="color: #2aa198;">"mymodule"</span>)
 <span style="color: #859900;">def</span> <span style="color: #b58900;">myfunc</span>():
     <span style="color: #859900;">print</span>(<span style="color: #2aa198;">" myfunc() called."</span>)
<span style="color: #268bd2;">@deco</span>(<span style="color: #2aa198;">"module2"</span>)
 <span style="color: #859900;">def</span> <span style="color: #b58900;">myfunc2</span>():
     <span style="color: #859900;">print</span>(<span style="color: #2aa198;">" myfunc2() called."</span>)
myfunc()
 myfunc2()
</pre>
</div>
<p>
需要给装饰器加参数.那么就给多添加一个嵌套函数, 这个参数可以是类以及其它对象
</p>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">functools模块</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li>wraps: 这个装饰器可以确保函数在装饰后属性的一致,比如上面的例子 myfunc=deco(myfunc), 那么此时
myfunc的__name__, __doc__等属性都不在是原myfunc的值了,而是_deco的值,每一次装饰之后这些函数对象的元信
息都丢失的话,那么这显然是一个大问题,而wraps可以用来应付这个问题
<div class="org-src-container">

<pre class="src src-python"> <span style="color: #859900;">import</span> functools
<span style="color: #859900;">def</span> <span style="color: #b58900;">deco</span>(func):
     <span style="color: #268bd2;">@functools.wraps</span>(func)
     <span style="color: #859900;">def</span> <span style="color: #b58900;">_deco</span>():
         <span style="color: #859900;">print</span>(<span style="color: #2aa198;">"before myfunc() called."</span>)
         func()
         <span style="color: #859900;">print</span>(<span style="color: #2aa198;">"  after myfunc() called."</span>)
    <span style="color: #859900;">return</span> _deco
<span style="color: #268bd2;">@deco</span>
 <span style="color: #859900;">def</span> <span style="color: #b58900;">myfunc</span>():
     <span style="color: #859900;">print</span>(<span style="color: #2aa198;">" myfunc() called."</span>)
</pre>
</div>
<p>
@functools.wraps(func)这行代码可以保证,通过装饰器调用后,函数__name__,
__doc__仍然和原来的函数一致
</p>
</li>
<li>partial: 有时候你知道一个函数的一部分参数,这个时候你可以先绑定这些参数,绑
定这些参数之后会返回一个partial对象,你可以当这个对象就是一个以绑定了一些参
数的函数,就是函数式语言中的curry,partial大体上等于以下代码
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">def</span> <span style="color: #b58900;">partial</span>(func, *args, **keywords):
    <span style="color: #859900;">def</span> <span style="color: #b58900;">newfunc</span>(*fargs, **fkeywords):
        <span style="color: #6c71c4;">newkeywords</span> = keywords.copy()
        newkeywords.update(fkeywords)
        <span style="color: #859900;">return</span> func(*(args + fargs), **newkeywords)
    <span style="color: #6c71c4;">newfunc.func</span> = func
    <span style="color: #6c71c4;">newfunc.args</span> = args
    <span style="color: #6c71c4;">newfunc.keywords</span> = keywords
    <span style="color: #859900;">return</span> newfunc
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">迭代器</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">迭代器的基本知识</h3>
<div class="outline-text-3" id="text-6-1">
<p>
迭代器对象是序列对象的一般化,每一个迭代器对象都有一个next方法,该方法每调用一次都会返回下一个元素,当没有元素
可返回时要触发StopIteration异常,这就是迭代对象的实质了
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">生成器generator</h3>
<div class="outline-text-3" id="text-6-2">
<p>
从大多数方面看生成器函数和普通函数一致,它们二者最大的不同时,普通函数是直接通过return返回一个值,而生成器函
数是通过yield返回一个迭代器对象,所以每一个生成器函数调用后都是返回一个迭代器对象,这是本质的区别
</p>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">for循环的迭代过程</h3>
<div class="outline-text-3" id="text-6-3">
<p>
for item in obj语句的执行过程其实是这样
</p>
<ol class="org-ol">
<li>先运行iter(obj) 获得迭代器对象 iter_obj
</li>
<li>重复的调用iter_obj.next() 直到出现StopIteration异常
</li>
<li>如果上述两步已成功,那么for循环就结束了,如果上述两步没成功,这意味着obj不支持迭代协议,那么for就会尝试使用
下标来遍历那么会使用下标来遍历,也就是从0开始每一轮循环都对下标加一,而且每一轮循环都使用obj[i] 来访问元
素,直到触发异常
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">with</h2>
<div class="outline-text-2" id="text-7">
<p>
基本模型：
</p>
<pre class="example">
with exp as name:
    body
</pre>
<p>
先对exp求值得到val，然后调用val的__enter__ 方法，最后将val绑定到name，接着运
行body，在要退出body时运行val的__exit__方法。File对象已经自带了这两个特殊方法，
所以打开文件时，with用的很多。
</p>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">模块</h2>
<div class="outline-text-2" id="text-8">
<p>
模块的_X与__all__: 当调用from XX import * 时, 如果指定了__all__, 那么就只导
入__all__中的名字,如果没指定__all__,那么导入所有除了以下划线开头的全部模块级
名字, 也就是说不会导入 _X 这样的名字
</p>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">relative import</h3>
<div class="outline-text-3" id="text-8-1">
<p>
相对导入必须使用from xxx import yyy 的形式, 而且xxx必须以点号开头, import
xxx 的形式都是绝对导入, python默认是绝对导入,也就是搜索sys.path, 一般来说
sys.path的第一项就是主模块的所在的目录,相对导入需要以下的语法:对于如下的一个
目录结构
</p>
<pre class="example">
package/
 __init__.py
 subpackage1/
     __init__.py
     moduleX.py
     moduleY.py
 subpackage2/
     __init__.py
     moduleZ.py
 moduleA.py
</pre>
<p>
假设在moduleX.py or subpackage1/__init__.py中，那么下列的相对导入是合法的
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">from</span> .moduleY <span style="color: #859900;">import</span> spam
<span style="color: #859900;">from</span> .moduleY <span style="color: #859900;">import</span> spam <span style="color: #859900;">as</span> ham
<span style="color: #859900;">from</span> . <span style="color: #859900;">import</span> moduleY
<span style="color: #859900;">from</span> ..subpackage1 <span style="color: #859900;">import</span> moduleY
<span style="color: #859900;">from</span> ..subpackage2.moduleZ <span style="color: #859900;">import</span> eggs
<span style="color: #859900;">from</span> ..moduleA <span style="color: #859900;">import</span> foo
<span style="color: #859900;">from</span> ...package <span style="color: #859900;">import</span> bar
<span style="color: #859900;">from</span> ...sys <span style="color: #859900;">import</span> path
</pre>
</div>
<p>
一个点代表当前文件所在的目录，两个点代表当前文件所在目录的父目录，以此类推，
注意相对导入使用__name__属性实现的，所以对于执行模块必须小心，因为他的__name__属
性是__main__, 所以这些模块中不能使用相对导入
</p>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">OOP</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">基本OOP代码示例</h3>
<div class="outline-text-3" id="text-9-1">
<p>
类,类的实例和模块都只是一个命名空间,命名空间的属性都可以修改,所以非常灵活,对于基于类的对象而言,可以使用dir内
置函数来查看命名空间, <b>类与类的实例都是对象,二者都是使用字典对象实现的命名空间,二者的__dict__属性基本就是命名空间
字典</b>, 看如下代码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">class</span> <span style="color: #268bd2;">Test</span>(<span style="color: #6c71c4;">object</span>):
    <span style="color: #2aa198;">"""</span>
<span style="color: #2aa198;">    a Test Class</span>
<span style="color: #2aa198;">    """</span>
    <span style="color: #6c71c4;">val1</span> = 1
    <span style="color: #6c71c4;">val2</span> = 2
    <span style="color: #859900;">def</span> <span style="color: #b58900;">__init__</span>(<span style="color: #859900;">self</span>, arg1, arg2):
        <span style="color: #2aa198;">"""</span>
<span style="color: #2aa198;">        """</span>
        <span style="color: #859900;">self</span>.arg1 = arg1
        <span style="color: #859900;">self</span>.arg2 = arg2

    <span style="color: #859900;">def</span> <span style="color: #b58900;">display</span>(<span style="color: #859900;">self</span>):
        <span style="color: #2aa198;">"""</span>
<span style="color: #2aa198;">        """</span>
        <span style="color: #859900;">print</span> <span style="color: #859900;">self</span>.arg1, <span style="color: #859900;">self</span>.arg2

<span style="color: #6c71c4;">obj1</span> = Test(1, 2)
<span style="color: #859900;">print</span> <span style="color: #6c71c4;">dir</span>(Test)
<span style="color: #859900;">print</span>
<span style="color: #859900;">print</span> <span style="color: #6c71c4;">dir</span>(obj1)
</pre>
</div>

<p>
val1, val2, <span class="underline"><span class="underline">init</span></span>, display都是类Test本身的属性, 而arg1, arg2就是类实例(obj1)的属性,实际上self产生的就是
类实例对象的属性, 当然类的实例也会继承
类的属性
</p>
</div>
</div>

<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">属性搜索树</h3>
<div class="outline-text-3" id="text-9-2">
<p>
当调用obj.attr时,python有一个属性的搜索过程,比如下面的代码
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">class</span> <span style="color: #268bd2;">D1</span>(<span style="color: #6c71c4;">object</span>):
    <span style="color: #859900;">pass</span>

<span style="color: #859900;">class</span> <span style="color: #268bd2;">D2</span>(<span style="color: #6c71c4;">object</span>):
    <span style="color: #859900;">pass</span>

<span style="color: #859900;">class</span> <span style="color: #268bd2;">D3</span>(<span style="color: #6c71c4;">object</span>):
    <span style="color: #859900;">pass</span>

<span style="color: #859900;">class</span> <span style="color: #268bd2;">C1</span>(D1, D2):
    <span style="color: #859900;">pass</span>

<span style="color: #859900;">class</span> <span style="color: #268bd2;">C2</span>(D3):
    <span style="color: #859900;">pass</span>

<span style="color: #859900;">class</span> <span style="color: #268bd2;">B</span>(C1, C2):
    <span style="color: #859900;">pass</span>

<span style="color: #6c71c4;">a1</span> = B()
<span style="color: #6c71c4;">a2</span> = B()
</pre>
</div>
<p>
上面的代码会构成一颗属性搜索树:
</p>

<div class="figure">
<p><img src="static/img/attribute-search-tree.png" alt="attribute-search-tree.png" />
</p>
</div>

<p>
因为类本身也是对象,所以类本身也有属性,类的属性就是类的方法,以及类的变量, 比如当调用a1.x时,那么搜索的过程就
是这样的: a1, B, C1, D1, D2, C2, D3注意这是深度优先搜索,python的经典类与新式类都是这种搜索模式，但是新式类
有一个diamond pattern，也就是钻石模式，这种模式下有一个以上的超类会通往相同的更高层次的超类，这时候会使用
广度优先搜索(只是有相同超类的那一部分)，举个例子：
</p>

<div class="figure">
<p><img src="static/img/diamond-pattern.png" alt="diamond-pattern.png" />
</p>
</div>

<p>
如上图所示，如果C2有个w属性，D2也有个w属性，那么当使用a1.w进行属性搜索时，如果使用深度优先搜索，那么会得到
D2.w， 但是C2是D2的子类，并且重载了w属性，这种情况下应该用子类的属性也就是C2的w属性，钻石继承就是为这种情
况准备的，在这种情况下，在C1,D2, C2会使用广度优先算法搜索，这样就可以先得到C2.w .这个特例需要注意
</p>
</div>
</div>

<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">类的设计</h3>
<div class="outline-text-3" id="text-9-3">
</div><div id="outline-container-sec-9-3-1" class="outline-4">
<h4 id="sec-9-3-1">is a</h4>
<div class="outline-text-4" id="text-9-3-1">
<p>
如何现实中两个事物是is a的关系，那么就应该用继承，比如teacher is a person，那么Teacher就应该继承Person
</p>
</div>
</div>

<div id="outline-container-sec-9-3-2" class="outline-4">
<h4 id="sec-9-3-2">has a</h4>
<div class="outline-text-4" id="text-9-3-2">
<p>
比如一个商店有商品，有营业员，有顾客，那么商店与商品，营业员，顾客就是has a的关系，这时候应该使用组合，也
就是说商店是一个容器，在该容器对象的构造函数中创建营业员对象，创建商品对象，创建顾客对象，具体到python就
是在__init__中创建这些对象
</p>
</div>
</div>
</div>

<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4">常见的运算符重载</h3>
<div class="outline-text-3" id="text-9-4">
<ol class="org-ol">
<li><span class="underline"><span class="underline">getattr</span></span> <span class="underline"><span class="underline">setattr___使用obj.attr时如果该属性obj中没有attr属性，这时会调用__getattr</span></span>, __setattr___会
拦截所有的属性赋值，也就是obj.attr = val这样的语句都等价于obj.__setattr___('attr', val)，这是
和__getattr__不同的地方，要特别注意
</li>
<li><span class="underline"><span class="underline">getitem</span></span> <span class="underline"><span class="underline">setitem_</span></span>
当出现x[i], x[i] = val, 会分别调用上述方法， 当使用for 迭代时会先尝试__iter__, 如果行不通，那么就使用索
引，也就是用不断递增的索引调用__getitem__, 直到出现IndexError
</li>
<li><span class="underline"><span class="underline">iter</span></span>
必须返回一个迭代器对象，一个拥有next方法的对象就是迭代器对象，如果使用for 在该对象上迭代，它会先使用
iter内置函数来调用__iter__ 方法获得迭代器对象，然后重复的调用该迭代器对象的next方法，直到该next方法产生
StopIteration异常。
</li>
<li><span class="underline"><span class="underline">call</span></span>
将类实例作为函数调用时就是使用的该方法，比如obj是一个类实例，那么obj('a', 'b')等价于
obj.__call__('a','b'),这是一个很常用的方法
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-9-5" class="outline-3">
<h3 id="sec-9-5">Descriptor</h3>
<div class="outline-text-3" id="text-9-5">
<p>
任何对象只要定义了__get__, <span class="underline"><span class="underline">set</span></span>, __del__三者之一，那么就是descriptor，这
是一份不错的<a href="http://docs.python.org/2/howto/descriptor.html">tutorial</a>， 示例代码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">class</span> <span style="color: #268bd2;">RevealAccess</span>(<span style="color: #6c71c4;">object</span>):
    <span style="color: #2aa198;">"""A data descriptor that sets and returns values</span>
<span style="color: #2aa198;">       normally and prints a message logging their access.</span>
<span style="color: #2aa198;">    """</span>

    <span style="color: #859900;">def</span> <span style="color: #b58900;">__init__</span>(<span style="color: #859900;">self</span>, initval=<span style="color: #268bd2;">None</span>, name=<span style="color: #2aa198;">'var'</span>):
        <span style="color: #859900;">self</span>.val = initval
        <span style="color: #859900;">self</span>.name = name

    <span style="color: #859900;">def</span> <span style="color: #b58900;">__get__</span>(<span style="color: #859900;">self</span>, obj, objtype):
        <span style="color: #859900;">print</span> <span style="color: #2aa198;">'Retrieving'</span>, <span style="color: #859900;">self</span>.name
        <span style="color: #859900;">return</span> <span style="color: #859900;">self</span>.val

    <span style="color: #859900;">def</span> <span style="color: #b58900;">__set__</span>(<span style="color: #859900;">self</span>, obj, val):
        <span style="color: #859900;">print</span> <span style="color: #2aa198;">'Updating'</span> , <span style="color: #859900;">self</span>.name
        <span style="color: #859900;">self</span>.val = val

<span style="color: #859900;">class</span> <span style="color: #268bd2;">MyClass</span>(<span style="color: #6c71c4;">object</span>):
    <span style="color: #6c71c4;">x</span> = RevealAccess(10, <span style="color: #2aa198;">'var "x"'</span>)
    <span style="color: #6c71c4;">y</span> = 5
</pre>
</div>
<p>
输出
</p>
<pre class="example">
&gt;&gt;&gt; m = MyClass()
&gt;&gt;&gt; m.x
Retrieving var "x"
10
&gt;&gt;&gt; m.x = 20
Updating var "x"
&gt;&gt;&gt; m.x
Retrieving var "x"
20
&gt;&gt;&gt; m.y
5
</pre>
<p>
上例中 m.x 是一个descriptor，因为它是RevealAccess的类实例，而该类定义了__get__与__set__,所以 m.x 实际上等价
于 x.__get__(m)
</p>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">python异常</h2>
<div class="outline-text-2" id="text-10">
<p>
只说明基于类的异常, 老版的python中基于字符串的异常不考虑
</p>
</div>
<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">try &#x2026; except语句</h3>
<div class="outline-text-3" id="text-10-1">
<pre class="example">
try:
    main-block
except class1:
    handler1
except class2, instance:
    handler2
except (class3, class4):
    handler3
except (class5, class6), instance:
    handler4
except:
    handler5
else:
    else-block finally: finally-block
</pre>
<p>
python2.5以后版本才可以else,finally混在一起,执行try 中语句块时如果没有出现异常,那么就执行else 语句块,如果出
现了异常,那么就从上到下的匹配ecxept子句,最后执行第一个匹配的except 语句块, finally是无论是否发生异常,以及无
论是否捕捉了异常都会执行的
</p>
</div>
</div>

<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2">raise</h3>
<div class="outline-text-3" id="text-10-2">
<p>
raise语句的几种形式
</p>
<ol class="org-ol">
<li>raise : 重新触发上一次产生的异常
</li>
<li>raise instance  : 触发为name的异常
</li>
<li>raise class, instance : 和2类似,只是data是额外数据
</li>
</ol>
<p>
<b>上述的instance应该是一个异常类的实例</b>,目前第二种最常用,为了兼容raise instance还有以下的几种衍生形式
</p>
<ul class="org-ul">
<li>raise class : 等同于 raise class()
</li>
<li>raise class, arg :等同于raise class(arg)
</li>
<li>raise class, (arg1, arg2,&#x2026;) : 等同于raise class(arg1, arg2,&#x2026;)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3">异常</h3>
<div class="outline-text-3" id="text-10-3">
<p>
异常都是类, exceptions must be old-style classes or derived from BaseException.也就是说,要么是老式类,要么
是BaseException的子类,实践中用户自定义的类最好继承于Exception,并且必须以Error结尾, <b>注意except语句是基于超
类匹配的</b>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">python中文处理</h2>
<div class="outline-text-2" id="text-11">
<p>
中文处理一直是一个比较棘手的问题,各种乱码一直让程序员苦不堪言,这里主要介绍
python中文处理的一般原则, 先介绍几个基本概念(强烈建议看看这篇<a href="http://nedbatchelder.com/text/unipain.html">文章</a>):
</p>
<ol class="org-ol">
<li>unicode: 简单点说你可以将unicode看成一种映射,地球上的每一个符号都在unicode
中有一个数(准确的说叫code point)与之对应
</li>
<li>utf8, utf16: 刚刚说了地球上的每一个符号在unicode中有一个数与之对应,那么这
个数如何存储在计算机上呢?utf8, utf16, utf32就是存储策略
</li>
<li>big5, gb2312等: 这些都是各个地区自行发明的双字节码,也就是两个字节代表一个
符号
</li>
</ol>
<p>
python字符处理的基本概念:
</p>
<ol class="org-ol">
<li>byte string: 字节流, utf8,utf16, gb2312等编码后得到的string都是字节流,通过
decode方法可以得到unicode string
</li>
<li>unicode string: unicode字符串的每一个字符都是一个code point, 它可以通过
encode方法转换为各种byte string
</li>
</ol>

<p>
因此python中文处理的实质就是在byte string与unicode string之间来回转换, 因为
python解释器在解释python源文件时,也是需要编码信息的,所以在文件的前两行必须指
定编码信息(coding:utf8), <b>指定的编码必须与python源文件保存时的编码一致</b>
</p>

<p>
python2与python3的区别:
</p>
<ol class="org-ol">
<li>python2中字面字符串是byte string, 而3中是unicode string
<div class="org-src-container">

<pre class="src src-python"><span style="color: #6c71c4;">ss</span> = <span style="color: #2aa198;">'&#20320;&#22909;'</span>                     <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">python2&#20026;byte string, python3&#20026;unicode string</span>
<span style="color: #6c71c4;">ss</span> = u<span style="color: #2aa198;">'&#20320;&#22909;'</span>                    <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">python2&#24471;&#21040;unicode string</span>
<span style="color: #6c71c4;">ss</span> = b<span style="color: #2aa198;">'&#20320;&#22909;'</span>                    <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">python3&#24471;&#21040;byte string</span>
</pre>
</div>
</li>
<li>对二者名称不同
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">category</th>
<th scope="col" class="left">python2</th>
<th scope="col" class="left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">byte string</td>
<td class="left">str</td>
<td class="left">bytes</td>
</tr>

<tr>
<td class="left">unicode string</td>
<td class="left">unicode</td>
<td class="left">str</td>
</tr>
</tbody>
</table>
</li>
<li>读取文件时,python2得到byte string, 而python3调用open时如果指定了b则得到
byte string, 如果没有指定b, 那么就会使用local.getpreferredencoding()返回的
编码方式来decode,然后得到unicode string. python3中调用open时有一个可选参数
来指定解码方式..
</li>
<li>混合时的处理方式不同,如一个byte string与一个unicode string相加,那么python2
会使用sys.getdefaultencoding()返回的编码方式来decode那个byte string, 然后
与unicode string相加得到一个unicode string,但是python3会返回异常因为
python3不允许二者混合.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">一些很诡异的问题</h2>
<div class="outline-text-2" id="text-12">
</div><div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1">传引用</h3>
<div class="outline-text-3" id="text-12-1">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #6c71c4;">gg</span> = <span style="color: #268bd2;">None</span>
<span style="color: #859900;">def</span> <span style="color: #b58900;">test</span>(aa={}):
    <span style="color: #859900;">print</span> aa
    <span style="color: #859900;">global</span> gg
    <span style="color: #6c71c4;">gg</span> = aa

test()
<span style="color: #6c71c4;">gg</span>[<span style="color: #2aa198;">"hello"</span>] = <span style="color: #2aa198;">"world"</span>
test()
</pre>
</div>
<p>
第一次调用test, aa是{}, 第二次调用就是{"hello": "world"}了, 所以默认参数可是
可变对象时,要特别注意, 一定要确定是否需要使用copy.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">一些标准库的使用说明</h2>
<div class="outline-text-2" id="text-13">
</div><div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1">python 正则表达式</h3>
<div class="outline-text-3" id="text-13-1">
<p>
python的正则表达式是通过re这个标准库支持的,这是一篇写的不错的<a href="https://www.evernote.com/shard/s89/sh/8d66ae55-5f2e-4a68-b11d-c8ae8ad3de56/00bfb7913d34061da0083d8286ff1592">文章</a>, 我可耻的用evernote保存下来
了,上面有原文章的连接.
</p>
</div>
</div>

<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2">多线程</h3>
<div class="outline-text-3" id="text-13-2">
</div><div id="outline-container-sec-13-2-1" class="outline-4">
<h4 id="sec-13-2-1">Thread</h4>
</div>
<div id="outline-container-sec-13-2-2" class="outline-4">
<h4 id="sec-13-2-2">threading</h4>
<div class="outline-text-4" id="text-13-2-2">
<p>
threading是一个更高层的模块，它使用更加方便，所以一般情况都是使用该模块
</p>
<ol class="org-ol">
<li>threading.Thread: 要创建一个线程，那么需要先创建threading.Thread的子类，并且重写它的run方法，每一个
Thread对象都要调用start方法，该方法启动线程，该线程会运行该对象的run方法
daemon： 如果已经没有活动的non-daemon(daemon=False)线程的话, 整个进程都会退出,所以经常将子线程的daemon
设为True,并且子线程做成一个while True的死循环,这样如果主线程退出,那么整个进程都会退出,那些死循环的子线
程自然也会退出
</li>
<li>Queue: 同步队列
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">from</span> Queue <span style="color: #859900;">import</span> Queue
<span style="color: #6c71c4;">q</span> = Queue()
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">thread1</span>
<span style="color: #6c71c4;">item</span> = q.get()
do_something(item)
q.task_done()

<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">main thread</span>
q.join()
</pre>
</div>
<p>
实际上task_done就是将内部的计数器减一, 而put会将内部的计数器加1,然后join会测试如果内部的计数器为0就返
回,不为0就阻塞
</p>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-13-3" class="outline-3">
<h3 id="sec-13-3">collections</h3>
<div class="outline-text-3" id="text-13-3">
</div><div id="outline-container-sec-13-3-1" class="outline-4">
<h4 id="sec-13-3-1">Counter</h4>
<div class="outline-text-4" id="text-13-3-1">
<p>
字典的子类，可以用于统计可迭代对象中重复元素出现的次数,这是<a href="http://docs.python.org/2/library/collections.html#counter-objects">文档</a>
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">from</span> collections <span style="color: #859900;">import</span> Counter
<span style="color: #6c71c4;">cn_str</span> = Counter(<span style="color: #2aa198;">'hello world'</span>)
<span style="color: #859900;">print</span> cn_str

<span style="color: #6c71c4;">cn_list</span> = Counter([<span style="color: #2aa198;">'red'</span>, <span style="color: #2aa198;">'blue'</span>, <span style="color: #2aa198;">'red'</span>, <span style="color: #2aa198;">'green'</span>, <span style="color: #2aa198;">'blue'</span>, <span style="color: #2aa198;">'blue'</span>])
<span style="color: #859900;">print</span> cn_list

<span style="color: #6c71c4;">cn_dict</span> = Counter(cats=4, dogs=8)
<span style="color: #859900;">print</span> cn_dict
</pre>
</div>

<pre class="example">
Counter({'l': 3, 'o': 2, ' ': 1, 'e': 1, 'd': 1, 'h': 1, 'r': 1, 'w': 1})
Counter({'blue': 3, 'red': 2, 'green': 1})
Counter({'dogs': 8, 'cats': 4})
</pre>

<p>
Counter除了有dict的方法外，还有几个特有的方法
</p>
<ol class="org-ol">
<li>elements(): 返回可迭代对象，比如调用cn_list.elements() 就会返回['red', 'blue', 'red', 'green',
'blue', 'blue']
</li>
<li>most_common([n]) : 根据字典色value从大到小排出n个item组成一个list
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-13-3-2" class="outline-4">
<h4 id="sec-13-3-2">deque 双端队列</h4>
<div class="outline-text-4" id="text-13-3-2">
<p>
可以从左边或者右边添加或者删除元素,这是<a href="http://docs.python.org/2/library/collections.html#deque-objects">文档</a> ,主要有append,appendleft(单个元素),extend,extendleft(可迭代对
象),pop, popleft等等
</p>
</div>
</div>
<div id="outline-container-sec-13-3-3" class="outline-4">
<h4 id="sec-13-3-3">defaultdict</h4>
<div class="outline-text-4" id="text-13-3-3">
<p>
提供了一个default_factory属性,通过初始化defaultdict实例时对该属性赋值,那么以后如果出现key不存在的情况,不
会出现KeyError,而是调用这个默认工厂函数,然后返回该工厂函数的返回值,这是<a href="http://docs.python.org/2/library/collections.html#defaultdict-objects">文档</a> ,这是几段代码示例:
</p>
<pre class="example">
# 以list 作为default_factory
&gt;&gt;&gt; s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; for k, v in s:
...     d[k].append(v)
...
&gt;&gt;&gt; d.items()
[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]

# 以整数作为default_factory
&gt;&gt;&gt; s = 'mississippi'
&gt;&gt;&gt; d = defaultdict(int)
&gt;&gt;&gt; for k in s:
...     d[k] += 1
...
&gt;&gt;&gt; d.items()
[('i', 4), ('p', 2), ('s', 4), ('m', 1)]
</pre>
</div>
</div>

<div id="outline-container-sec-13-3-4" class="outline-4">
<h4 id="sec-13-3-4">namedtuple</h4>
<div class="outline-text-4" id="text-13-3-4">
<p>
一个tuple的子类,可以给tuple的每一项添加一个名字,以后就可以通过 X.y这样的方式来访问了,看代码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">from</span> collections <span style="color: #859900;">import</span> namedtuple

<span style="color: #6c71c4;">Point</span> = namedtuple(<span style="color: #2aa198;">'Point'</span>, [<span style="color: #2aa198;">'x'</span>, <span style="color: #2aa198;">'y'</span>], verbose=<span style="color: #268bd2;">False</span>)
<span style="color: #6c71c4;">p</span> = Point(11, y=22)
<span style="color: #859900;">print</span> p

<span style="color: #6c71c4;">s</span> = p[0] + p[1]                 <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">like normal tuple</span>
<span style="color: #859900;">print</span> s

<span style="color: #6c71c4;">s</span> = p.x + p.y
<span style="color: #859900;">print</span> s
</pre>
</div>

<p>
=Point(x=11, y=22)
33
33
=    上述代码代表一个点,点有x,y两个值,要访问点的x,可以通过p.x 或者p\<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>(也就是和普通的tuple一样)
</p>
</div>
</div>

<div id="outline-container-sec-13-3-5" class="outline-4">
<h4 id="sec-13-3-5">OrderedDict</h4>
<div class="outline-text-4" id="text-13-3-5">
<p>
OrderedDict是dict的子类,它会记住key插入的顺序,默认的dict是会排序的, 比如下面的代码
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">from</span> collections <span style="color: #859900;">import</span> OrderedDict
<span style="color: #6c71c4;">l</span> = [(<span style="color: #2aa198;">'b'</span>, 3), (<span style="color: #2aa198;">'f'</span>, 2), (<span style="color: #2aa198;">'a'</span>, 1)]
<span style="color: #6c71c4;">d</span> = <span style="color: #6c71c4;">dict</span>(l)
<span style="color: #859900;">print</span> d

<span style="color: #6c71c4;">od</span> = OrderedDict(l)
<span style="color: #859900;">print</span> od
</pre>
</div>

<p>
={'a': 1, 'b': 3, 'f': 2}
OrderedDict([('b', 3), ('f', 2), ('a', 1)])
=    popitem(last=True): last为True,那么就是LIFO, 比如上例就是先弹出(a, 1) 然后(f, 2), 如果last为False,那么就
    是FIFO
</p>
</div>
</div>
</div>

<div id="outline-container-sec-13-4" class="outline-3">
<h3 id="sec-13-4">pickle</h3>
<div class="outline-text-3" id="text-13-4">
<ul class="org-ul">
<li>dump(self, obj, file) 将对象序列化到文件
</li>
<li>dumps(self, obj)      会返回序列化的字符串
</li>
<li>load(file)      从文件加载对象
</li>
<li>loads(str)      从字符串加载对象
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">import</span> pickle
<span style="color: #6c71c4;">d</span> = {<span style="color: #2aa198;">'tag'</span>:<span style="color: #2aa198;">'django'</span>}
<span style="color: #859900;">with</span> <span style="color: #6c71c4;">open</span>(<span style="color: #2aa198;">'aa.pickle'</span>, <span style="color: #2aa198;">'wb'</span>) <span style="color: #859900;">as</span> fp:
    pickle.dump(d, fp)

<span style="color: #859900;">with</span> <span style="color: #6c71c4;">open</span>(<span style="color: #2aa198;">'aa.pickle'</span>, <span style="color: #2aa198;">'rb'</span>) <span style="color: #859900;">as</span> fp:
    <span style="color: #6c71c4;">d</span> = pickle.load(fp)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-13-5" class="outline-3">
<h3 id="sec-13-5">json</h3>
<div class="outline-text-3" id="text-13-5">
<p>
和pickle类似,也是dump,dumps,load,loads这几个接口(以s结尾的就是字符串,否则就
是文件),json模块默认只能encode与decode python的内置类型，比如数字，字符串，
list，tuple，dict等，如果你要endcode自定义的类，那么你需要扩展，代码示例如下：
</p>
<script src="https://gist.github.com/yuyang0/6945963.js"></script>
<p>
调用的时候直接使用如下代码：
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #6c71c4;">d</span> = {
    <span style="color: #2aa198;">'status'</span>: 0,
    <span style="color: #2aa198;">'data'</span>: <span style="color: #6c71c4;">list</span>(comments),
}

json.dumps(d, cls=CustomTypeEncoder,
           user=request.user)
</pre>
</div>
<p>
cls参数指定用来encode的class，后面的user参数用来向自定义的encoder中添加额外
的参数，可以在自定义的encoder的init函数中获取，可以参见上面的encoder的代码
</p>
</div>
</div>

<div id="outline-container-sec-13-6" class="outline-3">
<h3 id="sec-13-6">HTMLParser</h3>
<div class="outline-text-3" id="text-13-6">
<p>
文档中的示例代码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">from</span> HTMLParser <span style="color: #859900;">import</span> HTMLParser

<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">create a subclass and override the handler methods</span>
<span style="color: #859900;">class</span> <span style="color: #268bd2;">MyHTMLParser</span>(HTMLParser):
    <span style="color: #859900;">def</span> <span style="color: #b58900;">handle_starttag</span>(<span style="color: #859900;">self</span>, tag, attrs):
        <span style="color: #859900;">print</span> <span style="color: #2aa198;">"Encountered a start tag:"</span>, tag
    <span style="color: #859900;">def</span> <span style="color: #b58900;">handle_endtag</span>(<span style="color: #859900;">self</span>, tag):
        <span style="color: #859900;">print</span> <span style="color: #2aa198;">"Encountered an end tag :"</span>, tag
    <span style="color: #859900;">def</span> <span style="color: #b58900;">handle_data</span>(<span style="color: #859900;">self</span>, data):
        <span style="color: #859900;">print</span> <span style="color: #2aa198;">"Encountered some data  :"</span>, data

<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">instantiate the parser and fed it some HTML</span>
<span style="color: #6c71c4;">parser</span> = MyHTMLParser()
parser.feed(<span style="color: #2aa198;">'&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;'</span>
            <span style="color: #2aa198;">'&lt;body&gt;&lt;h1&gt;Parse me!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'</span>)
</pre>
</div>
<p>
从上面的代码可以看出:该库的使用方法就是在类中处理starttag, endtag, data(标签中间的文本)
然后调用feed方法就好,实际是一个流式html解析器
</p>
</div>
</div>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">一些第三方库的使用方法</h2>
<div class="outline-text-2" id="text-14">
</div><div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1">requests</h3>
<div class="outline-text-3" id="text-14-1">
<p>
python的标准库中的urllib,urllib2的接口并不好用,requests的接口更简洁一致,这是官方<a href="http://docs.python-requests.org/en/latest/">文档</a>
</p>
<ol class="org-ol">
<li>get
requests.get(url, **kwargs)
<div class="org-src-container">

<pre class="src src-python"><span style="color: #6c71c4;">payload</span> = {<span style="color: #2aa198;">'key1'</span>: <span style="color: #2aa198;">'value1'</span>, <span style="color: #2aa198;">'key2'</span>: <span style="color: #2aa198;">'value2'</span>}
<span style="color: #6c71c4;">r</span> = requests.get(<span style="color: #2aa198;">"http://httpbin.org/get"</span>, params=payload)
</pre>
</div>
</li>
<li>post
requests.post(url, data=None, **kwargs)
<ul class="org-ul">
<li>data: 是要post的数据
</li>
<li>kwargs: 可以使用headers =  {&#x2026;.}指定http request header
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">import</span> json
<span style="color: #6c71c4;">url</span> = <span style="color: #2aa198;">'https://api.github.com/some/endpoint'</span>
<span style="color: #6c71c4;">payload</span> = {<span style="color: #2aa198;">'some'</span>: <span style="color: #2aa198;">'data'</span>}
<span style="color: #6c71c4;">headers</span> = {<span style="color: #2aa198;">'content-type'</span>: <span style="color: #2aa198;">'application/json'</span>}

<span style="color: #6c71c4;">r</span> = requests.post(url, data=json.dumps(payload), headers=headers)
</pre>
</div>
</li>
<li>put
requests.put(url, **kwargs)
</li>
<li>response object
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">import</span> requests
<span style="color: #6c71c4;">r</span> = requests.get(<span style="color: #2aa198;">'http://www.baidu.com'</span>)
<span style="color: #859900;">print</span> r.text
<span style="color: #859900;">print</span> r.url
<span style="color: #859900;">print</span> r.encoding
<span style="color: #859900;">print</span> r.status_code                    <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">response status code(eg:200)</span>
<span style="color: #859900;">print</span> r.headers                        <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">a dict</span>
<span style="color: #859900;">print</span> r.headers[<span style="color: #2aa198;">'Content-Type'</span>]        <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">response headers</span>
<span style="color: #859900;">print</span> r.cookies[<span style="color: #2aa198;">'example_cookie_name'</span>] <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">cookies</span>
<span style="color: #859900;">print</span> r.json()                         <span style="color: #586e75; font-style: italic;">#  </span><span style="color: #586e75; font-style: italic;">built-in json function</span>

<span style="color: #859900;">print</span> r.request.headers         <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">http request headers</span>
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2">pip</h3>
<div class="outline-text-3" id="text-14-2">
<p>
从github安装包
pip install git+git://github.com/yourname/package.git
或者pip install git+<a href="https://github.com/yourname/package.git">https://github.com/yourname/package.git</a>
</p>
</div>
</div>

<div id="outline-container-sec-14-3" class="outline-3">
<h3 id="sec-14-3">pyquery</h3>
<div class="outline-text-3" id="text-14-3">
<p>
一个使用jquery语法的html解析器,非常方便,比BeautifulSoup好用,这是它的<a href="http://pythonhosted.org/pyquery/index.html">文档</a>
</p>
<div class="org-src-container">

<pre class="src src-python">form pyquery <span style="color: #859900;">import</span> PyQuery
<span style="color: #6c71c4;">html</span> = <span style="color: #2aa198;">'&lt;html&gt;&lt;title&gt;hello world&lt;/title&gt;&lt;/html&gt;'</span>
<span style="color: #6c71c4;">d</span> = PyQuery(html, parser = <span style="color: #2aa198;">'html'</span>)
d(<span style="color: #2aa198;">'title'</span>).text()
</pre>
</div>
<p>
在调用PyQuery时尽量指定parser, 因为默认判断有时会出错,比如用xml的parser去解析html会得到不正确的结果.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #6c71c4;">d</span> = PyQuery(html, parser = <span style="color: #2aa198;">'html'</span>)
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">selector</span>
d(<span style="color: #2aa198;">'body'</span>)
d(<span style="color: #2aa198;">'div#header'</span>)
d(<span style="color: #2aa198;">'div.class ul'</span>)
d(<span style="color: #2aa198;">'meta[name=keywords]'</span>) <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">attribute</span>

<span style="color: #6c71c4;">links</span> = d(<span style="color: #2aa198;">'div.links a'</span>)
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">&#35813;&#22788;&#24212;&#20351;&#29992;&#19979;&#26631;,&#32780;&#19981;&#26159;for link in links</span>
<span style="color: #859900;">for</span> i <span style="color: #859900;">in</span> <span style="color: #6c71c4;">range</span>(0, <span style="color: #6c71c4;">len</span>(links)):
    <span style="color: #859900;">print</span> links.eq(i).attr(<span style="color: #2aa198;">'href'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-14-4" class="outline-3">
<h3 id="sec-14-4">watchdog</h3>
<div class="outline-text-3" id="text-14-4">
<p>
看门狗,用来监控文件系统改变,这是<a href="http://pythonhosted.org/watchdog/">文档</a>, 基本使用:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">import</span> time
<span style="color: #859900;">from</span> watchdog.observers <span style="color: #859900;">import</span> Observer
<span style="color: #859900;">from</span> watchdog.events <span style="color: #859900;">import</span> LoggingEventHandler

<span style="color: #859900;">if</span> <span style="color: #6c71c4;">__name__</span> == <span style="color: #2aa198;">"__main__"</span>:
    <span style="color: #6c71c4;">event_handler</span> = LoggingEventHandler()
    <span style="color: #6c71c4;">observer</span> = Observer()
    observer.schedule(event_handler, path=<span style="color: #2aa198;">'.'</span>, recursive=<span style="color: #268bd2;">True</span>)
    observer.start()
    <span style="color: #859900;">try</span>:
        <span style="color: #859900;">while</span> <span style="color: #268bd2;">True</span>:
            time.sleep(1)
    <span style="color: #859900;">except</span> <span style="color: #268bd2;">KeyboardInterrupt</span>:
        observer.stop()
    observer.join()
</pre>
</div>
<p>
关键的部分有两个:
</p>
<ol class="org-ol">
<li>recursive=True,默认是False,如果不指定那么那么就不会监控子目录
</li>
<li>event_handler:这个是文件系统事件的处理对象,可以自己继承watchdog.events.FileSystemEventHandler,
然后重载<a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_created">on_create</a>d, <a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_deleted">on_deleted</a>, <a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_modified">on_modified</a>, <a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_moved">on_moved</a>,
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-14-5" class="outline-3">
<h3 id="sec-14-5">rauth</h3>
<div class="outline-text-3" id="text-14-5">
<p>
一个Oauth库,这是<a href="https://rauth.readthedocs.org/en/latest/">文档</a>, 这是一份示例
<a href="https://gist.github.com/yuyang0/5949932">代码</a>, 基本上照着流程走就OK了
</p>
</div>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">常用工具的使用方法</h2>
<div class="outline-text-2" id="text-15">
</div><div id="outline-container-sec-15-1" class="outline-3">
<h3 id="sec-15-1">virtualenv</h3>
<div class="outline-text-3" id="text-15-1">
<p>
这是一份不错的<a href="http://docs.python-guide.org/en/latest/dev/virtualenvs.html">tutorial</a>
</p>
<ol class="org-ol">
<li>virtualenv venv
</li>
<li>source venv/bin/activate
</li>
<li>deactivate
</li>
</ol>
<p>
virtualenvwrapper可以对virtualenv进行一定的增强
</p>
<ol class="org-ol">
<li>install
<pre class="example">
sudo pip install virtualenvwrapper
export WORKON_HOME=~/envs
source /usr/local/bin/virtualenvwrapper.sh
</pre>
</li>
<li>mkvirtualenv my_env
在WORKON_HOME中创建一个名为my_env虚拟环境
</li>
<li>workon my_env
切换到my_env环境
</li>
<li>deactivate
</li>
<li>lssitepackages
</li>
<li>lsvirtualenv
</li>
<li>rmvirtualenv my_env
</li>
</ol>

<p>
和zsh的整合：
安装virtualenvwrapper插件，然后在每一个仓库中放一个.venv文件，文件的内容
是你创建的env的名字
</p>
</div>
</div>

<div id="outline-container-sec-15-2" class="outline-3">
<h3 id="sec-15-2">ipython</h3>
<div class="outline-text-3" id="text-15-2">
<p>
ipython是一个增强的python interpreter,有许多有趣的功能
</p>
<ol class="org-ol">
<li>magic function
以 % 或者 %% 开头的都是magic function,其中
<ul class="org-ul">
<li>以%开头会将本行余下的部分作为一个参数传递给该命令,如果%automagic为on(默认), 那么可以省略前面的 %, 可以
使用 %lsmagic 来列出有多少这种命令.
</li>
<li>以%%开头的命令不仅会将本行余下的部分作为参数,本行下面独立的行也会作为参数
</li>
</ul>
</li>
<li>TAB补全, 可以补全内置的函数,模块以及变量文件名等等
</li>
<li>%run命令: 该命令可以用来运行脚本(实际是把所有的属性导入当前的namespace,和import功能类似),测试脚本时用该
命令,而不是import,因为该命令可以让改动立即生效,有以下几个选项:
<ul class="org-ul">
<li>t: 可以用来获得脚本的运行时间
</li>
<li>p: 性能分析,会列出程序中每个函数调用的时间, %prun命令与该选项功能相似,但是它是对一条python命令或者一个函数调
用进行性能测试
</li>
<li>d: 调试,激活pdb,并在开始处暂停,和gdb类似
</li>
</ul>
</li>
<li>剖析对象,给定一个对象,观察这个对象的文档,函数定义以及源代码,有以下命令
<ul class="org-ul">
<li>%pdoc: print doc string
</li>
<li>%pdef: print definition of function
</li>
<li>%psource: print source code
</li>
<li>%pfile: get file of this object
</li>
</ul>
</li>
<li>调试: %pdb命令会打开或关闭在任何未捕捉的异常点调用pdb调试器的功能, 如果该功能打开了,那么遇到任何未捕捉的
异常,会自动调用调试器,这样就可以打印异常点的变量值,执行代码了
</li>
<li>运行shell命令: !开头,比如 !ping www.baidu.com ,可以将shell命令的输出赋给python变量, 比如
output = !ping www..baidu.com, 那么output就会是ping的输出
</li>
</ol>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>DEFINITION NOT FOUND.</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<div id="disqus_comment">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
        var url = window.location.pathname;
        var disqus_identifier = url.substring(url.lastIndexOf('/')+1);
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'yuyang'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
<!-- begin footer -->
<div id="footer">
  <ul class="links vertical-nav">
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a class="back-to-top" href="#">Back to Top</a></li>
  </ul>
  <span>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</span>
  <a href="#" class="back-to-top" id="fixed-back-to-top" ></a>
</div>
<script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script type="text/javascript" src="static/js/custom.js"></script>
<!-- end footer -->
</div>
</body>
</html>
