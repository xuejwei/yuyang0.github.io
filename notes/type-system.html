<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-02-22 Mon 20:57 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Type System</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Yu Yang" />
<meta  name="keywords" content="type theory" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/>
<link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "%LINEBREAKS" },
                        webFont: "%FONT"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "%LINEBREAKS" },
              font: "%FONT"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "%AUTONUMBER"},
               MultLineWidth: "%MULTLINEWIDTH",
               TagSide: "%TAGSIDE",
               TagIndent: "%TAGINDENT"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.bootcss.com/mathjax/2.4.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="site-title"><a href="/"> 编码者言 </a></h1>
        <div>
          <a href="###" id="site-nav-btn">菜单</a>
          <ul id="site-nav" class="vertical-nav mobi-hid">
            <li> <a href="/">Home</a></li>
            <li> <a href="/about.html">About</a></li>

            <li> <a href="/tags.html">Tags</a></li>

            <li> <a href="/atom.xml">RSS</a></li>
          </ul>

          <form id="site-search" method="get" action="https://google.com/search">
            <input type="hidden" name="q" value="site:yuyang0.github.io" />
            <input type="text" name="q" placeholder="Search..." />
            <button class="btn-search" type="submit">Search</button>
          </form>
          <div style="clear:both;"> </div>
        </div>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">Type System</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">Concepts</a></li>
<li><a href="#orgheadline2">Safety = Progress + Preservation</a></li>
<li><a href="#orgheadline7">Simple Typed Lambda Calculus</a>
<ul>
<li><a href="#orgheadline3">Function type</a></li>
<li><a href="#orgheadline4">terms</a></li>
<li><a href="#orgheadline5">evaluation relation</a></li>
<li><a href="#orgheadline6">type relations</a></li>
</ul>
</li>
<li><a href="#orgheadline8">Type extensions</a>
<ul>
<li><a href="#orgheadline9">base type</a></li>
<li><a href="#orgheadline10">Unit</a></li>
<li><a href="#orgheadline11">pairs T<sub>1</sub> &times; T<sub>2</sub></a></li>
<li><a href="#orgheadline12">tuples {T<sub>1</sub> T<sub>2</sub> &#x2026;}</a></li>
<li><a href="#orgheadline13">records {l<sub>i</sub> = T<sub>i</sub> &#x2026;}</a></li>
<li><a href="#orgheadline14">sums T<sub>1</sub> + T<sub>2</sub></a></li>
<li><a href="#orgheadline15">variants &lt;l<sub>i</sub>:T<sub>i</sub> &#x2026;&gt;</a></li>
<li><a href="#orgheadline16">recursive function</a></li>
<li><a href="#orgheadline17">Lists (List T)</a></li>
</ul>
</li>
<li><a href="#orgheadline18">Reference</a>
<ul>
<li><a href="#orgheadline19">type rules</a></li>
</ul>
</li>
<li><a href="#orgheadline20">Subtype</a>
<ul>
<li><a href="#orgheadline21">function</a></li>
<li><a href="#orgheadline22">record</a></li>
<li><a href="#orgheadline23">variant</a></li>
<li><a href="#orgheadline24">reference</a></li>
<li><a href="#orgheadline25">The Top and Bottom types</a></li>
<li><a href="#orgheadline26">STLC</a></li>
<li><a href="#orgheadline27">OOP</a></li>
</ul>
</li>
<li><a href="#orgheadline34">Polymorphism</a>
<ul>
<li><a href="#orgheadline28">concepts</a></li>
<li><a href="#orgheadline29">Parameter Polymorphism</a>
<ul>
<li><a href="#orgheadline30">system F</a></li>
</ul>
</li>
<li><a href="#orgheadline32">ad-hoc polymorphism</a>
<ul>
<li><a href="#orgheadline31">Overload</a></li>
</ul>
</li>
<li><a href="#orgheadline33">subtype Polymorphism</a></li>
</ul>
</li>
<li><a href="#orgheadline38">Recursive Type</a>
<ul>
<li><a href="#orgheadline35">An Example(number list)</a></li>
<li><a href="#orgheadline36">fix combinator</a></li>
<li><a href="#orgheadline37">fold and unfold</a></li>
</ul>
</li>
<li><a href="#orgheadline40">Type Inference</a>
<ul>
<li><a href="#orgheadline39">Unification Algorithm</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">Concepts</h2>
<div class="outline-text-2" id="text-orgheadline1">
<ol class="org-ol">
<li><b>type</b>: type is a name for a collection of values(actually it also
defines a collection of operations on these values). In general, if two
things below to two different types, they can't be the same.</li>
<li><b>type system</b>: A type system is a set of types and the rules that gave
their use in programs.</li>
<li><b>normal form</b>: A term is in normal form if no evaluation rule applies to
it. Every value is in normal form.but not every term in normal form is a
value.</li>
<li><b>closed term</b>: A term without free variables is said to be closed.</li>
<li><b>diverges</b>: if eval<sub>v</sub>(M) does not exist, we say that M diverges.</li>
<li><b>stuck</b>: A closed term is stuck if it is in normal form but not a value.</li>
<li><b>redex</b>: reducible expression. One can think redex as the subexpression
reduced by evaluation relation.</li>
<li><b>context</b>: The text surrounding a redex is its context.</li>
<li><b>strict</b>: The arguments of a function are always evaluated whether they
are used by the body of the function. The call by value strategy is strict.</li>
<li><b>non-strict(aka lazy)</b>: Evaluate only the arguments which are actually
used.The Call By Name and Call By Need strategy is non-strict.</li>
<li><b>typeable(aka well-typed)</b>: A term <code>t</code> is well-typed if there is some T such
that <code>t:T</code>.</li>
<li><b>safety(aka soundness)</b>: well-typed terms doesn't ``go wrong''.</li>
<li><b>untyped language</b>: if a language only consists of an expression gammar
and a reduction relation, it is a untyped language.</li>
<li><b>transparent type</b>: aka concrete type.</li>
<li><b>Opaque type</b>: aka abstract type.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">Safety = Progress + Preservation</h2>
<div class="outline-text-2" id="text-orgheadline2">
<ul class="org-ul">
<li>Progress: A well-typed term is not stuck (either it is a value or it can
take a step according to the evaluation rules).</li>
<li>Preservation: If a well-typed term takes a step of evaluation, then the
resulting term is also well typed.</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7">Simple Typed Lambda Calculus</h2>
<div class="outline-text-2" id="text-orgheadline7">
</div><div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">Function type</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
The type of a function should describe the type of the argument and the
type of the function body.
</p>
\begin{displaymath}
  \frac{\Gamma , x:T_1 \vdash t:T_2}{\Gamma \vdash \lambda x . t :T_1 \rightarrow T_2}
\end{displaymath}

<p>
One can think &rarr; as a type constructor which consumes two types and
produces a function type.
</p>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">terms</h3>
<div class="outline-text-3" id="text-orgheadline4">
\begin{eqnarray*}
  t ::= &                   &\textrm{terms}\\
        & x                 &\textrm{variable}\\
        & \lambda x:T.t     &\textrm{abstraction}\\
        & tt                &\textrm{application} \\
  v ::= &                   &\textrm{values} \\
        & \lambda x:T.t     &\textrm{abstraction value} \\
  T ::= &                   &\textrm{types} \\
        & T \rightarrow T   &\textrm{function type}\\
  \Gamma ::=&               &\textrm{type context}\\
            & \emptyset     &\textrm{empty context} \\
            & \Gamma , x:T  &\textrm{term variable binding}
\end{eqnarray*}

<ul class="org-ul">
<li><code>t</code> define the terms(expressions) of the STLC</li>
<li><code>v</code> define the set of value(only contains function)</li>
<li><code>T</code> define the set of type(only contains function type)</li>
<li>\(\Gamma\) is the type context, also known as type environment.</li>
<li>\(\vdash\) is a relation which maps a type environment and a term to a
type.</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">evaluation relation</h3>
<div class="outline-text-3" id="text-orgheadline5">
\begin{eqnarray*}
  & \frac{t_1 \rightarrow t_1'}{t_1 t_2 \rightarrow t_1' t_2} \qquad &\textrm{(E-APP1)}\\
  & \frac{t_2 \rightarrow t_2'}{v_1 t_2 \rightarrow v_1 t_2'} \qquad &\textrm{(E-APP2)}\\
  & (\lambda x:T_{11}.t_{12})v_2 \rightarrow t_{12}[x \leftarrow v_2] \qquad &\textrm{(E-APPABS)}
\end{eqnarray*}
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">type relations</h3>
<div class="outline-text-3" id="text-orgheadline6">
\begin{eqnarray*}
  & \frac{x:T \in \Gamma}{\Gamma \vdash x:T} &\textrm{(T-VAR)} \\
  & \frac{\Gamma, x:T_1 \vdash t_2 : T_2}{\Gamma \vdash \lambda x:T_1.t_2 : T_2} &\textrm{(T-ABS)} \\
  & \frac{\Gamma \vdash t_1 : T_1\rightarrow T_2 \qquad \Gamma \vdash t_2:T_1}{\Gamma \vdash t_1 t_2 :T_2} &\textrm{(T-APP)}
\end{eqnarray*}
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8">Type extensions</h2>
<div class="outline-text-2" id="text-orgheadline8">
<p>
STLC实际上限制了 lambda calculus 的表达能力,比如说在 STLC中不能定义递归函数,
不能编码 pair等等,但是为了给该语言添加这种表现力,我们可以直接向语言中添加一
些基本构造,比如为了定义递归函数,我们可以直接添加一个 <code>fix</code> 函数.为了编码
<code>pair</code> 我们可以直接将 mkpiar,fst,snd作为扩展添加进语言中.
</p>
</div>
<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">base type</h3>
<div class="outline-text-3" id="text-orgheadline9">
<p>
int, char, etc
</p>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10">Unit</h3>
<div class="outline-text-3" id="text-orgheadline10">
<p>
Unit type is another base type. statements or expressions which are used to
perform side affect return Unit type. One can think Unit type means no
type.
</p>
\begin{eqnarray*}
  & \Gamma \vdash unit:Unit & \\
  & t_1;t_2 \overset{def}{=} (\lambda x:Unit. t_2)\ t_1 & \qquad where \ x \notin \mathcal{FV}(t_2)
\end{eqnarray*}
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11">pairs T<sub>1</sub> &times; T<sub>2</sub></h3>
<div class="outline-text-3" id="text-orgheadline11">
<p>
One can think pair as a special case of tuple which only has two
elements. The type rule of pair is as follows:
</p>
\begin{eqnarray*}
  t ::= &...                &\textrm{terms}\\
        & \{t, t\}          &\textrm{pair}\\
        & t.1               &\textrm{first projection}\\
        & t.2               &\textrm{second projection}\\
  v ::= &...                &\textrm{values}\\
        &\{v, v\}           &\textrm{pair value}\\
  T ::= &...                &\textrm{types}\\
        & T_1 \times T_2    &\textrm{pair type}
\end{eqnarray*}

<p>
evaluation rules:
</p>
\begin{eqnarray*}
  & \{v_1, v_2\}.1 \rightarrow v_1 \\
  & \{v_1, v_2\}.2 \rightarrow v_2 \\
  & \frac{t \rightarrow t'}{t.1 \rightarrow t'.1} \\
  & \frac{t \rightarrow t'}{t.2 \rightarrow t'.2} \\
  & \frac{t_1 \rightarrow t_1'} {\{t_1, t_2\} \rightarrow \{t_1', t_2\}}  \\
  & \frac{t_2 \rightarrow t_2'} {\{v_1, t_2\} \rightarrow \{v_1, t_2'\}}
\end{eqnarray*}

<p>
type rules
</p>
\begin{eqnarray*}
  & \frac{\Gamma \vdash t_1:T_1 \qquad \Gamma \vdash t_2:T_2}{\Gamma \vdash \{t_1,t_2\}: T_1 \times T_2} &\textrm{(T-PAIR)}\\
  & \frac{\Gamma \vdash t:T_1 \times T_2}{\Gamma \vdash t.1 : T_1} &\textrm{(T-PROJ1)}\\
  & \frac{\Gamma \vdash t:T_1 \times T_2}{\Gamma \vdash t.2 : T_2} &\textrm{(T-PROJ2)}
\end{eqnarray*}
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">tuples {T<sub>1</sub> T<sub>2</sub> &#x2026;}</h3>
<div class="outline-text-3" id="text-orgheadline12">
<p>
t1:T1, t2:T2, t3:T3 ==&gt; (t1 t2 t3 &#x2026;.) : T1 * T2 * T3 * &#x2026;
</p>

<p>
The type of aa tuple can also write as: {T1 T2 T3 &#x2026;}
</p>

<p>
type rules:
</p>
\begin{eqnarray*}
  & \frac{for \ each i \quad \Gamma \vdash t_i:T_i}{\Gamma \vdash \{{t_i}^{i\in 1..n}\}:\{{T_i}^{i \in 1..n}\}} &\textrm{(T-TUPLE)}\\
  & \frac{\Gamma \vdash t:\{{T_i}^{i \in 1..n}\}}{\Gamma \vdash t.j:T_j} &\textrm{(T-PROJ)}
\end{eqnarray*}
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">records {l<sub>i</sub> = T<sub>i</sub> &#x2026;}</h3>
<div class="outline-text-3" id="text-orgheadline13">
<p>
like the ``struct'' statement in C. every field has a name. while tuple uses
the index to fetch the field, record uses the name to fetch the field
</p>

<p>
{cost=30.27,partno=5524} : {cost=Float, partno=Int}
</p>

<p>
terms,values,types:
</p>
\begin{eqnarray*}
  t ::= & ...                      &\textrm{terms} \\
        & \{l_i={t_i}^{i \in 1..n} \}     &\textrm{record} \\
        & t.l                      &\textrm{projection}  \\
  v ::= & ...                      &\textrm{values}  \\
        & \{l_i={v_i}^{i \in 1..n} \}     &\textrm{record value}  \\
  T ::= & ...                      &\textrm{types}   \\
        & \{l_i={T_i}^{i \in 1..n} \}     &\textrm{record type} \\
\end{eqnarray*}

<p>
evaluation rules
</p>
\begin{eqnarray*}
  & \frac{t_j \rightarrow t_j'}{\{ {l_i=v_i}^{i \in 1..j-1}, l_j=t_j, {l_k=t_k}^{k \in j+1..n}\} \rightarrow} \\
  &   \{ {l_i=v_i}^{i \in 1..j-1}, l_j=t_j', {l_k=t_k}^{k \in j+1..n}\} \\
  & \frac{t \rightarrow t'}{t.l_i \rightarrow t'.l_i}       \\
  & \{ {l_i=v_i}^{i \in 1..n}\}.l_i \rightarrow v_i
\end{eqnarray*}

<p>
type rules:
</p>
\begin{eqnarray*}
  & \frac{for \ each \ \Gamma \vdash t_i:T_i}{\Gamma \vdash \{ {l_i=t_i}^{i \in 1..n}\}:\{ {l_i=T_i}^{i \in 1..n}\}} \\
  & \frac{\Gamma \vdash t:\{ {l_i=T_i}^{i \in 1..n}\}}{\Gamma \vdash t.l_i : T_i}   \\
\end{eqnarray*}
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14">sums T<sub>1</sub> + T<sub>2</sub></h3>
<div class="outline-text-3" id="text-orgheadline14">
<p>
sums is a special case of variants which has only two variants.
</p>

<p>
T1 + T2
</p>

<p>
type rules:
</p>
\begin{eqnarray*}
  & \frac{\Gamma \vdash t:T_1}{\Gamma \vdash inl \ t:T_1 + T_2}  \\
  & \frac{\Gamma \vdash t:T_2}{\Gamma \vdash inr \ t:T_1 + T_2}  \\

  & \frac{\Gamma \vdash t:T_1 + T_2 \quad \Gamma, x_1:T_1 \vdash t_1:T \quad \Gamma, x_2:T_2 \vdash t_2:T}
       {\Gamma \vdash case\ t\ of\  x_1 \Rightarrow t_1 | inr\ x_2 \Rightarrow t_2 :T}
\end{eqnarray*}
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15">variants &lt;l<sub>i</sub>:T<sub>i</sub> &#x2026;&gt;</h3>
<div class="outline-text-3" id="text-orgheadline15">
<p>
This data type has serveral variants. every variant is tagged with a
label. through these tags, we can use a case expression to deconstruct the
data type. this data type is also called disjoint Unions(not Union, Union
represents the untagged variant, like the ``union'' statement in C).
</p>

<p>
for example, the lambda expression type has three variants: identifier,
function expression and application expression, each also is a type. so you
can think the lambda expression type is the disjoint Unions of the three
types.because all the elements in this three types are also in lambda
expression type.
</p>

<p>
type rules:
</p>
\begin{eqnarray*}
  \frac{\Gamma \vdash t_j:T_j}{\Gamma \vdash \langle l_j=t_j\rangle \ as \
    \langle l_i:{T_i}^{i \in 1..n} \rangle : \langle l_i:{T_i}^{i \in 1..n} \rangle}  &\textrm{(T-VARIANT)}\\
  \Gamma \vdash t_0: \langle l_i:{T_i}^{i \in 1..n} \rangle  \\
  \frac{for \ each \ i \quad \Gamma,x_i:T_i \vdash t_i:T}
  {\Gamma \vdash case \ t_0 \ of \ \langle l_i=x_i \rangle \Rightarrow {t_i}^{i \in 1..n} :T}  &\textrm{(T-CASE)}
\end{eqnarray*}
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16">recursive function</h3>
<div class="outline-text-3" id="text-orgheadline16">
<p>
add <code>fix</code> to the language.
</p>
\begin{equation}
  \frac{\Gamma \vdash t:T\rightarrow T}{\Gamma \vdash fix \ t :T}
\end{equation}
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17">Lists (List T)</h3>
<div class="outline-text-3" id="text-orgheadline17">
<p>
e1:T, e2:T, e3:T &#x2026; ==&gt; (e1 e2 e3 &#x2026;) : List T
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-2">
<h2 id="orgheadline18">Reference</h2>
<div class="outline-text-2" id="text-orgheadline18">
<ol class="org-ol">
<li>&mu;: the state of the store. One can think &mu; as a map from location to
expressed value</li>
<li>&Sigma;: store typing. One can think &Sigma; as a map from location to
type. the reason why we need &Sigma; is that without the help of
&Sigma;,everytime we need the type of a location, we must calculate the
type of the content pointed by this location.</li>
</ol>
\begin{eqnarray*}
  t ::= &                &\textrm{terms}\\
        & x              &\textrm{variable}\\
        & \lambda x:T.t  &\textrm{abstraction}\\
        & t\ t           &\textrm{application}\\
        & unit           &\textrm{constant unit}\\
        & ref \ t        &\textrm{new reference}\\
        & !t             &\textrm{dereference}\\
        & t := t         &\textrm{assignment}\\
        & l              &\textrm{store location} \\
  v ::= &                &\textrm{values}\\
        & \lambda x:T.t  &\textrm{function value}\\
        & unit           &\textrm{constant unit}\\
        & l              &\textrm{store location}\\
  T ::= &                &\textrm{types}\\
        & T \rightarrow T   &\textrm{function type}\\
        & Unit              &\textrm{unit type}\\
        & Ref \ T             &\textrm{type of reference cell}\\
  \Gamma ::= &              &\textrm{type context}\\
             & \emptyset    &\textrm{empty context}\\
             & \Gamma,x:T   &\textrm{varible binding}\\
  \mu ::= &                 &\textrm{store}\\
          & \emptyset       &\textrm{empty store}\\
          & \mu,l=v         &\textrm{location binding}\\
  \Sigma ::= &              &\textrm{store typings}\\
             & \emptyset    &\textrm{empty store typing}\\
             & \Sigma,l:T   &\textrm{location typing}
\end{eqnarray*}
</div>

<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19">type rules</h3>
<div class="outline-text-3" id="text-orgheadline19">
\begin{eqnarray*}
  & \frac{x:T \in \Gamma}{\Gamma | \Sigma \vdash x:T} &\textrm{(T-VAR)} \\
  & \frac{\Gamma,x:T_1|\Sigma \vdash t_2:T_2}{\Gamma | \Sigma \vdash \lambda x:T_1.t_2:T_1 \rightarrow T_2}  &\textrm{(T-ABS)}    \\
  & \frac{\Gamma | \Sigma \vdash t_1:T_1\rightarrow T_2 \qquad \Gamma | \Sigma \vdash t_2:T_1}{\Gamma | \Sigma \vdash t_1t_2:T_2}  &\textrm{(T-APP)}\\
  & \Gamma | \Sigma \vdash unit:Unit  &\textrm{(T-UNIT)}  \\
  & \frac{\Sigma(l)=T_1}{\Gamma | \Sigma \vdash l:Ref \ T_1}   &\textrm{(T-LOC)}\\
  & \frac{\Gamma | \Sigma \vdash t_1:T_1}{\Gamma | \Sigma \vdash ref\ t_1:Ref \ T_1}   &\textrm{(T-REF)} \\
  & \frac{\Gamma | \Sigma \vdash t:Ref \ T}{\Gamma | \Sigma \vdash !t:T}    &\textrm{(T-DEREF)}     \\
  & \frac{\Gamma | \Sigma \vdash t_1:Ref \ T \qquad \Gamma | \Sigma \vdash t_2:T}{\Gamma | \Sigma \vdash t_1:=t_2:Unit}   &\textrm{(T-ASSIGN)}
\end{eqnarray*}
</div>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-2">
<h2 id="orgheadline20">Subtype</h2>
<div class="outline-text-2" id="text-orgheadline20">
<p>
if S is the Subtype of T, any term of type S can safely be used in a
context where a term of type T is expected.
</p>

<p>
S &lt;: T means S is the subtype of T, One can think S is a subset of T.
</p>
</div>

<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21">function</h3>
<div class="outline-text-3" id="text-orgheadline21">
<p>
The subtype rule of function type is as follows:
</p>
\begin{displaymath}
  \frac{T_1 <: S_1 \qquad S_2 <: T_2}{S_1 \rightarrow S_2 <: T_1 \rightarrow T_2}
\end{displaymath}

<p>
the inverse Lemma:
</p>
\begin{displaymath}
  \frac{S_1 \rightarrow S_2 <: T_1 \rightarrow T_2}{T_1 <: S_1 \qquad S_2 <: T_2}
\end{displaymath}
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-3">
<h3 id="orgheadline22">record</h3>
</div>
<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23">variant</h3>
</div>
<div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24">reference</h3>
<div class="outline-text-3" id="text-orgheadline24">
\begin{displaymath}
  \frac{S_1 <: T_1 \qquad T_1 <: S_1}{Ref\ S_1 <: Ref \ T_1}
\end{displaymath}

<p>
since reference can be used for reading and writing, so S<sub>1</sub> and T<sub>1</sub> should
be equivalent in substype relation.
</p>
</div>
</div>

<div id="outline-container-orgheadline25" class="outline-3">
<h3 id="orgheadline25">The Top and Bottom types</h3>
<div class="outline-text-3" id="text-orgheadline25">
<ol class="org-ol">
<li><b>Top</b> is the super type of all the types</li>
<li><b>Bot</b> is a subtype of every type</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26">STLC</h3>
<div class="outline-text-3" id="text-orgheadline26">

<div class="figure">
<p><img src="static/img/STLC-subtyping.png" alt="STLC-subtyping.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27">OOP</h3>
<div class="outline-text-3" id="text-orgheadline27">
<p>
In a OOP language, t<sub>1</sub> is subtype of t<sub>2</sub> if:
</p>
<ol class="org-ol">
<li>t<sub>1</sub> and t<sub>2</sub> are all <b>classes</b> and t<sub>1</sub> is subclass of t<sub>2</sub></li>
<li>t<sub>1</sub> is a <b>class</b> and t<sub>2</sub> is an <b>interface</b>, and t<sub>1</sub> or one of its
superclasses implements t<sub>2</sub>.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline34" class="outline-2">
<h2 id="orgheadline34">Polymorphism</h2>
<div class="outline-text-2" id="text-orgheadline34">
</div><div id="outline-container-orgheadline28" class="outline-3">
<h3 id="orgheadline28">concepts</h3>
<div class="outline-text-3" id="text-orgheadline28">
<ol class="org-ol">
<li><b>Polymorphism</b>: in <b>function</b> programming language, Polymorphism usually
denotes <b>Parameter Polymorphism</b>, however in <b>Object-oriented</b>
programming language, it usually denotes the <b>subtype Polymorphism</b> and
the term <b>generics(泛型)</b> is used to denote parameter polymorphism.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29">Parameter Polymorphism</h3>
<div class="outline-text-3" id="text-orgheadline29">
<p>
这种多态一般意味着: 函数不需要知道参数的具体类型, 比如说haskell 中的一个计
算list长度的函数length,length的类型很显然是 \([\alpha] \rightarrow int\)
(\([\alpha]\) 可以看作是 \((\forall \alpha )[\alpha]\) 的简写), length并不需要
知道参数到底是[int],[char]或者[float], length对于这些类型都是同一种操作方式
</p>

<p>
就像使用 &lambda; 来提供抽象,使得我们可以定义函数,而这个函数可以对不同的
value作出反应, 对type我们也可以采用类似的方法.用&Lambda; 来提供抽象使得一个
definition可以对多个type作出反应,以swap函数为例,它会交换一个pair中first与
second位置的元素, swap的定义如下:
</p>
\begin{displaymath}
  swap = \Lambda \alpha . \Lambda \beta . \lambda p : (\alpha \times \beta) . \langle snd \  p , fst \  p \rangle
\end{displaymath}

<p>
该函数的type如下:
</p>
\begin{displaymath}
  \vdash swap : (\forall \alpha . (\forall \beta . ((\alpha \times \beta) \rightarrow (\beta \times \alpha))))
\end{displaymath}

<p>
如果要交换的pair的type是 \(bool \times int\), 那么就可以将这两个type应用到
swap上,也就是 \(swap[bool][int]\) 这样就可以得到类型正确的swap函数了.
</p>

<p>
在比如说 identity 函数
</p>
\begin{displaymath}
  id = \Lambda \alpha . \lambda x: \alpha . x
\end{displaymath}

<p>
identity函数的类型就是
</p>
\begin{displaymath}
  \vdash id : (\forall \alpha. (\alpha \rightarrow \alpha))
\end{displaymath}

<p>
前面说过,STLC实际上限制了 untyped lambda calculus的表达能力, STLC不能编码
pair,list,不能定义递归函数等等,当我们引入了 &Lambda; 抽象后, 这些问题就都解
决了. 比如编码list:
</p>
</div>
<div id="outline-container-orgheadline30" class="outline-4">
<h4 id="orgheadline30">system F</h4>
<div class="outline-text-4" id="text-orgheadline30">

<div class="figure">
<p><img src="static/img/system-F.png" alt="system-F.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline32" class="outline-3">
<h3 id="orgheadline32">ad-hoc polymorphism</h3>
<div class="outline-text-3" id="text-orgheadline32">
</div><div id="outline-container-orgheadline31" class="outline-4">
<h4 id="orgheadline31">Overload</h4>
<div class="outline-text-4" id="text-orgheadline31">
<p>
这种多态对不同的类型有不同的操作方式,比如haskell的 <code>+</code> 操作,该操作可以应用
于int, float等等, 但是对于每一种类型它都有一套特有的操作方式,也就是需要重载.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline33" class="outline-3">
<h3 id="orgheadline33">subtype Polymorphism</h3>
<div class="outline-text-3" id="text-orgheadline33">
<p>
Mostly used in Object-oriented language.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline38" class="outline-2">
<h2 id="orgheadline38">Recursive Type</h2>
<div class="outline-text-2" id="text-orgheadline38">
</div><div id="outline-container-orgheadline35" class="outline-3">
<h3 id="orgheadline35">An Example(number list)</h3>
<div class="outline-text-3" id="text-orgheadline35">
<p>
An number list is either
</p>
<ul class="org-ul">
<li>null or</li>
<li>(cons n l) where n is a number and l is a list of number.</li>
</ul>
<p>
what is the type of the number list? The \(List_{num}\) must obey the
following equation:
</p>
\begin{displaymath}
  List_{num} = (bool + (num \times List_{num}))
\end{displaymath}

<p>
but like the recusive function, you can't reference the type itself when
you define it. so you can't use \(List_{num}\) on the right side of the
equation. but we can use the same skill like we define the recusive
function: we can define tfix(the type fix combinator), so the \(List_{num}\)
can define like this:
</p>
\begin{displaymath}
  List_{num} \dot{=}_{} tfix(\forall \alpha .(bool + (num \times \alpha)))
\end{displaymath}

<p>
by convention a <code>tfix</code> an its following &forall; are collapsed together to a
single &mu;, &mu; is a explicit recursive operator for types. one can
think &mu; is like letrec.
</p>
\begin{displaymath}
  List_{num} \dot{=}_{} \mu \alpha(bool + (num \times \alpha))
\end{displaymath}

<p>
a type constructed by &mu; is a <b>recursive type</b>.
</p>
</div>
</div>
<div id="outline-container-orgheadline36" class="outline-3">
<h3 id="orgheadline36">fix combinator</h3>
<div class="outline-text-3" id="text-orgheadline36">
\begin{displaymath}
  fix_T = \lambda f:T \rightarrow T.(\lambda x:(\mu A.A \rightarrow T) .f (x\ x)) (\lambda x:(\mu A.A \rightarrow T). f (x\ x))
\end{displaymath}
</div>
</div>

<div id="outline-container-orgheadline37" class="outline-3">
<h3 id="orgheadline37">fold and unfold</h3>
<div class="outline-text-3" id="text-orgheadline37">
<p>
In many language, there is no explicit <code>fold</code> and <code>unfold</code> keyword. instead
each use of a constructor to create a value implies a <code>fold</code>, and each use
of a constructor in a pattern match implies <code>unfold</code>. The type rules for
<code>fold</code> and <code>unfold</code> is as follows:
</p>
\begin{displaymath}
  \frac{\Gamma \vdash M:T[A \leftarrow (\mu A.T)]}{\Gamma \vdash (fold \ M) : (\mu A.T)}
  \qquad
  \frac{\Gamma \vdash M:(\mu A.T)}{\Gamma \vdash (unfold \ M) : T[A \leftarrow (\mu A.T)]}
\end{displaymath}

\begin{eqnarray}
  List_\tau &\dot{=}& \mu \alpha . (bool + (\tau \times \alpha)) \\
  UList_\tau &\dot{=}& (bool + (\tau \times List_\tau))
\end{eqnarray}
</div>
</div>
</div>

<div id="outline-container-orgheadline40" class="outline-2">
<h2 id="orgheadline40">Type Inference</h2>
<div class="outline-text-2" id="text-orgheadline40">
</div><div id="outline-container-orgheadline39" class="outline-3">
<h3 id="orgheadline39">Unification Algorithm</h3>
<div class="outline-text-3" id="text-orgheadline39">
<p>
unification consumes a set of constraints and either:
</p>
<ul class="org-ul">
<li>identifies inconsistencies amongst the constraints or</li>
<li>generate a substitution that represent the solution of the constraints.</li>
</ul>

<p>
The algorithm is as follows(Assume the constraint has the form: X=Y):
</p>
<ol class="org-ol">
<li>Push all the constraints to a stack and generate an empty substitution.</li>
<li>If X and Y are identical identifiers, do nothing.</li>
<li>If X is an identifier, replace all occurrences of X by Y both on the
stack and in the substitution, and add X → Y to the substitution.</li>
<li>If Y is an identifier, replace all occurrences of Y by X both on the
stack and in the substitution, and add Y → X to the substitution.</li>
<li>If X is of the form C(X1 , . . . , Xn ) for some constructor C,4 and Y
is of the form C(Y1 , . . . ,Yn ) (i.e., it has the same constructor),
then push Xi = Yi for all 1 ≤ i ≤ n onto the stack.</li>
<li>Otherwise, X and Y do not unify. Report an error.</li>
</ol>

<p>
实际中在实现一个类型推导的过程是这样的:
</p>
<ol class="org-ol">
<li>先将 substitution 应用到 X 与 Y, 也就是替换 X 与 Y 中已在 substitution
中绑定的 type variable.</li>
<li>如果 X 与 Y 相等,那么什么也不做</li>
<li>如果 X 是标识符,那么先检查 Y 中是否包含 X, 如果包含那么就是一个错误,因为
一个像这样的方程是无解的: \(X = X \rightarrow int\),如果不包含,那么将
substitution 中每一个方程的右边部分中出现的 X 用 Y替换掉, 然后把 X=Y 添
加进 substitution中</li>
<li>如果 Y是标识符,同第三条,只是方向相反.</li>
<li>如果 X 与 Y都是复合类型, 比如说函数类型, record 类型等等, 那么先拆解</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<!-- 多说评论框 start -->
  <div id="duoshuo-id" class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
   var url = window.location.pathname;
   var duoshuo_identifier = url.substring(url.lastIndexOf('/')+1);
   if (!!! duoshuo_identifier) {
     duoshuo_identifier = "index.html";
   }
   var title = document.title;
   var ele = document.getElementById("duoshuo-id");
   ele.setAttribute("data-thread-key", duoshuo_identifier);
   ele.setAttribute("data-title", title);
   ele.setAttribute("data-url", url);

</script>

<script type="text/javascript">
var duoshuoQuery = {short_name:"yuyang0"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementById('postamble')
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end --><!-- begin footer -->
<div id="footer">
  <ul class="links vertical-nav">
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a class="back-to-top" href="#">Back to Top</a></li>
  </ul>
  <span>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</span>
  <a href="#" class="back-to-top" id="fixed-back-to-top" ></a>
</div>
<script src="http://apps.bdimg.com/libs/jquery/2.0.0/jquery.min.js"></script>
<script type="text/javascript">
	window.jQuery || document.write('<script src="static/js/jquery-2.0.0.min.js"><\/script>');
	</script>
<script type="text/javascript" src="static/js/custom.js"></script>
<!-- end footer -->
</div>
</body>
</html>
